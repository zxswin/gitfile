一.let 和 const
1.let命令:用来声明一个变量,和var非常类似。
2.const命令：用来声明一个常量,常量就是不可用变化的量。
3.使用let声明的变量,所声明的变量只有在命令所在的代码块内有效。
4.使用let命令声明的变量在域解析的时候不会被提升。
5.暂时性死区
  let f=10;
  function fn(){
     f=7;//暂时性死区
     let f=2;
  };
  fn();
6.let 不运行在同一个作用域下声明已经存在的变量
7.利用let获取循环时候每个i的值
  for(let i=0;i<btns.length;i++){
     btn[i].onclick=function(){
        console.log(i);
     };
  }
8.在循环语句内是一个父作用域,在循环体之中是一个子作用域。
  for(let i=0;i<3;i++){//和循环体中的i是分离的
     let i=10;
     console.log(i);
  }
  console.log(i);//报错,因为for中的i变量不会泄露到外面

9.const声明的变量只有在所在的代码块内有效
  声明的常量不会被提示
  不能声明已经被声明过的常量或者变量
  声明的时候必须赋值
  声明的常量储存简单的数据类型时候不可改变其值,如果储存的是对象,那么
  引用不可被改变,至于对象里的数据如何变化,是没有关系的。

  //会报错的
  const a =1;
  a={};

  //不会报错的
  const obj={a:10};
  obj.a=20;

二.变量的解构赋值
1.基本概念
  本质上就是一种匹配模式,只要等号两边的模式相同,那么左边的变量就可以被赋予对应的值。
2.结构赋值主要分为：
  数组的解构赋值
  对象的解构赋值
  基本类型的解构赋值
  //数组的解构赋值
  let [a,b,c]=[1,2,3];
  console.log(a,b,c);//1,2,3

  let [a,[[b],c]]=[1,[[2],3]];
  console.log(a,b,c);//1,2,3;

  let [,,c]=[1,2,3];
  console.log(c);//3

  let [x]=[];
  console.log(x);//undefined;

  let[y=1]=[];
  console.log(y);//1

  //对象的解构赋值
  let {a,b}={b:'bbb',a:'aaa'};
  console.log(a,b);//aaa,bbb

  let {a:b}={a:1};
  console.log(b);//1
  console.log(a);//报错

  //基本类型的解构赋值
  let [a,b,c,d]='1234';
  console.log(a,b,c,d);//1,2,3,4

  let {length:len}='miaov';
  console.log(len);//5;

  let {toString:ts}=1;
  let {toString:bs}=true;

  console.log(ts===Number.prototype.toString);//true
  console.log(bs===Boolean.prototype.toString);//true

  //null 和 underfined 不能进行解构赋值
  let [a]=null;//报错

三.数据结构Set(里面的数据是不重复的)
1.ES6提供了数据结构Set.它类似于数组,但是成员的值都是唯一的,没有重复的值。
2.创建一个Set
  const s=new Set([1,2,3]);
  console.log(s);//Set(3){1,2,3}
3.Set类的属性
console.log(s,size);//3
4.Set类的方法
  set.add(value) 添加一个数据,返回Set结构本身。
  s.add('a').add('b').add('c');
  console.log(s);

  set.delete(value) 删除指定数据,返回一个布尔值,表示删除是否成功。
  console.log(s.delete('a'));//true
  console.log(s);
  console.log(s.delete('a'));//false

  set.has(value) 判断该值是否为Set成员,返回一个布尔值
  console.log(s.has('a'));//false
  console.log(s.has(1));//true

  set.clear()清除所有数据,没有返回值
  s.clear();
  console.log(s);

  keys()返回键名的遍历器(key和value是一样的)
  console.log(s.keys());

  values()返回键值得遍历器(key和value是一样的)
  console.log(s.values());

  entries()返回键值对的遍历器
  console.log(s.entries());

  forEach()使用回调函数遍历每个成员
  forEach(function(){
     console.log(value+'miaov');
  });
  console.log(s);

四.数据结构Map
1.字典;是用来储存不重复key的Hash结构,不同于集合(Set)的是,字典使用的是[键,值]的形式类储存数据的
2.js的对象object:{}只能使用字符串来作为键。这给它的使用带来了很大的限制。
  var data1={a:1},data2={b:2},obj={};
  obj[data1]=1;
  obj[data2]=2;
  console.log(obj);
  console.log(data2.toString()===data2.toString);//true
3.Map的键的范围不限于字符串,各种类型的值(包括对象)都可以作为键。
  object提供了“字符串-值”的对应,Map是“值-值”的对应
  是一种更完善的Hash结构实现。
4.创建一个Map
const map=new Map([
  ['a',1],
  ['b',2]
]);
console.log(map);
5.Map类的属性
console.log(map.size);
6.set(key,value)设置key对应的value值。返回Map结构。
  如果key已经有值,则键值会被更新,否则就生成新的键
  map.set('miaov','ketang').set('new','fq').set('miaov'.'leo');
  console.log(map);
7.get（key） get方法读取key对应的key对应的值,如果找不到key，返回undefined

console.log(map.get('new'));
console.log(map.get('x'));

8.delete(key)删除某个键,返回true,如果删除失败,返回false
console.log(map.delete('a'));
console.log(map);
console.log(map.delete('a'));

9.has(key)方法返回一个布尔值,表示某个键是否在Map对象之中
console.log(map.has('miaov'));
console.log(map.has('a'));

10.clear()清除所有数据结构,没有返回值。
map.clear();
console.log(map);

11.keys()返回键名的遍历器
console.log(map.key());
12.values()返回键值得遍历器
console.log(map.values());
13.entries()返回键值对的遍历器
console.log(map.entries());
14.forEach() 使用回调函数遍历每个成员
map.forEach(function(key,value,map){
  console.log(key+":"+value);
});

15.Map在使用过程中的一些注意事项：
map.set(NaN,10).set(NaN,100);
console.log(map);//Map认为NaN是相等的

map.set({},'x').set({},'y');
console.log(map);
console.log({}==={});
map的键是和内存地址绑定的
map里面的key的排列顺序是按照添加顺序进行排列的。

五.iterator 和for-of循环
1.Iterator就是这样一种机制,它是一种接口,为各种不同的数据结构提供统一的访问机制。
任何数据接口只要部署Interator接口,就可以完成遍历操作。

function iterator(arr){
  let index=0;
  return {
    next:function(){
       return index<arr.length?
       {value:arr[index++],done:false};
       {value:undefined,done:true};
    }
  }
}
const it=iterator(arr);
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());

2.Iterator的遍历过程：
创建一个指针对象,指向当前数据结构的起始位置,也就是说，遍历器对象本质上是指针对象。
第一次调用指针对象的next方法,可以将指针指向数据结构的第一个成员
第二次调用指针对象的next方法,指针就指向数据结构的第二个成员
不断调用指针的next方法,直到它指向数据结构的结束位置

返回一个包含value和done的两个属性的对象,其中,value属性就是当前成员的值,done是一个属性值,表示遍历是否结束

3.凡是具有Symbol.iterator属性的数据结构都具有Iterator接口
const arr=[1,2,3];
const set=new Set(['a','b','c']);
const map=new Map([['a',1]]);

const itArr=arr[Symbol.iterator]();
const itSet=set[Symbol.iterator]();
const itMap=map[symbol.iterator]();

console.log(itArr);
console.log(itSet);
console.log(itMap);

console.log(itSet.next());
console.log(itSet.next());
console.log(itSet.next());
console.log(itSet.next());

const obj={};
console.log(obj[Symbol.iterator]);//undefined

4.凡是具备iterator接口的数据结构都可以进行如下操作
  -解耦赋值
  let [x,y]=set;
  console.log(x,y);//a,b

  -扩展运算符
  let str="miaov";//字符串是一个类数组
  let arrStr=[...str];
  console.log(arrStr);//['m','i','a','o','v'];

  -数组去重
  const arr2=[{},1,'a',1,'a','b',[]];
  console.log([...new Set(arr2)]);

5.for...of循环
const ofArr=[1,2,3,4];
for(let i of ofArr){
  console.log(i);
}

const m=new Map();

m.set('a',1).set('b',2).set('c',3);
for(let data of m){
   console.log(data);
}

for(let [key,value] of m){
  console.log(key,value);
}

六.class的基本使用
1.传统的js面向对象的写法
const Miaov=function(a,b){
  this.a=a;
  this.b=b;
  return this;
}
Miaov.prototype={
  constructor:Miaov,
  print:function(){
    console.log(this.a+''+this.b);
  }
}
const miaov=new Miaov('hello','world').print();//hello world

2.ES6中新增加了类的概念,可以使用class关键字声明一个类,之后以这个类来实例化对象
class Miaov{
   constructor(a,b){
      this.a=a;
      this.b=b;
      return this;
   }
   print(){
      console.log(this.a+''+this.b);
   }
}
const miaov=new Miaov('hello','world').print();//hello world

3.Miaov中的constructor方法是构造方法,this关键字则代表实例对象。
  定义类的方法的时候前面不需要加上function这个关键字,直接把函数定义放进去就可以了。
  方法之间不需要逗号分隔,加了会报错。
4.构造函数的prototype属性在ES6的类上继续存在,而且类的所有方法都定义在prototype属性上面。
console.log(Miaov.prototype);

5.定义在类中的方法都是不可枚举的。
console.log(Object.key(Miaov.prototype));

6.constructor方法是类的默认方法,通过new命令生成对象实例时,自动调用该方法.一个类必须有constructor方法,如果没有显示定义
一个空的constructor方法会被默认添加。
class P{};
const p=new P{};
console.log(p);
7.如果实例化类的时候忘记写new 将会报错

七.class的继承
1.子类继承父类,使用extends关键字
2.为父类指定静态方法,使用static方法名字
3.super:
  在构造函数中可以当一个函数类使用,相当于调用父类的构造函数
  在原型方法中,可以当做一个对象来使用,相当于父类的原型对象,并且自动绑定this到子类上

4.实际例子 extends,static,super
const canvas=document.querySelector('#canvas');
const ctx=canvas.getContext('2d');

const w=canvas.width=600;
const h=canvas.height=400;

class Ball{
  constructor(x,y,r){
     this.x=x;
     this.y=y;
     this.r=r;
     this.color=rab(${~~Ball.rpfn([55,255])},${~~Ball.rpfn([55,255])},${~~Ball.rpfn([55,255])});
     return this;
  }

  render(ctx){
     ctx.save();
     ctx.translate(this.x,this.y);
     ctx.fillStyle=this.color;
     ctx.beginPath();
     ctx.arc(0,0,this.r,0,2*Math.PI);
     ctx.fill();
     ctx.restore();
     return this;
  }

  static rpFn(arr){//静态方法
    let max=Math.max(...arr),
        min=Math.min(...arr);
    return Math.random()*(max-min)+min;
  }
}

class SuperBall extends Ball{//继承父类
     constructor(x,y,r){
        super(x,y,r);//调用父类的构造方法,只有调用了this才有效
        this.vy=SuperBall.rpFn([2,4]);
        this.g=SuperBall.rpFn([0.2,0.4]);
        this.a=0;
        return this;
     }
     move(ctx){
        this.y+=this.vy;
        this.vy+=this.g;
        let current=this.vy*-0.75;
        if(this.y+this.r>=ctx.canvas.height){
           this.y=ctx.canvas.height-this.r;
           if(Math.abs(current-this.a)<0.01) return false;
           this.a=this.vy*=-0.75;
        }
        ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
        super.render(ctx);
        return true;
     }
}

//小球点击后自由落体
let ball,timer;
canvas.onclick=function(e){
   let x=e.offsetX,y=e.offsetY;
   let r=~~Ball.rpFn([25,55]);
   ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
   ball=new SuperBall(x,y,r).render(ctx);

   ballMove();
}

function ballMove(){
   timer=window.requestAnimationFrame(ballMove);
   if(!ball.move(ctx)){
      window.cancelAnimationFrame(timer);
   }
}


//const ball1=new Ball(100,100,30).render(ctx);//实例化

八.Symbol 数据类型
1.Symbol,表示独一无二的值。它是JS中的第七种数据类型

基本数据类型;Null Undefined Number Boolean String Symbol
引用数据类型：Object

let s1=Symbol();
let s2=Symbol();
console.log(typeof s1);//'symbol'
console.log(s1===s2);//false

2.Symbol函数前不能使用new否则会报错,原因在于Symbol是一个原始类型的值，不是对象。
let s3=new Symbol;//错误

3.Symbol函数接受一个字符串作为参数,表示对Symbol的描述,主要是为了控制台显示，
或者转为字符串的时候,比较容易区分。
let s3=Symbol('miaov');
let s4=Symbol('leo');

console.log(s3,s4);//Symbol(miaov) Symbol(leo)

4.Symbol数据类型转换
console.log(String(Symbol('miaov')));//Symbol(miaov);
console.log(Symbol('leo').toString());//Symbol(leo);

console.log(!!Symbol());//true
console.log(Number(Symbol()));//报错,可以转换成功数字

//不能做任何的运算
console.log(Symbol('momo')+'pangzi');
console.log(Symbol('momo')*100);//不能做任何运算

5.作为对象的属性名
let yyy=Symbol('yyy');
const obj={};
obj[yyy]='hello';
console.log(obj);
console.log(obj[yyy]);

let ss=Symbol('ss');
const data={
  [ss]:'miaov'
};
console.log(data);
console.log(data[ss]);

const data={
  [Symbol()]:123,
  a:1,
  b:2
};
console.log(data);
console.log(data['Symbol()']);//找不到

不能被for...in循环遍历,虽然不能被遍历,但是有私有属性,可以通过Object.getOwnPropertySymbols
方法获取一个对象的所有Symbol属性

for(let i in data){
   console.log(i);
}
console.log(Object.getOwnPropertySymbols(data));//[Symbol()]
console.log(data[Object.getOwnPropertySymbols(data)][0]);

九.内置对象的扩展
1.字符串扩展-模板字符串
let flag=true;
let html=`<ul>
            <li>
               <span>${'首页'}</span>
               <span class="${flag?'show':'hide'}"></span>
            </li>
           </ul>`
console.log(html);
2.repeat()
    let str1='a';
    let str2=str1.repeat(3);
    console.log(str2);//aaa

  includes()
     let str="miaov";
     console.log(str.includes('ao'));//true
     console.log(str.includes('asd');//false

  startsWith()
      console.log(str.startsWith('m'));//true
      console.log(str.startsWith('o'));//false

  endsWith()
       console.log(str.endsWith('ov'));//true
       console.log(str.endsWith('m'));//true

2.数组的扩展
  Array.from();//把类数组对象转换为数组对象
  var lis=document.querySelectorAll('li');
  var lis2=Array.from(lis);

  console.log(lis2);
  console.log(Array.isArray(lis2));

  Array.of();//创建数组
  const arr=Array.of(1);
  console.log(arr);//[1];

  find();//返回符合条件的数组元素,不符合条件返回undefined
  const arr=[1,2,3,4];
  let res=arr.find(function(a){
      return a<2;
  })
  console.log(res);//1

   findIndex();//返回符合条件的数组元素的下标,不符合条件返回-1
   const arr=[1,2,3,4];
     let res=arr.findIndex(function(a){
         return a<2;
    })
    console.log(res);//0

   fill()填充数组
   const arr=[1,2,3,4];
   arr.fill('abc',1,3);
   console.log(arr);//[1,"abc","abc",4]

3.对象的扩展
  对象的简洁表示法
  let a=1;
  const obj={a:a};=>const obj{a};//如果键这值一样的情况下

  const obj={
     fn:function(){
        console.log(1);
     }
     fn2(){
       console.log(2);
     }
  }
  obj.fn();//1
  obj.fn2();//2

  Object.is();//判断是否相等,长得是否一样
  console.log(Object.is(NaN,NaN));//true
  console.log(Object.is(+0,-0));//false

   Object.assign();对象的复制
   //用于对象的合并,将源对象的所有可枚举属性,复制到目标对象。
   let obj1={a:1};
   let obj2={a:2,b:3};
   let obj3={c:'abc'};

   Object.assign(obj1,obj2,obj3);//第一个参数是目标对象
   console.log(obj1);//{a:2,b:3,c:'abc'};

十.函数的扩展
1.为函数参数指定默认值
  function fn(a=10,b=20){
    console.log(a+b);
  }
  fn();//30;
  fn(0,10);//20
2.函数的rest参数
  rest参数形式为('...变量名'),用于获取函数的多余参数,这样就不需要使用arguments对象了。
  rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中。
  //使用传统的arguments参数
  function sum(){
     var args=arguments;
     var res=0;
     for(var i=0;i<args.length;i++){
        res+=args[i];
     }
     console.log(res);
  }
  sum(1,2,3,4,5);//15

  //使用rest参数搭配
  function sum(a,...arr){ //后面不能再传参数了。
     var res=0;
     for(var i=0;i<arr.length;i++){
        res+=arr[i];
     }
     console.log(res);
  }
  sum(10,1,2,3,4,5);//15
3.箭头函数
  使用箭头函数(=>)定义函数
  const fn=a=>a;
  const fn2=function(a){ //等同于
    return a;
  }
  console.log(fn(1));//1
  console.log(fn2(2));//2

  const fn=(a,b)=>a+b;
  console.log(fn(1,2));

  const fn=(a,b)=>{ //等同函数,记得要return出来
     a=a*2;
     b=b*2;
     return a+b;
  }
  console.log(fn(1,2));

  //如果想返回的是一个对象
  const fn=(a,b)=>({a,b});//此时返回的是一个对象
  console.log(fn(1,2));

  //一个排序的例子
  var arr=[5,2,3,4,1];
  arr.sort(function(a,b)){ //es5的例子
     return a-b;
  }
  console.log(arr);

  arr.sort((a,b)=>a-b);
  console.log(arr);

  箭头函数体内没有自己的this对象,其内部的this是定义时候环境的对象，而不是使用时所在的环境对象
  function fn(){
     setTimeout(function(){
        console.log(this);//window
     },1000);
     setTimeout(function(){
        console.log(this);//{a:1}
     },1000)
  }
  var obj={a:1};
  fn.call(obj);

  //箭头函数体内没有arguments对象,如果要用可以使用rest参数代替
  function fn(){
     setTimeout({
        console.log(arguments);
     },1000);
  }
  fn(1,2,3);

  const fn(...arr)=>arr;
  console.log(fn(1,2,3,4));//[1,2,3,4]

  不可以当做构造函数,不可以使用new命令,否则会抛出一个错误。
  const fn=(a,b)=>a+b;
  const f=new Fn(1,2); //报错了

  箭头函数不能做Generator函数

十一.异步操作之promise
1.基本概念
  Promise:是ES6中新增的异步编程解决方案,提现在代码中它是一个对象，可以通过Promise构造函数来实例化。
  new Promise(cd)===>实例的基本使用 Pending  Resolved Rejected

  两个原型方法
    Promise.prototype.then();
    Promise.prototype.catch();

  两个常用的静态方法：
    Promise.all();
    Promise.resolve();

  New Promise(cd)
  Pending(进行中)===>Resolved(已完成);
  Pending(进行中)===>Rejected(已失败);

  const p=new Promise(function(resolve,reject){
     const img=new Image();
     img.src=imgs[0];
     img.onload=function(){
        resolve(this);
     };
     img.onerror=function(){
       reject(new Error('图片加载失败'));
     };
  })
  console.log(123);
  p.then(function(img){
     console.log('加载完成');
     document.body.appendChild(img);
  }.catch(function(err){
     console.log(err);
   })
  console.log(456);

2.Promise.all可以将多个Promise实例包装成一个新的Promise实例
//进行封装
function loadImg(url){
   const p=new Promise(function(resolve,reject){
      const img =new Image();
      img.src=url;
      img.onload=function(){
         resolve(this);
      };
      img.onerror=function(){
         reject(new Error('图片加载失败'));
      };
   });
   return p;
}

loadImg(imgs[0]).then(function(img){
   document.body.appendChild(img);
});

当所有的Promise实例的状态都变成resolved,Promise.all的状态才会变成resolved,此时
返回值组成一个数组,传递给then中的resolve函数

只要其中一个被rejected，Promise.all的状态就变成rejected，此时第一个被reject的实例的
返回值,会传递给p的回调函数。
const allDone=Promise.all([LoadImg(imgs[0])],[LoadImg(imgs[1)],[LoadImg('')]);
allDone.then(function(datas){
   datas.forEach(function(item,i){
      document.body.appendChild(item);
   });
}).catch(function(err){
    console.log(err);
});

参数是Promise实例,将不做任何修改，原封不动地返回这个实例
Promise.resolve(loadImg(imgs[0])).then(function(img){
    document.body.appendChild(img);
})

将对象转换为Promise对象,然后就立即执行thenable对象的then方法。
Promise.resolve({
  then(resolve,reject){
     const img=new Image();
     img.src=imgs[1];
     img.onload=function(){
        resolve(this);
     }
  }
}).then(function(img){
   document.body.appendChild(img);
});

Promise.resolve('miaov').then(function(str)){
   console.log(str);
}
const p=Promise.resolve();
console.log(p);//为空会返回一个Promise对象
