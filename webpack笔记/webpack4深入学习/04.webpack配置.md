# webpack 配置

## 配置文件选项

```js
const path = require('path');

module.exports = {
  mode: "production", // "production" | "development" | "none"
  mode: "production", // enable many optimizations for production builds
  mode: "development", // enabled useful tools for development
  mode: "none", // no defaults
  // Chosen mode tells webpack to use its built-in optimizations accordingly.

  entry: "./app/entry", // string | object | array
  entry: ["./app/entry1", "./app/entry2"],
  entry: {
    a: "./app/entry-a",
    b: ["./app/entry-b1", "./app/entry-b2"]
  },
  // 这里应用程序开始执行
  // webpack 开始打包

  output: {
    // webpack 如何输出结果的相关选项

    path: path.resolve(__dirname, "dist"), // string
    // 所有输出文件的目标路径
    // 必须是绝对路径（使用 Node.js 的 path 模块）

    filename: "bundle.js", // string
    filename: "[name].js", // 用于多个入口点(entry point)（出口点？）
    filename: "[chunkhash].js", // 用于长效缓存
    // 「入口分块(entry chunk)」的文件名模板（出口分块？）

    publicPath: "/assets/", // string
    publicPath: "",
    publicPath: "https://cdn.example.com/",
    // 输出解析文件的目录，url 相对于 HTML 页面

    library: "MyLibrary", // string,
    // 导出库(exported library)的名称

    libraryTarget: "umd", // 通用模块定义
        libraryTarget: "umd2", // 通用模块定义
        libraryTarget: "commonjs2", // exported with module.exports
        libraryTarget: "commonjs-module", // 使用 module.exports 导出
        libraryTarget: "commonjs", // 作为 exports 的属性导出
        libraryTarget: "amd", // 使用 AMD 定义方法来定义
        libraryTarget: "this", // 在 this 上设置属性
        libraryTarget: "var", // 变量定义于根作用域下
        libraryTarget: "assign", // 盲分配(blind assignment)
        libraryTarget: "window", // 在 window 对象上设置属性
        libraryTarget: "global", // property set to global object
        libraryTarget: "jsonp", // jsonp wrapper
    // 导出库(exported library)的类型

    /* 高级输出配置（点击显示） */

    pathinfo: true, // boolean
    // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。

    chunkFilename: "[id].js",
    chunkFilename: "[chunkhash].js", // 长效缓存(/guides/caching)
    // 「附加分块(additional chunk)」的文件名模板

    jsonpFunction: "myWebpackJsonp", // string
    // 用于加载分块的 JSONP 函数名

    sourceMapFilename: "[file].map", // string
    sourceMapFilename: "sourcemaps/[file].map", // string
    // 「source map 位置」的文件名模板

    devtoolModuleFilenameTemplate: "webpack:///[resource-path]", // string
    // 「devtool 中模块」的文件名模板

    devtoolFallbackModuleFilenameTemplate: "webpack:///[resource-path]?[hash]", // string
    // 「devtool 中模块」的文件名模板（用于冲突）

    umdNamedDefine: true, // boolean
    // 在 UMD 库中使用命名的 AMD 模块

    crossOriginLoading: "use-credentials", // 枚举
    crossOriginLoading: "anonymous",
    crossOriginLoading: false,
    // 指定运行时如何发出跨域请求问题

    /* 专家级输出配置（自行承担风险） */

    devtoolLineToLine: {
      test: /\.jsx$/
    },
    // 为这些模块使用 1:1 映射 SourceMaps（快速）

    hotUpdateMainFilename: "[hash].hot-update.json", // string
    // 「HMR 清单」的文件名模板

    hotUpdateChunkFilename: "[id].[hash].hot-update.js", // string
    // 「HMR 分块」的文件名模板

    sourcePrefix: "\t", // string
    // 包内前置式模块资源具有更好可读性
  },

  module: {
    // 关于模块配置

    rules: [
      // 模块规则（配置 loader、解析器等选项）

      {
        test: /\.jsx?$/,
        include: [
          path.resolve(__dirname, "app")
        ],
        exclude: [
          path.resolve(__dirname, "app/demo-files")
        ],
        // 这里是匹配条件，每个选项都接收一个正则表达式或字符串
        // test 和 include 具有相同的作用，都是必须匹配选项
        // exclude 是必不匹配选项（优先于 test 和 include）
        // 最佳实践：
        // - 只在 test 和 文件名匹配 中使用正则表达式
        // - 在 include 和 exclude 中使用绝对路径数组
        // - 尽量避免 exclude，更倾向于使用 include

        issuer: { test, include, exclude },
        // issuer 条件（导入源）

        enforce: "pre",
        enforce: "post",
        // 标识应用这些规则，即使规则覆盖（高级选项）

        loader: "babel-loader",
        // 应该应用的 loader，它相对上下文解析
        // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的
        // 查看 webpack 1 升级指南。

        options: {
          presets: ["es2015"]
        },
        // loader 的可选项
      },

      {
        test: /\.html$/,
        test: "\.html$"

        use: [
          // 应用多个 loader 和选项
          "htmllint-loader",
          {
            loader: "html-loader",
            options: {
              /* ... */
            }
          }
        ]
      },

      { oneOf: [ /* rules */ ] },
      // 只使用这些嵌套规则之一

      { rules: [ /* rules */ ] },
      // 使用所有这些嵌套规则（合并可用条件）

      { resource: { and: [ /* 条件 */ ] } },
      // 仅当所有条件都匹配时才匹配

      { resource: { or: [ /* 条件 */ ] } },
      { resource: [ /* 条件 */ ] },
      // 任意条件匹配时匹配（默认为数组）

      { resource: { not: /* 条件 */ } }
      // 条件不匹配时匹配
    ],

    /* 高级模块配置（点击展示） */

    noParse: [
      /special-library\.js$/
    ],
    // 不解析这里的模块

    unknownContextRequest: ".",
    unknownContextRecursive: true,
    unknownContextRegExp: /^\.\/.*$/,
    unknownContextCritical: true,
    exprContextRequest: ".",
    exprContextRegExp: /^\.\/.*$/,
    exprContextRecursive: true,
    exprContextCritical: true,
    wrappedContextRegExp: /.*/,
    wrappedContextRecursive: true,
    wrappedContextCritical: false,
    // specifies default behavior for dynamic requests
  },

  resolve: {
    // 解析模块请求的选项
    // （不适用于对 loader 解析）

    modules: [
      "node_modules",
      path.resolve(__dirname, "app")
    ],
    // 用于查找模块的目录

    extensions: [".js", ".json", ".jsx", ".css"],
    // 使用的扩展名

    alias: {
      // 模块别名列表

      "module": "new-module",
      // 起别名："module" -> "new-module" 和 "module/path/file" -> "new-module/path/file"

      "only-module$": "new-module",
      // 起别名 "only-module" -> "new-module"，但不匹配 "only-module/path/file" -> "new-module/path/file"

      "module": path.resolve(__dirname, "app/third/module.js"),
      // 起别名 "module" -> "./app/third/module.js" 和 "module/file" 会导致错误
      // 模块别名相对于当前上下文导入
    },
    /* 可供选择的别名语法（点击展示） */
    alias: [
      {
        name: "module",
        // 旧的请求

        alias: "new-module",
        // 新的请求

        onlyModule: true
        // 如果为 true，只有 "module" 是别名
        // 如果为 false，"module/inner/path" 也是别名
      }
    ],

    /* 高级解析选项（点击展示） */

    symlinks: true,
    // 遵循符号链接(symlinks)到新位置

    descriptionFiles: ["package.json"],
    // 从 package 描述中读取的文件

    mainFields: ["main"],
    // 从描述文件中读取的属性
    // 当请求文件夹时

    aliasFields: ["browser"],
    // 从描述文件中读取的属性
    // 以对此 package 的请求起别名

    enforceExtension: false,
    // 如果为 true，请求必不包括扩展名
    // 如果为 false，请求可以包括扩展名

    moduleExtensions: ["-module"],
    enforceModuleExtension: false,
    // 类似 extensions/enforceExtension，但是用模块名替换文件

    unsafeCache: true,
    unsafeCache: {},
    // 为解析的请求启用缓存
    // 这是不安全，因为文件夹结构可能会改动
    // 但是性能改善是很大的

    cachePredicate: (path, request) => true,
    // predicate function which selects requests for caching

    plugins: [
      // ...
    ]
    // 应用于解析器的附加插件
  },

  performance: {
    hints: "warning", // 枚举
    hints: "error", // 性能提示中抛出错误
    hints: false, // 关闭性能提示
    maxAssetSize: 200000, // 整数类型（以字节为单位）
    maxEntrypointSize: 400000, // 整数类型（以字节为单位）
    assetFilter: function(assetFilename) {
      // 提供资源文件名的断言函数
      return assetFilename.endsWith('.css') || assetFilename.endsWith('.js');
    }
  },

  devtool: "source-map", // enum
  devtool: "inline-source-map", // 嵌入到源文件中
  devtool: "eval-source-map", // 将 SourceMap 嵌入到每个模块中
  devtool: "hidden-source-map", // SourceMap 不在源文件中引用
  devtool: "cheap-source-map", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant)
  devtool: "cheap-module-source-map", // 有模块映射(module mappings)的 SourceMap 低级变体
  devtool: "eval", // 没有模块映射，而是命名模块。以牺牲细节达到最快。
  // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试
  // 牺牲了构建速度的 `source-map' 是最详细的。

  context: __dirname, // string（绝对路径！）
  // webpack 的主目录
  // entry 和 module.rules.loader 选项
  // 相对于此目录解析

  target: "web", // 枚举  // 包(bundle)应该运行的环境
  // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module)

  externals: ["react", /^@angular\//],  // 不要遵循/打包这些模块，而是在运行时从环境中请求他们

  stats: "errors-only",
  stats: { //object
    assets: true,
    colors: true,
    errors: true,
    errorDetails: true,
    hash: true,
    // ...
  },
  // 精确控制要显示的 bundle 信息

  devServer: {
    proxy: { // proxy URLs to backend development server
      '/api': 'http://localhost:3000'
    },
    contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location
    compress: true, // enable gzip compression
    historyApiFallback: true, // true for index.html upon 404, object for multiple paths
    hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin
    https: false, // true for self-signed, object for cert authority
    noInfo: true, // only errors & warns on hot reload
    // ...
  },

  plugins: [
    // ...
  ],
  // 附加插件列表


  /* 高级配置（点击展示） */

  resolveLoader: { /* 等同于 resolve */ }
  // 独立解析选项的 loader

  parallelism: 1, // number
  // 限制并行处理模块的数量

  profile: true, // boolean
  // 捕获时机信息

  bail: true, //boolean
  // 在第一个错误出错时抛出，而不是无视错误。

  cache: false, // boolean
  // 禁用/启用缓存

  watch: true, // boolean
  // 启用观察

  watchOptions: {
    aggregateTimeout: 1000, // in ms
    // 将多个更改聚合到单个重构建(rebuild)

    poll: true,
    poll: 500, // 间隔单位 ms
    // 启用轮询观察模式
    // 必须用在不通知更改的文件系统中
    // 即 nfs shares（译者注：Network FileSystem，最大的功能就是可以透過網路，讓不同的機器、不同的作業系統、可以彼此分享個別的檔案 ( share file )）
  },

  node: {
    // Polyfills and mocks to run Node.js-
    // environment code in non-Node environments.

    console: false, // boolean | "mock"
    global: true, // boolean | "mock"
    process: true, // boolean
    __filename: "mock", // boolean | "mock"
    __dirname: "mock", // boolean | "mock"
    Buffer: true, // boolean | "mock"
    setImmediate: true // boolean | "mock" | "empty"
  },

  recordsPath: path.resolve(__dirname, "build/records.json"),
  recordsInputPath: path.resolve(__dirname, "build/records.json"),
  recordsOutputPath: path.resolve(__dirname, "build/records.json"),
  // TODO

}
```

## 使用不同语言进行配置(configuration languages)

- TypeScript

```js
/**
 * 先安装相关依赖
 * npm install --save-dev typescript ts-node @types/node @types/webpack

 * 在 tsconfig.json 文件中，具有 esModuleInterop 和 allowSyntheticDefaultImports 
 * tsconfig.json 中的 compilerOptions 中的 module 字段是 commonjs ，则配置是正确的，否则 webpack 将因为错误而构建失败
 */

// webpack.config.ts
import path from 'path';
import webpack from 'webpack';

const config: webpack.Configuration = {
  mode: 'production',
  entry: './foo.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'foo.bundle.js'
  }
};

export default config;
```

## 多种配置类型(configuration types)

- 导出为一个函数

```js
/**
 * 环境对象(environment)作为第一个参数
 * 一个选项 map 对象（argv）作为第二个参数。这个对象描述了传递给 webpack 的选项，
 * 并且具有 output-filename 和 optimize-minimize 等 key。
 */
module.exports = function(env, argv) {
  return {
    mode: env.production ? 'production' : 'development',
    devtool: env.production ? 'source-maps' : 'eval',
    plugins: [
      new webpack.optimize.UglifyJsPlugin({
        compress: argv['optimize-minimize'] // 只有传入 -p 或 --optimize-minimize
      })
    ]
  };
};
```

- 导出一个 Promise

```js
/**
 * webpack 将运行由配置文件导出的函数，并且等待 Promise 返回。便于需要异步地加载所需的配置变量
 */
module.exports = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({
        entry: './app.js'
        /* ... */
      });
    }, 5000);
  });
};
```

- 导出多个配置对象

```js
/**
 * 对于针对多个构建目标（例如 AMD 和 CommonJS）打包一个 library 非常有用。
 */
module.exports = [
  {
    output: {
      filename: './dist-amd.js',
      libraryTarget: 'amd'
    },
    entry: './app.js',
    mode: 'production'
  },
  {
    output: {
      filename: './dist-commonjs.js',
      libraryTarget: 'commonjs'
    },
    entry: './app.js',
    mode: 'production'
  }
];
```

## 入口和上下文(entry and context)

```js
/**
 * context
 * 基础目录，绝对路径，用于从配置中解析入口起点(entry point)和 loader
 * 默认使用当前目录
 * context: path.resolve(__dirname, "app")

 * entry
 * 起点或是应用程序的起点入口。从这个起点开始，应用程序启动执行
 * 如果传递一个数组，那么数组的每一项都会执行。

 * 如果传入一个字符串或字符串数组，chunk 会被命名为 main
 * 如果传入一个对象，则每个键(key)会是 chunk 的名称，该值描述了 chunk 的入口起点。

 * 动态入口
 * entry: () => './demo'
 * entry: () => new Promise((resolve) => resolve(['./demo', './demo2']))
 * 当结合 output.library 选项时：如果传入数组，则只导出最后一项。
 */
entry: {
  home: "./home.js",
  about: "./about.js",
  contact: "./contact.js"
}
```

## 输出(output)

- output.auxiliaryComment

```js
/**
 * 在和 output.library 和 output.libraryTarget 一起使用时，此选项允许用户向导出容器(export wrapper)中插入注释。
 * 要为 libraryTarget 每种类型都插入相同的注释，将 auxiliaryComment 设置为一个字符串
 */
output: {
  library: "someLibName",
  libraryTarget: "umd",
  filename: "someLibName.js",
  auxiliaryComment: "Test Comment"
}

// 将生成如下内容
(function webpackUniversalModuleDefinition(root, factory) {
  // Test Comment
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = factory(require("lodash"));
  // Test Comment
  else if(typeof define === 'function' && define.amd)
    define(["lodash"], factory);
  // Test Comment
  else if(typeof exports === 'object')
    exports["someLibName"] = factory(require("lodash"));
  // Test Comment
  else
    root["someLibName"] = factory(root["_"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
  // ...
});

// 对于 libraryTarget 每种类型的注释进行更细粒度地控制，请传入一个对象
auxiliaryComment: {
  root: "Root Comment",
  commonjs: "CommonJS Comment",
  commonjs2: "CommonJS2 Comment",
  amd: "AMD Comment"
}
```

- output.chunkFilename

```js
/**
 * 此选项决定了非入口(non-entry) chunk 文件的名称
 * 需要在 webpack runtime 输出 bundle 值时，将 chunk id 的值对应映射到占位符(如 [name] 和 [chunkhash])
 * 这会增加文件大小，并且在任何 chunk 的占位符值修改后，都会使 bundle 失效。
 * 默认使用 [id].js 或从 output.filename 中推断出的值（[name] 会被预先替换为 [id] 或 [id].）
 */
```

- output.chunkLoadTimeout

```js
/**
 * chunk 请求到期之前的毫秒数，默认为 120 000。
 */
```

- output.crossOriginLoading

```js
/**
 * 只用于 target 是 web，使用了通过 script 标签的 JSONP 来按需加载 chunk。
 * crossOriginLoading: false - 禁用跨域加载（默认）
 * crossOriginLoading: "anonymous" - 不带凭据(credential)启用跨域加载
 * crossOriginLoading: "use-credentials" - 带凭据(credential)启用跨域加载 with credentials
 */
```

- output.jsonpScriptType

```js
/**
 * 允许自定义 script 的类型，webpack 会将 script 标签注入到 DOM 中以下载异步 chunk
 * "text/javascript"（默认）
 * "module"：与 ES6 就绪代码一起使用。
 */
```

- output.devtoolFallbackModuleFilenameTemplate

```js
/**
 * 当上面的模板字符串或函数产生重复时使用的备用内容
 */
```

- output.devtoolModuleFilenameTemplate

```js
/**
 * 此选项仅在 「devtool 使用了需要模块名称的选项」时使用。
 * 自定义每个 source map 的 sources 数组中使用的名称
 * 当使用 devtool: 'eval'，默认值是
 * devtoolModuleFilenameTemplate: "webpack://[namespace]/[resource-path]?[loaders]"
  [absolute-resource-path]
  绝对路径文件名
  [all-loaders]
  自动和显式的 loader，并且参数取决于第一个 loader 名称
  [hash]
  模块标识符的 hash
  [id]
  模块标识符
  [loaders]
  显式的 loader，并且参数取决于第一个 loader 名称
  [resource]
  用于解析文件的路径和用于第一个 loader 的任意查询参数
  [resource-path]
  不带任何查询参数，用于解析文件的路径
  [namespace]
  模块命名空间。在构建成为一个 library 之后，通常也是 library 名称，否则为空

  * 当使用一个函数，同样的选项要通过 info 参数并使用驼峰式(camel-cased)
 */

devtoolModuleFilenameTemplate: info => {
  return `webpack:///${info.resourcePath}?${info.loaders}`;
};
```

- output.devtoolNamespace

```js
/**
 * 此选项确定 output.devtoolModuleFilenameTemplate 使用的模块名称空间。未指定时的默认值为：output.library。
 * 在加载多个通过 webpack 构建的 library 时，用于防止 sourcemap 中源文件路径冲突
 * 将这些文件暴露为 webpack://library1/./src/index.js 和 webpack://library2/./src/index.js。
 */
```

- output.filename

```js
/**
 * 此选项决定了每个输出 bundle 的名称。这些 bundle 将写入到 output.path 选项指定的目录下。
 * 此选项被称为文件名，但是你还是可以使用像 "js/[name]/bundle.js" 这样的文件夹结构
 * 此选项不会影响那些「按需加载 chunk」的输出文件。对于这些文件，请使用 output.chunkFilename 选项来控制输出。
 * 通过 loader 创建的文件也不受影响。

 * 使用入口名称：filename: "[name].bundle.js"
 * 使用内部 chunk id:filename: "[id].bundle.js"
 * 使用每次构建过程中，唯一的 hash 生成: filename: "[name].[hash].bundle.js"
 * 使用基于每个 chunk 内容的 hash：filename: "[chunkhash].bundle.js"

 * 可以使用以下替换模板字符串（通过 webpack 内部的[TemplatedPathPlugin]TemplatedPathPlugin）
 * [hash] 和 [chunkhash] 的长度可以使用 [hash:16]（默认为20）来指定。
 * 或者，通过指定output.hashDigestLength 在全局配置长度。
  [hash]
  模块标识符(module identifier)的 hash
  [chunkhash]
  chunk 内容的 hash
  [name]
  模块名称
  [id]
  模块标识符(module identifier)
  [query]
  模块的 query，例如，文件名 ? 后面的字符串
 */
```

- output.hashDigest

```js
/**
 * 在生成 hash 时使用的编码方式，默认为 'hex'。支持 Node.js hash.digest 的所有编码。
 */
```

- output.hashDigestLength

```js
/**
 * 散列摘要的前缀长度，默认为 20
 */
```

- output.hashFunction

```js
/**
 * 散列算法，默认为 'md5'。
 * 支持 Node.JS crypto.createHash 的所有功能
 */
```

- output.hashSalt

```js
/**
 * 一个可选的加盐值，通过 Node.JS hash.update 来更新哈希。
 */
```

- output.hotUpdateChunkFilename

```js
/**
 * 自定义热更新 chunk 的文件名。
 * 占位符只能是 [id] 和 [hash]，默认值是：
 * hotUpdateChunkFilename: "[id].[hash].hot-update.js"
 */
```

- output.hotUpdateFunction

```js
/**
 * 只在 target 是 web 时使用，用于加载热更新(hot update)的 JSONP 函数。
 */
```

- output.hotUpdateMainFilename

```js
/**
 * 自定义热更新的主文件名(main filename)。
 * 占位符只能是 [hash]，默认值是：
 * hotUpdateMainFilename: "[hash].hot-update.json"
 */
```

- output.jsonpFunction

```js
/**
 * 只在 target 是 web 时使用，用于按需加载(load on-demand) chunk 的 JSONP 函数。
 */
```

- output.library

```js
/**
 * output.library 的值的作用，取决于output.libraryTarget 选项的值；
 * 注意，output.libraryTarget 的默认选项是 var
 * 如果生成的输出文件，是在 HTML 页面中作为一个 script 标签引入，则变量 MyLibrary 将与入口文件的返回值绑定。
 */

output: {
  library: 'MyLibrary';
}
```

- output.libraryExport

```js
/**
 *
 */
```

- output.libraryTarget

```js
/**
 * 配置如何暴露 library。
 * 假定将 output.library 的值配置为 MyLibrary

 * 如果 MyLibrary 在作用域中未在前面代码进行定义，则你的 library 将被设置在全局作用域内。
 * 当使用此选项时，将 output.library 设置为空，将产生一个破损的输出 bundle。
 */

// libraryTarget: "var" - （默认值）当 library 加载完成，入口起点的返回值将分配给一个变量：
var MyLibrary = _entry_return_;
// 在一个单独的 script……
MyLibrary.doSomething();

/**
 * libraryTarget: "assign" - 这将产生一个隐含的全局变量，可能会潜在地重新分配到全局中已存在的值（谨慎使用）。.
 */

MyLibrary = _entry_return_;

/**
 * 通过在对象上赋值暴露
 * 如果 output.library 未赋值为一个非空字符串，则默认行为是，
 * 将入口起点返回的所有属性都赋值给一个对象（此对象由 output.libraryTarget 特定）

 * 不设置 output.library 将导致由入口起点返回的所有属性，都会被赋值给给定的对象；这里并不会检查现有的属性名是否存在。
 */
(function(e, a) { for(var i in a) e[i] = a[i]; }(${output.libraryTarget}, _entry_return_)

/**
 * ibraryTarget: "this" - 入口起点的返回值将分配给 this 的一个属性（此名称由 output.library 定义）下，this 的含义取决于你：
 */
this["MyLibrary"] = _entry_return_;

// 在一个单独的 script……
this.MyLibrary.doSomething();
MyLibrary.doSomething(); // 如果 this 是 window

/**
  * libraryTarget: "window" - 入口起点的返回值将使用 output.library 中定义的值，分配给 window 对象的这个属性下。
  */
window["MyLibrary"] = _entry_return_;
window.MyLibrary.doSomething();

/**
  * libraryTarget: "global" - 入口起点的返回值将使用 output.library 中定义的值，分配给 global 对象的这个属性下。
  */
global["MyLibrary"] = _entry_return_;
global.MyLibrary.doSomething();

/**
* libraryTarget: "commonjs" - 入口起点的返回值将使用 output.library 中定义的值，分配给 exports 对象。这个名称也意味着，模块用于 CommonJS 环境：
  */
exports["MyLibrary"] = _entry_return_;
require("MyLibrary").doSomething();
```

- 模块定义系统

```js
/**
 * libraryTarget: "commonjs2" - 入口起点的返回值将分配给 module.exports 对象。这个名称也意味着模块用于 CommonJS 环境：
 * 注意，output.library 会被省略，因此对于此特定的 output.libraryTarget，无需再设置 output.library
 */
module.exports = _entry_return_;
require('MyLibrary').doSomething();

/**
 * libraryTarget: "amd" - 将你的 library 暴露为 AMD 模块。
 * 生成的 output 将会使用 "MyLibrary" 作为模块名定义
 */
output: {
  library: "MyLibrary",
  libraryTarget: "amd"
}

define("MyLibrary", [], function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});

// 可以在 script 标签中，将 bundle 作为一个模块整体引入，并且可以像这样调用 bundle：
require(['MyLibrary'], function(MyLibrary) {
  // 使用 library 做一些事……
});

/**
  * 如果 output.library 未定义，将会生成以下内容。
  */
define([], function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});


/**
  * libraryTarget: "umd" - 将你的 library 暴露为所有的模块定义下都可运行的方式。
  */
output: {
  library: "MyLibrary",
  libraryTarget: "umd"
}

// 最终输出如下：

(function webpackUniversalModuleDefinition(root, factory) {
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if(typeof define === 'function' && define.amd)
    define([], factory);
  else if(typeof exports === 'object')
    exports["MyLibrary"] = factory();
  else
    root["MyLibrary"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});

/**
  * 省略 library 会导致将入口起点返回的所有属性，直接赋值给 root 对象
  */
// 输出结果如下：
(function webpackUniversalModuleDefinition(root, factory) {
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if(typeof define === 'function' && define.amd)
    define([], factory);
  else {
    var a = factory();
    for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
  }
})(typeof self !== 'undefined' ? self : this, function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});

/**
  * 将 library 指定为一个对象，用于给每个 target 起不同的名称
  */
output: {
  library: {
    root: "MyLibrary",
    amd: "my-library",
    commonjs: "my-common-library"
  },
  libraryTarget: "umd"
}

/**
  * libraryTarget: "jsonp" - 这将把入口起点的返回值，包裹到一个 jsonp 包装容器中
  */
MyLibrary(_entry_return_);
```

- output.path

```js
/**
 * output 目录对应一个绝对路径。
 */
path: path.resolve(__dirname, 'dist/assets');
```

- output.pathinfo

```js
/**
 * 告诉 webpack 在 bundle 中引入「所包含模块信息」的相关注释。
 * 此选项默认值是 false，并且不应该用于生产环境(production)，但是对阅读开发环境(development)中的生成代码(generated code)极其有用
 * 注意，这些注释也会被添加至经过 tree shaking 后生成的 bundle 中。
 */
pathinfo: true;
```

- output.publicPath

```js
/**
 * 对于按需加载(on-demand-load)或加载外部资源(external resources)（如图片、文件等）来说，
 * output.publicPath 是很重要的选项。如果指定了一个错误的值，则在加载这些资源时会收到 404 错误。

 * 此选项指定在浏览器中所引用的「此输出目录对应的公开 URL」。
 * 相对 URL(relative URL) 会被相对于 HTML 页面（或 <base> 标签）解析。
 * 该选项的值是以 runtime(运行时) 或 loader(载入时) 所创建的每个 URL 为前缀。因此，在多数情况下，此选项的值都会以/结束。

 * 默认值是一个空字符串 ""。
 */

// output.path 中的 URL 以 HTML 页面为基准
path: path.resolve(__dirname, "public/assets"),
publicPath: "https://cdn.example.com/assets/"

// 对于一个 chunk 请求，看起来像这样 /assets/4.chunk.js。
publicPath: "/assets/",
chunkFilename: "[id].chunk.js"

// 对于一个输出 HTML 的 loader 可能会像这样输出：
<link href="/assets/spinner.gif" />

// webpack-dev-server 也会默认从 publicPath 为基准，使用它来决定在哪个目录下启用服务，来访问 webpack 输出的文件。


publicPath: "https://cdn.example.com/assets/", // CDN（总是 HTTPS 协议）
publicPath: "//cdn.example.com/assets/", // CDN (协议相同)
publicPath: "/assets/", // 相对于服务(server-relative)
publicPath: "assets/", // 相对于 HTML 页面
publicPath: "../assets/", // 相对于 HTML 页面
publicPath: "", // 相对于 HTML 页面（目录相同）

/**
  * 在编译时(compile time)无法知道输出文件的 publicPath 的情况下，可以留空，
  * 然后在入口文件(entry file)处使用自由变量(free variable) __webpack_public_path__，以便在运行时(runtime)进行动态设置。
  */

// 应用程序入口的其他部分
__webpack_public_path__ = myRuntimePublicPath

```

- output.sourceMapFilename

```js
/**
 * 此选项会向硬盘写入一个输出文件，只在 devtool 启用了 SourceMap 选项时才使用。
 */
```

- output.sourcePrefix

```js
/**
 * 修改输出 bundle 中每行的前缀。
 */
```

- output.strictModuleExceptionHandling

```js
/**
 * 如果一个模块是在 require 时抛出异常，告诉 webpack 从模块实例缓存(require.cache)中删除这个模块。
 * 出于性能原因，默认为 false。
 * strictModuleExceptionHandling 设置为 true，这个模块所有的 require 都抛出异常
 */
```

- output.umdNamedDefine

```js
/**
 * 当使用了 libraryTarget: "umd"，设置：
 * 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define。
 */
umdNamedDefine: true;
```

## 模块(module)

- module.noParse

```js
/**
 * 防止 webpack 解析那些任何与给定正则表达式相匹配的文件
 */
// 从 webpack 3.0.0 开始
noParse: function(content) {
  return /jquery|lodash/.test(content);
}
```

- module.rules

```js
/**
 * 对模块(module)应用 loader，或者修改解析器(parser)。

 * Rule.exclude
 * Rule.exclude 是 Rule.resource.exclude 的简写。如果你提供了 Rule.exclude 选项，就不能再提供 Rule.resource。

 * Rule.parser
 parser: {
  amd: false, // 禁用 AMD
  commonjs: false, // 禁用 CommonJS
  system: false, // 禁用 SystemJS
  harmony: false, // 禁用 ES2015 Harmony import/export
  requireInclude: false, // 禁用 require.include
  requireEnsure: false, // 禁用 require.ensure
  requireContext: false, // 禁用 require.context
  browserify: false, // 禁用特殊处理的 browserify bundle
  requireJs: false, // 禁用 requirejs.*
  node: false, // 禁用 __dirname, __filename, module, require.extensions, require.main 等。
  node: {...} // 在模块级别(module level)上重新配置 node 层(layer)
}
 */
use: [
  'style-loader',
  {
    loader: 'css-loader',
    options: {
      importLoaders: 1
    }
  },
  {
    loader: 'less-loader',
    options: {
      noIeCompat: true
    }
  }
];
```

- 条件

```js
/**
 *
 { test: Condition }：匹配特定条件。一般是提供一个正则表达式或正则表达式的数组，但这不是强制的。
 { include: Condition }：匹配特定条件。一般是提供一个字符串或者字符串数组，但这不是强制的。
 { exclude: Condition }：排除特定条件。一般是提供一个字符串或字符串数组，但这不是强制的。
 { and: [Condition] }：必须匹配数组中的所有条件
 { or: [Condition] }：匹配数组中任何一个条件
 { not: [Condition] }：必须排除这个条件
 */
{
  test: /\.css$/,
  include: [
    path.resolve(__dirname, "app/styles"),
    path.resolve(__dirname, "vendor/styles")
  ]
}
```

## 解析(resolve)

- resolve

```js
/**
 * 配置模块如何解析。
 * 这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节
 */
```

- resolve.alias

```js
/**
 * 创建 import 或 require 的别名，来确保模块引入变得更简单。
 */
alias: {
  Utilities: path.resolve(__dirname, 'src/utilities/'),
  Templates: path.resolve(__dirname, 'src/templates/')
}

// 导入
import Utility from '../../utilities/utility';
// 也可以使用别名
import Utility from 'Utilities/utility';

/**
  * 末尾添加 $，以表示精准匹配
  */
alias: {
  xyz$: path.resolve(__dirname, 'path/to/file.js')
}
import Test1 from 'xyz'; // 精确匹配，所以 path/to/file.js 被解析和导入
import Test2 from 'xyz/file.js'; // 非精确匹配，触发普通解析
```

- resolve.aliasFields

```js
/**
 * 指定一个字段，例如 browser，根据此规范进行解析。默认：
 * aliasFields: ["browser"]
 */
```

- resolve.cacheWithContext

```js
/**
 * 解析缓存(resolve caching)中的上下文(context)会被忽略。这解决了性能衰退的问题。
 */
```

- resolve.descriptionFiles

```js
/**
 * 用于描述的 JSON 文件。默认
 * descriptionFiles: ["package.json"]
 */
```

- resolve.enforceExtension

```js
/**
 * 如果是 true，将不允许无扩展名(extension-less)文件。
 */
```

- resolve.enforceModuleExtension

```js
/**
 * 对模块是否需要使用的扩展（例如 loader）。
 */
```

- resolve.extensions

```js
/**
 * 自动解析确定的扩展。默认值为
 * extensions: [".js", ".json"]
 */
```

- resolve.extensions

```js
/**
 * 自动解析确定的扩展。默认值为
 * extensions: [".js", ".json"]

 * 能够使用户在引入模块时不带扩展：
 * import File from '../path/to/file'
 */
```

- resolve.mainFields

```js
/**
 * 当 target 属性设置为 webworker, web 或者没有指定，默认值为：
 * mainFields: ["browser", "module", "main"]

 * 对于其他任意的 target（包括 node），默认值为：
 * mainFields: ["module", "main"]

 * 例如，D3 的 package.json 含有这些字段：
 * 当我们 import * as D3 from "d3"，实际从 browser 属性解析文件。在这里 browser 属性是最优先选择的，
 * 因为它是 mainFields 的第一项。
 * 由 webpack 打包的 Node.js 应用程序默认会从 module 字段中解析文件。
 {
  ...
  main: 'build/d3.Node.js',
  browser: 'build/d3.js',
  module: 'index',
  ...
}
 */
```

- resolve.mainFiles

```js
/**
 * 解析目录时要使用的文件名。默认：
 * mainFiles: ["index"]
 */
```

- resolve.modules

```js
/**
 * 告诉 webpack 解析模块时应该搜索的目录
 * 使用绝对路径，将只在给定目录中搜索。
 * modules: ["node_modules"]

 * 如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索：
 * modules: [path.resolve(__dirname, "src"), "node_modules"]
 */
```

- resolve.unsafeCache

```js
/**
 * 启用，会主动缓存模块，但并不安全。传递 true 将缓存一切。
 * 默认：unsafeCache: true

 * 只缓存 utilities 模块：
 * unsafeCache: /src\/utilities/
 */
```

- resolve.plugins

```js
/**
 * 应该使用的额外的解析插件列表。它允许插件，如 DirectoryNamedWebpackPlugin。
 */
plugins: [new DirectoryNamedWebpackPlugin()];
```

- resolve.symlinks

```js
/**
 * 是否将符号链接(symlink)解析到它们的符号链接位置(symlink location)
 * 启用时，符号链接(symlink)的资源，将解析为其_真实_路径，而不是其符号链接(symlink)位置。
 */
```

- resolve.cachePredicate

```js
/**
 * 决定请求是否应该被缓存的函数。函数传入一个带有 path 和 request 属性的对象
 */
cachePredicate: function() { return true }
```

- resolveLoader

```js
/**
 * 这组选项与上面的 resolve 对象的属性集合相同，但仅用于解析 webpack 的 loader 包
 */
{
  modules: [ 'node_modules' ],
  extensions: [ '.js', '.json' ],
  mainFields: [ 'loader', 'main' ]
}
```

- resolveLoader.moduleExtensions

```js
/**
 * 解析 loader 时，用到扩展名(extensions)/后缀(suffixes)。
 * 如果你确实想省略 -loader，也就是说只使用 example，则可以使用此选项来实现：
 * moduleExtensions: [ '-loader' ]
 */
```
