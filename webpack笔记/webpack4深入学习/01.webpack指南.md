# webpack 指南

## 快速起步

- 安装

```bash
## webpack-cli 命令行交互工具
## webpack
## webpack-dev-server 服务器开发环境

## 创建一个项目
## 创建package.json文件
npm init -y

## 安装webpack-cli | webpack | webpack-dev-server
npm i webpack-cli webpack webpack-dev-server -D

## 安装相关依赖
## 安装一个要打包到生产环境的安装包时
npm install --save lodash
## 安装一个用于开发环境的安装包
npm install --save-dev 安装包

```

- 配置

```bash
## 在 webpack 4 中，可以无须任何配置使用也可以正常运行
## 如果 webpack.config.js 存在，则 webpack 命令将默认选择使用它。

## 在根目录下新建 webpack.config.js 文件
## 可通过npx使用新配置文件执行构建
npx webpack --config webpack.config.js

## 通过NPM 脚本(NPM Scripts)使用新配置文件执行构建
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack"
  },
## 使用 npm run build 命令执行构建
```

## 管理资源

- css 资源的处理

```bash
## 安装 style-loader 和 css-loader
cnpm i style-loader css-loader -D
## webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。
{
  test: /\.css$/,
  use: ['style-loader', 'css-loader']
}
## 样式会解析并通过<style>标签插入到index.html中
```

- 加载图片

```bash
## 安装file-loader
npm i file-loader -D

## 图片的引用
## import MyImage from './my-image.png'
该图像将被处理并添加到 output 目录，
并且_MyImage 变量将包含该图像在处理后的最终 url。
## CSS 中的 url('./my-image.png') 会使用类似的过程去处理。
## html-loader 以相同的方式处理 <img src="./my-image.png" />
{
  test: /\.(png|svg|jpg|gif)$/,
  use: ['file-loader']
},
## 压缩和优化图片
## 安装image-webpack-loader url-loader

```

- 加载字体

```bash
## 安装 file-loader 和 url-loader
## 可以接收并加载任何文件，然后将其输出到构建目录
npm i file-loader url-loader -D
{
  test: /\.(woff|woff2|eot|ttf|otf)$/,
  use: ['file-loader']
}

```

- 加载数据

```bash
## JSON文件
## 仅读取了数据 并没有在dist目录下生成json文件
JSON 支持实际上是内置的，也就是说 import Data from './data.json' 默认将正常运行。

## 导入 CSV、TSV 和 XML
## 安装csv-loader xml-loader
## csv-loader 依赖于papaparse
npm i papaparse csv-loader xml-loader -D
import Data from './data.xml';
console.log(Data);
{
  test: /\.(csv|tsv)$/,
  use: ['csv-loader']
},
{
  test: /\.xml$/,
  use: ['xml-loader']
}

```

- 全局资源

```bash
## 提倡使用如下目录结构管理资源
- |- /assets
+ |– /components
+ |  |– /my-component
+ |  |  |– index.jsx
+ |  |  |– index.css
+ |  |  |– icon.svg
+ |  |  |– img.png
```

## 管理输出

- 多个入口文件

```bash
## 构建后会在dist目录中生成多个编译后的js文件
entry: {
  app: './src/index.js',
  print: './src/print.js'
},
output: {
  filename: '[name].bundle.js',
  path: path.resolve(__dirname, 'dist')
}
```

- 设定 HtmlWebpackPlugin

```bash
## 安装 html-webpack-plugin
npm i html-webpack-plugin -D

## 配置
const HtmlWebpackPlugin = require('html-webpack-plugin');
plugins: [
  new HtmlWebpackPlugin({
    title: 'Output Management'
  })
],

## 构建后会自动生成index.html文件，并引入对应的js文件
## 无需模板也可以生产index.html文件

## 安装html-webpack-template
除了默认模板之外，还提供了一些额外的功能

```

- 清理 /dist 文件夹

```bash
## 每次构建前清理 /dist 文件夹，是比较推荐的做法
## 安装clean-webpack-plugin
npm i clean-webpack-plugin -D

## 配置
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
plugins: [
  new CleanWebpackPlugin(),
  new HtmlWebpackPlugin({
    title: 'Output Management'
  })
],

```

- manifest

```bash
## 通过 manifest，webpack 知道应该生成哪些文件
## 通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪。
## 通过使用 WebpackManifestPlugin，可以直接将数据提取到一个 json 文件，以供使用
```

## 开发

- 使用 source map

```bash
## 使用 source map
## 准确地知道错误来自于哪个源文件
## source map 功能，将编译后的代码映射回原始源代码
## 如果一个错误来自于 b.js，source map 就会明确的告诉你

## 配置
## 使用 inline-source-map 选项(不要用于生产环境)
devtool: 'inline-source-map',
```

- 使用 webpack-dev-server

```bash
## 代码发生变化后自动编译代码
## 自动刷新浏览器
## 配置
## 在 localhost:8080 下建立服务，将 dist 目录下的文件，作为可访问文件。
devServer: {
  contentBase: './dist'
},

## 在package中配置Script
"start": "webpack-dev-server --open",
```

- 使用 webpack-dev-middleware 进行自定义配置

```bash
## webpack-dev-server 在内部使用了webpack-dev-middleware
## webpack-dev-middleware 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)
## 它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求

## 安装 express 和 webpack-dev-middleware：
## 使用koa会报错
npm i express webpack-dev-middleware -D

## 在webpack.config.js文件中
output: {
  filename: '[name].bundle.js',
  path: path.resolve(__dirname, 'dist'),
  publicPath: '/'
}

## 新建server.js
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(
  webpackDevMiddleware(compiler, {
    publicPath: config.output.publicPath
  })
);

app.listen(3000, function() {
  console.log('Example app listening on port 3000!\n');
});

## package.json文件中配置快捷启动
"server": "node server.js"

## 如果有修改能自动编译 但是浏览器貌似不能自动刷新

```

## 模块热替换

- 启用 HMR

```bash
## 它允许在运行时更新各种模块，而无需进行完全刷新
## HMR 不适用于生产环境，这意味着它应当只在开发环境使用


## 使用webpack-dev-server的配置(这种方式速度是最快的)
## NamedModulesPlugin，以便更容易查看要修补(patch)的依赖
const webpack = require('webpack');
devServer: {
  contentBase: './dist',
  hot: true
},
new webpack.NamedModulesPlugin(),
new webpack.HotModuleReplacementPlugin()

## webpack-dev-middleware的配置
## 安装webpack-hot-middleware包，以在你的自定义服务或应用程序上启用 HMR
npm i webpack-hot-middleware -D

## server.js文件中(不会自动刷新和进行热替换bug)
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');
const webpackHotMiddleware = require('webpack-hot-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(
  webpackDevMiddleware(compiler, {
    publicPath: config.output.publicPath
  })
);

app.use(
  webpackHotMiddleware(compiler, {
    heartbeat: 2000
  })
);

app.listen(3000, function() {
  console.log('Example app listening on port 3000!\n');
});

```

-通过 Node.js API (自定义配置推荐使用)

```bash
## 当使用 webpack dev server 和 Node.js API 时
## 不要将 dev server 选项放在 webpack 配置对中。而是，在创建选项时，将其作为第二个参数传递
## new WebpackDevServer(compiler, options)

## 感觉启动速度比较慢

## 新建dev-server.js文件
const webpackDevServer = require('webpack-dev-server');
const webpack = require('webpack');

const config = require('./webpack.config.js');
const options = {
  contentBase: './dist',
  hot: true,
  host: 'localhost'
};

webpackDevServer.addDevServerEntrypoints(config, options);
const compiler = webpack(config);
const server = new webpackDevServer(compiler, options);

server.listen(5000, 'localhost', () => {
  console.log('dev server listening on port 5000');
});

## package.json添加快捷启动
"dev": "node dev-server.js"

```

- HMR 修改样式表

```bash
## 安装 style-loader css-loader
npm i style-loader css-loader -D

## 常规配置后即可实现热替换
```

- 其他代码和框架

```bash
## React Hot Loader：实时调整 react 组件。
## Vue Loader：此 loader 支持用于 vue 组件的 HMR，提供开箱即用体验。
## Elm Hot Loader：支持用于 Elm 程序语言的 HMR。
## Redux HMR：无需 loader 或插件！只需对 main store 文件进行简单的修改。
## Angular HMR：没有必要使用 loader！只需对主要的 NgModule 文件进行简单的修改，由 HMR API 完全控制。
```

- index.js 文件

```js
import _ from 'lodash';
import printMe from './print.js';
import './styles.css';

import { cube } from './math.js';

function component() {
  var element = document.createElement('div');
  var btn = document.createElement('button');

  element.innerHTML = _.join(['Hello', 'webpack'], ' ');

  btn.innerHTML = '点击我';
  btn.onclick = printMe;
  element.appendChild(btn);
  return element;
}

let element = component(); // 当 print.js 改变导致页面重新渲染时，重新获取渲染的元素
document.body.appendChild(element);

if (module.hot) {
  module.hot.accept('./print.js', function() {
    console.log('Accepting the updated printMe module!');
    document.body.removeChild(element);
    element = component(); // 重新渲染页面后，component 更新 click 事件处理
    document.body.appendChild(element);
  });
}
```

## tree shaking 树摇晃

- 基本概念

```bash
## tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。
## 它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。

## webpack 4 正式版本
## 通过 package.json 的 "sideEffects" 属性作为标记，向 compiler 提供提示，
## 表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。
```

- 添加一个通用模块

```bash
## 添加src/main.js
export function square(x) {
  return x * x;
}

export function cube(x) {
  return x * x * x;
}

## 问题一：square 没有被导入，但是，它仍然被包含在 bundle 中

```

- 将文件标记为无副作用(side-effect-free)

```bash
## 通过 package.json 的 "sideEffects" 属性来实现
## 标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出
{
  "name": "your-project",
  "sideEffects": false
}
## 副作用」不纯的代码
## 定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。
{
  "name": "your-project",
  "sideEffects": [
    "./src/some-side-effectful-file.js"
  ]
}

## 任何导入的文件都会受到 tree shaking 的影响
## 如果在项目中使用类似 css-loader 并导入 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除：
{
  "name": "your-project",
  "sideEffects": [
    "./src/some-side-effectful-file.js",
    "*.css"
  ]
}

## 最后，还可以在 module.rules 配置选项 中设置 "sideEffects"。

```

- 压缩输出

```bash
## 使用 -p(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件
## --optimize-minimize 标记也会在 webpack 内部调用 UglifyJsPlugin。
## webpack 4 开始，也可以通过 "mode" 配置选项轻松切换到压缩输出，只需设置为 "production"
mode: 'production',
## 看到 cube 函数的修改版本（function r(e){return e*e*e}n.a=r）

## 具体步骤
## 使用 ES2015 模块语法（即 import 和 export）。
## 在项目 package.json 文件中，添加一个 "sideEffects" 入口。
## 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）。
```

## 生产环境构建

## 补充知识

- npx 使用教程

```bash
## npm 从5.2版开始，增加了 npx 命令
## 万一不能用，就要手动安装一下
npm install -g npx

## npx解决了哪些问题
## 让项目内部安装的模块用起来更方便
## 1.通过命令行执行,项目脚本和 package.json 的scripts字段里面有对应配置(方案1)
npm run webpack
## 2.项目的根目录下执行(方案2)
node-modules/.bin/mocha --version
## 3.在项目根目录下通过npx执行(方案3推荐)
npx webpack

## 原理
## 会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。
## 由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。
# 等同于 ls
npx ls

## 避免全局模块安装
## npx可以运行全局安装模块，而不运行安装全局模块
## npx 将模块下载到一个临时目录，使用以后再删除。
## 以后再次执行上面的命令，会重新下载对应模块

## 只要 npx 后面的模块无法在本地发现，就会下载同名模块。
## 允许运行指定版本：指定使用 3.1.0 版本的uglify-js压缩脚本
npx uglify-js@3.1.0 main.js -o ./dist/main.js

## 命令参数
## --no-install
## 让 npx 强制使用本地模块，不下载远程模块
## 如果本地不存在该模块，就会报错。
npx --no-install http-server

## --ignore-existing
## 忽略本地的同名模块，强制安装使用远程模块
npx --ignore-existing create-react-app my-react-app

## 使用npx允许不同版本的node
## 下面命令会使用 0.12.8 版本的 Node 执行脚本。
## 原理是从 npm 下载这个版本的 node，使用后再删掉。
## 某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些
npx node@0.12.8 -v
v0.12.8

## -p 参数
## -p参数用于指定 npx 所要安装的模块
## 下面命令先指定安装node@0.12.8，然后再执行node -v命令。
npx -p node@0.12.8 node -v
v0.12.8
## -p参数对于需要安装多个模块的场景很有用
npx -p lolcatjs -p cowsay [command]

## -c参数
## 如果 npx 安装多个模块，默认情况下，所执行的命令之中，
## 只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。
## -c参数可以将所有命令都用 npx 解释。
npx -p lolcatjs -p cowsay -c 'cowsay hello | lolcatjs'


## 执行 GitHub 源码
## 远程代码必须是一个模块，即必须包含package.json和入口脚本
## 执行 Gist 代码
$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
## 执行仓库代码
$ npx github:piuccio/cowsay hello
```

## 参考文章

[webpack 中文文档](https://www.webpackjs.com/concepts/)
[markdown 文件编写规范](https://www.cnblogs.com/liugang-vip/p/6337580.html)
[Webpack 揭秘——走向高阶前端的必经之路](https://github.com/jerryOnlyZRJ/webpack-loader)
[Webpack 运行机制](https://github.com/jerryOnlyZRJ/webpack-loader)
[《深入浅出 webpack》 读书笔记](https://blog.csdn.net/qq_39232515/article/details/88394114)
[npm 中文网](https://www.npmjs.cn/)
