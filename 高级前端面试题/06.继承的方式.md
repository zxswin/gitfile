# 继承的方式

- 纯原型链继承

```js
/**
 * 缺陷
 * 无法给父类的构造函数传递参数
 * 原型链的改变会影响所有已经构造出的实例。这是一种灵活性，也是一种危险。
 * 父类可能有一些属性不适合共享，但是纯原型链继承强迫所有父类属性都要共享。
 */
function SuperType() {
  this.property = 1;
}
// 将方法放在原型上，以便所有实例共用，避免重复定义
SuperType.prototype.getSuperValue = function() {
  return this.property;
};

function SubType() {
  this.subproperty = 2;
}
SubType.prototype = new SuperType();
// 将方法放在原型上，以便所有实例共用，避免重复定义
SubType.prototype.getSubValue = function() {
  return this.subproperty;
};
var instance = new SubType();
console.log(instance.getSuperValue()); // 1
console.log(instance instanceof SubType); // true
console.log(instance instanceof SuperType); // true
```

- 纯构造函数继承

```js
/**
 * 缺陷
 * 与创建对象的构造函数模式相同，低效率，函数重复定义，无法复用
 * 使用这种方式的前提就是所有需要继承的属性都在父构造函数上
 * 对象识别功能不全。无法使用 instanceof 来判断某个对象是否继承自某个父类。
 * 无法得到父类原型上的属性
 */
function SuperType(fatherName) {
  this.fatherName = fatherName;
  this.fatherArray = ['red', 'blue', 'green'];
}

function SubType(childName, fatherName) {
  SuperType.call(this, fatherName);
  this.childName = childName;
}
var child1 = new SubType('childName1', 'fatherName1');
var child2 = new SubType('childName2', 'fatherName2');

child1.fatherArray.push('black');
console.log(child1.fatherArray); //"red,blue,green,black"
console.log(child2.fatherArray); //"red,blue,green"
```

- 组合继承

```js
/**
 * 缺陷
 * 得到一个子对象要执行两次父构造函数，重复定义属性。
 */
// 定义父类
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}
SuperType.prototype.sayName = function() {
  console.log(this.name);
};

// 定义子类
function SubType(name, age) {
  // 这里调用了父对象的构造函数（构造函数继承）
  SuperType.call(this, name);
  this.age = age;
}
// 这里创建了一个父对象来当作原型（原型链继承）
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function() {
  console.log(this.age);
};

var instance1 = new SubType('Nicholas', 29);
var instance2 = new SubType('Greg', 27);

instance1.colors.push('black');
console.log(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas";
instance1.sayAge(); //29

console.log(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg";
instance2.sayAge(); //27
```

- 寄生组合式继承（比较完美的继承方案）

```js
// 定义父类
function SuperType(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}
SuperType.prototype.sayName = function() {
  console.log(this.name);
};

// 定义子类
function SubType(name, age) {
  // 获得父对象实例上的属性
  SuperType.call(this, name);
  this.age = age;
}
/**
 * 获得父对象原型链上的属性  Object.create的作用类似于下面的函数
 * function inherits(Child, Parent) {
  var F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
}
  */
SubType.prototype = Object.create(SuperType.prototype);
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function() {
  console.log(this.age);
};

var instance1 = new SubType('Nicholas', 29);
var instance2 = new SubType('Greg', 27);

instance1.colors.push('black');
console.log(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas";
instance1.sayAge(); //29

console.log(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg";
instance2.sayAge(); //27
```

- Object.create()

```js
/**
 * 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
 * Object.create(proto, [propertiesObject])
 * proto 新创建对象的原型对象。
 * propertiesObject 如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性
 */

/**
 * 用 Object.create实现类式继承
 */
// Shape - 父类(superclass)
function Shape() {
  this.x = 0;
  this.y = 0;
}

// 父类的方法
Shape.prototype.move = function(x, y) {
  this.x += x;
  this.y += y;
  console.info('Shape moved.');
};

// Rectangle - 子类(subclass)
function Rectangle() {
  Shape.call(this); // call super constructor.
}

// 子类续承父类
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

var rect = new Rectangle();

console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true
console.log('Is rect an instance of Shape?', rect instanceof Shape); // true
rect.move(1, 1); // Outputs, 'Shape moved.'

/**
 * 继承多个对象
 */
function MyClass() {
  SuperClass.call(this);
  OtherSuperClass.call(this);
}

// 继承一个类
MyClass.prototype = Object.create(SuperClass.prototype);
// 混合其它
Object.assign(MyClass.prototype, OtherSuperClass.prototype);
// 重新指定constructor
MyClass.prototype.constructor = MyClass;

MyClass.prototype.myMethod = function() {
  // do a thing
};
```
