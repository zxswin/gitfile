# javascript 面向对象

- 对象

```js
/**
 * obj.propertyIsEnumerable(prop) 返回该属性是否可以枚举，如果不是自身的属性，直接返回false。
 * obj.hasOwnProperty(prop)：参数为属性名，返回布尔值，这个属性是否属于对象自身。只要在对象自身上，不管可不可枚举都返回true。
 * in 操作符：用法prop in objectName，返回这个属性是否存在于对象自身或原型链上，只要存在，不管可不可枚举都返回true。注意如果属性名是字符串，要用引号括起来。
 */

/**
 * Object.getOwnPropertyNames(obj)：返回obj的所有自身属性的属性名（包括可枚举和不可枚举的属性）组成的数组。
 * Object.keys(obj)：返回obj的所有可枚举的自身属性的属性名组成的数组。
 * for (variable in object) {...}：迭代一个对象的所有可枚举属性，包括在原型链上的可枚举属性。
 */
```

- 原型链

```bash
每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的原型对象（ prototype ）
该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null
null 没有原型，并作为这个原型链中的最后一个环节。
几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。

JavaScript 对象有一个指向一个原型对象的链。
当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，
依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

arr ----> Array.prototype ----> Object.prototype ----> null

__proto__与prototype的区别！__proto__才是真正连接原型链的东西，而prototype只是构造函数的一个指针属性而已。

new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：
xiaoming.constructor === Student.prototype.constructor; // true
Student.prototype.constructor === Student; // true
Object.getPrototypeOf(xiaoming) === Student.prototype; // true
xiaoming instanceof Student; // true

```

- 原型继承

```js
/**
 * 定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；
 * 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；
 * 继续在新的构造函数的原型上定义新方法。
 */

function inherits(Child, Parent) {
  var F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
}

function Student(props) {
  this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function() {
  alert('Hello, ' + this.name + '!');
};

function PrimaryStudent(props) {
  Student.call(this, props);
  this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function() {
  return this.grade;
};
```

- Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的**proto**。

```js
/**
 * Object.create(proto, [propertiesObject])
 */
const person = {
  isHuman: false,
  printIntroduction: function() {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  }
};

const me = Object.create(person);

const me1 = Object.create(person);

me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten

me.printIntroduction(); // expected output: "My name is Matthew. Am I human? true"
console.log(me.isHuman); // true
console.log(me1.isHuman); // false
```

- Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）

```js
/**
 * Object.getPrototypeOf(object)
 * 等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__。
 */
const prototype1 = {};
const object1 = Object.create(prototype1);

console.log(Object.getPrototypeOf(object1) === prototype1);
// 输出: true
```

## 继承

- Function​.prototype​.call()

```js
/**
 * 语法：fun.call(thisArg, arg1, arg2, ...)
 * call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。
 * call() 方法接受的是一个参数列表
 * 在非严格模式下运行，则指定为 null 和 undefined 的 this 值会自动指向全局对象
 * 同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。
 * 可以使用 call 来实现继承
 */
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  /** 通过call对象冒充的方式继承  */
  Product.call(this, name, price);
  this.category = 'food';
}

console.log(new Food('cheese', 5).name);
// 输出: "cheese"

/**
 * 通过调用父构造函数的 call 方法来实现继承
 */
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = 'food';
}

function Toy(name, price) {
  Product.call(this, name, price);
  this.category = 'toy';
}

var cheese = new Food('feta', 5);
var fun = new Toy('robot', 40);

/**
 * 使用 call 方法调用匿名函数
 */
var animals = [
  { species: 'Lion', name: 'King' },
  { species: 'Whale', name: 'Fail' }
];

for (var i = 0; i < animals.length; i++) {
  (function(i) {
    this.print = function() {
      console.log('#' + i + ' ' + this.species + ': ' + this.name);
    };
    this.print();
  }.call(animals[i], i));
}

/**
 * 使用 call 方法调用函数并且指定上下文的 'this'
 */
function greet() {
  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(
    ' '
  );
  console.log(reply);
}

var obj = {
  animal: 'cats',
  sleepDuration: '12 and 16 hours'
};

greet.call(obj); // cats typically sleep between 12 and 16 hours
```

- Function​.prototype​.apply()

```js
/**
 * func.apply(thisArg, [argsArray])
 * apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。
 * call()方法的作用和 apply() 方法类似
 * call()方法接受的是参数列表，而apply()方法接受的是一个参数数组
 */

var numbers = [5, 6, 2, 3, 7];

var max = Math.max.apply(null, numbers);

console.log(max); // 输出: 7

/*如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 */
var min = Math.min.apply(null, numbers);

console.log(min); // 输出: 2

/**
 * 用 apply 将数组添加到另一个数组
 */
var array = ['a', 'b'];
var elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]
```

- Function​.prototype​.bind()

```js
/**
 * function.bind(thisArg[, arg1[, arg2[, ...]]])
 * bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。
 * 并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。
 * 如果bind函数的参数列表为空，执行作用域的this将被视为新函数的thisArg。
 * 返回一个原函数的拷贝，并拥有指定的this值和初始参数。
 */
var module = {
  x: 42,
  getX: function() {
    return this.x;
  }
};

var unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// 输出: undefined

/** bind()方法创建一个新的函数，在调用时设置this关键字为提供的值  */
var boundGetX = unboundGetX.bind(module);
console.log(boundGetX()); // 输出: 42

/** 也可以使用call() 结果是一样的 call 直接执行方法并返回值 */
var boundGetX = unboundGetX.call(module);
console.log(boundGetX); // 输出: 42

/**
 * 创建绑定函数
 */
this.x = 9; // 在浏览器中，this指向全局的 "window" 对象
var module = {
  x: 81,
  getX: function() {
    return this.x;
  }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();
// 返回9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 'this' 绑定到 module 对象
// 新手可能会将全局变量 x 与 module 的属性 x 混淆
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81

/** 偏函数  */
function list() {
  return Array.prototype.slice.call(arguments);
}

function addArguments(arg1, arg2) {
  return arg1 + arg2;
}

var list1 = list(1, 2, 3); // [1, 2, 3]

var result1 = addArguments(1, 2); // 3

// 创建一个函数，它拥有预设参数列表。
var leadingThirtysevenList = list.bind(null, 37);

// 创建一个函数，它拥有预设的第一个参数
var addThirtySeven = addArguments.bind(null, 37);

var list2 = leadingThirtysevenList();
// [37]

var list3 = leadingThirtysevenList(1, 2, 3);
// [37, 1, 2, 3]

var result2 = addThirtySeven(5);
// 37 + 5 = 42

var result3 = addThirtySeven(5, 10);
// 37 + 5 = 42 ，第二个参数被忽略

/**
 * 配合 setTimeout
 * 在默认情况下，使用 window.setTimeout() 时，this 关键字会指向 window （或global）对象
 */
function LateBloomer() {
  this.petalCount = Math.ceil(Math.random() * 12) + 1;
}

// 在 1 秒钟后声明 bloom
LateBloomer.prototype.bloom = function() {
  /* 显式地把 this 绑定到回调函数，就不会丢失该实例的引用。 */
  window.setTimeout(this.declare.bind(this), 1000);
};

LateBloomer.prototype.declare = function() {
  /* 在默认情况下，使用 window.setTimeout() 时，this 关键字会指向 window （或global）对象 */
  console.log('I am a beautiful flower with ' + this.petalCount + ' petals!');
};

var flower = new LateBloomer();
flower.bloom(); // 一秒钟后, 调用'declare'方法
```
