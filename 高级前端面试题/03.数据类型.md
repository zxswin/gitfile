# 数据类型

- js 的数据类型

```js
/**
 * 数据类型
 * 字符串、数字、布尔、数组、对象、Null、Undefined
 * 
 * 
 * 原始类型（primitives types）
    boolean
    number 包括Infinity和NaN，你可以通过typeof Infinity;来验证
    string
    null
    undefined
 * 
 * 对象类型
    基本对象：
    Object
    Function
    Boolean
    Symbol
    Error
    EvalError
    InternalError
    RangeError
    ReferenceError
    SyntaxError
    TypeError
    URIError

    数字和日期对象
    Number
    Math
    Date

    字符串
    String
    RegExp

    可索引的集合对象
    Array
    Int8Array
    Uint8Array
    Uint8ClampedArray
    Int16Array
    Uint16Array
    Int32Array
    Uint32Array
    Float32Array
    Float64Array

    使用键的集合对象
    Map
    Set
    WeakMap
    WeakSet

    矢量集合
    SIMD 
    SIMD.Float32x4 
    SIMD.Float64x2 
    SIMD.Int8x16 
    SIMD.Int16x8 
    SIMD.Int32x4 
    SIMD.Uint8x16 
    SIMD.Uint16x8 
    SIMD.Uint32x4 
    SIMD.Bool8x16 
    SIMD.Bool16x8 
    SIMD.Bool32x4 
    SIMD.Bool64x2 

    结构化数据
    ArrayBuffer
    SharedArrayBuffer 
    Atomics 
    DataView
    JSON

    控制抽象对象
    Promise
    Generator
    GeneratorFunction
    AsyncFunction

    反射
    Reflect
    Proxy

    国际化
    Intl
    Intl.Collator
    Intl.DateTimeFormat
    Intl.NumberFormat

    WebAssembly
    WebAssembly
    WebAssembly.Module
    WebAssembly.Instance
    WebAssembly.Memory
    WebAssembly.Table
    WebAssembly.CompileError
    WebAssembly.LinkError
    WebAssembly.RuntimeError

    其他
    arguments

 */
```

- js 的自动装箱

```js
/**
 * js标准库给boolean、number、string分别提供了一个包装对象
 * Boolean、Number、String
 * 在需要的时候，原始类型会自动转换成相应的包装对象（这个过程叫自动装箱）
 *
 * 自动装箱就是临时创建一个包装对象，将原始类型的值封装起来，以便调用包装对象的函数。
 */
var str = 'I am str';
str.toUpperCase(); // "I AM STR"

/**
 * 手动装箱
 */
var str_object = new String('I am str_object'); //  手动装箱
str_object.toUpperCase(); //  "I AM STR_OBJECT"
typeof str_object; //  "object"
```

- valueOf()

```js
/**
 * valueOf() 方法返回指定对象的原始值
 * js的许多内置对象都重写valueOf() 覆盖Object原型链上的valueOf()方法以返回适当的值
 * 如果对象没有原始值，则valueOf将返回对象本身。
 *
 * 不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。
    Array	返回数组对象本身。
    Boolean	布尔值。
    Date	存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。
    Function	函数本身。
    Number	数字值。
    Object	对象本身。这是默认情况。
    String	字符串值。
    Math 和 Error 对象没有 valueOf 方法。
 */
// Array：返回数组对象本身
var array = ['ABC', true, 12, -5];
console.log(array.valueOf() === array); // true

// Date：当前时间距1970年1月1日午夜的毫秒数
var date = new Date(2013, 7, 18, 23, 11, 59, 230);
console.log(date.valueOf()); // 1376838719230

// Number：返回数字值
var num = 15.2654;
console.log(num.valueOf()); // 15.2654

// 布尔：返回布尔值true或false
var bool = true;
console.log(bool.valueOf() === bool); // true

// new一个Boolean对象
var newBool = new Boolean(true);
// valueOf()返回的是true，两者的值相等
console.log(newBool.valueOf() == newBool); // true
// 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型
console.log(newBool.valueOf() === newBool); // false

// Function：返回函数本身
function foo() {}
console.log(foo.valueOf() === foo); // true
var foo2 = new Function('x', 'y', 'return x + y;');
console.log(foo2.valueOf());
/*
ƒ anonymous(x,y
) {
return x + y;
}
*/

// Object：返回对象本身
var obj = { name: '张三', age: 18 };
console.log(obj.valueOf() === obj); // true

// String：返回字符串值
var str = 'http://www.xyz.com';
console.log(str.valueOf() === str); // true

// new一个字符串对象
var str2 = new String('http://www.xyz.com');
// 两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型
console.log(str2.valueOf() === str2); // false
```

- toString()

```js
/**
 * toString() 方法返回一个表示该对象的字符串。
 * js的许多内置对象都重写toString() 覆盖Object原型链上的toString()方法以返回适当的值
 * 如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"
 */
var o = new Object();
o.toString(); //  '[object Object]'

var o = { a: 1 };
o.toString(); //  '[object Object]'

var o = function() {};
console.log(o.toString()); // 'function() {}'

var o = [1];
console.log(o.toString()); // '1'

/**
 * 使用toString()检测对象类型
 */
var toString = Object.prototype.toString;

toString.call(new Date()); // [object Date]
toString.call(new String()); // [object String]
toString.call(Math); // [object Math]

// Since JavaScript 1.8.5
toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]
```

- 显式类型转换（强制类型转换）

```js
Boolean('sdfsd'); //  true
Number('23'); //  23
String({ a: 24 }); //  "[object Object]"
```

- 不同的检测方案

```js
/**
 * 1、不完全准确的检测：typeof
 * 优点：使用简单，能直接输出结果
 * 缺点：检测出的类型太少，不能检测出object的具体类型
    num   =>	number
    str	  =>  string
    bool  =>	boolean
    arr   =>	object
    json  =>	object
    function  =>	function
    undefined   =>	undefined
    null  =>	object
    date  =>	object
    reg   =>	object
    error =>	object
 */

var str = 'abcdef';
typeof str === 'string'; //true

/**
 * 2、不完全准确的检测：instanceof
 * 优点：明确地确认对象(object)为某个特定类型；能检测出多层继承的关系
 * 缺点：对number、string、boolean类型的变量声明方式有要求，必须用new方法声明才能检测，不能跨iframe
    var num = 123;	num instanceof Number	 => false
    var num = new Number(123);	num instanceof Number	=> true
    var str = “abcdef”;	str instanceof String	=> false
    var str = new String(“abcdef”);	str instanceof String	=> true
    var bool = true;	bool instanceof Boolean	=> false
    var bool = new Boolean(true);	bool instanceof Boolean	=> true
    var arr = [1,2,3,4];	arr instanceof Array	=> true
    {name:“苏”,age:25};	json instanceof Object	=> true
    var func = function(){console.log(‘this is function’);}	func instanceof Function	=> true
    var und = undefined;	und instanceof Object	=> false
    var nul = null;	nul instanceof Object	=> false
    var date = new Date();	date instanceof Date	=> true
    var reg = / ^ [a-zA-Z]{5,20}$ /;	reg instanceof RegExp	=> true
    var err = new Error();	err instanceof Error	=> true
 */

// instanceof用于识别正在处理的对象（Object）类型
function Person() {}
function Student() {}
Student.prototype = new Person();
var Tom = new Student();
console.log(Tom instanceof Person); //true
console.log(Tom instanceof Student); //true

/**
 * 3、不完全准确的检测：constructor
 * 除了undefined和null，其他类型的变量都可以使用constructor检测
 * constructor属性可以被修改，会导致结果不正确，不能跨iframe
 * 
  var Tom = new Person();	Tom.constructor == Person => true
  var num = 123;	num.constructor == Number	=> true
  var str = “abcdef”;	str.constructor == String	=> true
  var bool = true;	bool.constructor == Boolean	=> true
  var arr = [1,2,3,4];	arr.constructor == Array	=> true
  {name:“苏”,age:25};	json.constructor == Object	=> true
  var func = function(){console.log(‘this is function’);}	func.constructor == Function	=> true
  var date = new Date();	date.constructor == Date	=> true
  var reg = / ^ [a-zA-Z]{5,20}$ /;	reg.constructor == RegExp	=> true
  var err = new Error();	err.constructor == Error	=> true
 */
var str = 'abcdef';
console.log(str.constructor === String); //true

// 输出数字类型变量的构造函数
var num = 123;
console.log(num.constructor); // Number() { [native code] }
console.log(num.constructor === Number); //true

// constructor检测不出实例对象John真实的构造函数f
function Person() {}
function Student() {}
Student.prototype = new Person();
// Student原型中的constructor被指向到Person
var John = new Student();
console.log(John.constructor == Student);
console.log(John.constructor == Person);

/**
 * 4、准确的检测：Object.prototype.toString.call
 * 优点：能检测出所有的类型
 * 缺点：IE6下undefined、null均为Object类型
  var num = 123;	Object.prototype.toString.call(num) =>	‘[object Number]’
  var str = “abcdef”;	Object.prototype.toString.call(str) =>	‘[object String]’
  var bool = true;	Object.prototype.toString.call(bool) =>	‘[object Boolean]’
  var arr = [1,2,3,4];	Object.prototype.toString.call(arr) =>	‘[object Array]’
  {name:“苏”,age:25};	Object.prototype.toString.call(json) =>	‘[object Object]’
  var func = function(){console.log(‘this is function’);}	Object.prototype.toString.call(func) =>	‘[object Function]’
  var und = undefined;	Object.prototype.toString.call(und) =>	‘[object Undefined]’
  var nul = null;	Object.prototype.toString.call(nul) =>	‘[object Null]’
  var date = new Date();	Object.prototype.toString.call(date) =>	‘[object Date]’
  var reg = / ^ [a-zA-Z]{5,20}$ /;	Object.prototype.toString.call(reg) =>	‘[object RegExp]’
  var err = new Error();	Object.prototype.toString.call(err) =>	‘[object Error]’
 */

/**
 * 5、使用JQuery中的检测：$.type
 * $.type就是用Object.prototype.toString.call实现的。
    var num = 123;	$.type(num) =>	‘number’
    var str = “abcdef”;	$.type(str) =>	‘string’
    var bool = true;	$.type(bool) =>	‘boolean’
    var arr = [1,2,3,4];	$.type(arr) =>	‘array’
    {name:“苏”,age:25};	$.type(json) =>	‘object’
    var func = function(){console.log(‘this is function’);}	$.type(func) =>	‘function’
    var und = undefined;	$.type(und) =>	‘undefined’
    var nul = null;	$.type(nul) =>	‘null’
    var date = new Date();	$.type(date) =>	‘date’
    var reg = / ^ [a-zA-Z]{5,20}$ /;	$.type(reg) =>	‘regexp’
    var err = new Error();	$.type(err) =>	‘error’
 */
```
