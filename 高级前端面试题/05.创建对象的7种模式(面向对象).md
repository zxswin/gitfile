# 创建对象的 7 种模式(面向对象)

## 工厂模式

- 工厂模式的实现

```js
/**
 * 工厂模式使用一个函数来封装创建对象、属性赋值、组装对象，这个函数叫做工厂函数
 * 低效率，每次调用工厂函数都重复地定义了相同的函数 却各自占用了内存空间和cpu资
 * 对象识别困难。实例对象与它的工厂函数没有关联。
 */
function createPerson(name, age) {
  var o = {};
  o.name = name;
  o.age = age;
  o.sayName = function() {
    alert(this.name);
  };
  return o;
}
var person1 = createPerson('p1', 21);
var person2 = createPerson('p2', 22);
var person3 = createPerson('p3', 23);
```

## 构造函数模式

- 构造函数模式的实现

```js
/**
 * 模板的所有属性都通过构造函数来定义
 * 低效率，每次调用工厂函数都重复地定义了相同的函数 却各自占用了内存空间和cpu资
 */
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = function() {
    alert(this.name);
  };
}
var person1 = new Person('p1', 21);
var person2 = new Person('p2', 22);
var person3 = new Person('p3', 23);
```

## 原型模式

- 原型模式的实现

```js
/**
 * 模板的所有属性都定义在原型对象上
 * 让所有实例对象共享原型链上的属性
 *
 * 不会出现构造函数模式中重复定义函数的问题
 * 在实例化的时候我们无法指定新对象的属性值
 * 原型链的改变会影响所有已经构造出的实例
 */
function Person() {}
Person.prototype = {
  name: 'Nicholas',
  age: 29,
  friends: ['Shelby', 'Court'],
  sayName: function() {
    alert(this.name);
  },
  constructor: Person
};
var person1 = new Person();
var person2 = new Person();

/**
 * 也可以不使用构造函数来实现原型模式：
 */
var personTemplate = {
  name: 'Nicholas',
  age: 29,
  friends: ['Shelby', 'Court'],
  sayName: function() {
    alert(this.name);
  }
};
var person1 = Object.create(personTemplate);
var person2 = Object.create(personTemplate);
```

## 组合使用构造函数模式和原型模式

```js
/**
 * 构造函数模式的思路是每次实例化对象的时候都给新对象定义属性。
 * 原型模式的思路是所有实例对象共享同一条原型链。
 * 通过构造函数来定义那些需要属于自己的属性，通过原型对象来定义那些需要共享的属性（尤其是函数）。
 *
 * 构造函数定义与原型定义的割裂。 不在同一个代码块中
 */
function Person(name, age, friends) {
  this.name = name;
  this.age = age;
  this.friends = friends;
}
Person.prototype = {
  constructor: Person,
  sayName: function() {
    alert(this.name);
  }
};
var person1 = new Person('p1', 21, ['f1', 'f2']);
var person2 = new Person('p2', 22, ['f3', 'f4']);
```

## 动态原型模式

```js
/**
 * 将原型的配置放在了构造函数中，使得“模板定义”的代码集中在了一个代码块中。
 */
function Person(name, age) {
  this.name = name;
  this.age = age;
  if (typeof this.sayName != 'function') {
    Person.prototype.sayName = function() {
      alert(this.name);
    };
  }
}
```
