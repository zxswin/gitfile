# 深入理解 JavaScript 系列（5）：强大的原型和原型链

## 强大的原型和原型链

- 原型与原型链继承

```js
/**
 * 原型的继承模型比传统的类继承还要强大
 * JavaScript 是唯一一个被广泛使用的基于原型继承的语言
 * 可以赋值任何类型的对象到原型上，但是不能赋值原子类型的值，比如如下代码是无效的
    function Foo() {}
    Foo.prototype = 1; // 无效

 * 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined(最后指向null  null的prototype是undefined)
 */
function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// 设置Bar的prototype属性为Foo的实例对象
Bar.prototype = new Foo();
Bar.prototype.foo = 'Hello World';

// 修正Bar.prototype.constructor为Bar本身
Bar.prototype.constructor = Bar;

var test = new Bar() // 创建Bar的一个新实例

// 原型链
test [Bar的实例]
    Bar.prototype [Foo的实例]
        { foo: 'Hello World' }
        Foo.prototype
            {method: ...};
            Object.prototype
                {toString: ... /* etc. */};
```

- hasOwnProperty 函数：

```js
/**
 * hasOwnProperty是Object.prototype的一个方法，它可是个好东西，他能判断一个对象是否包含自定义属性而不是原型链上的属性
 */
var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: 'Here be dragons'
};

foo.hasOwnProperty('bar'); // 总是返回 false

// 使用{}对象的 hasOwnProperty，并将其上下为设置为foo
{}.hasOwnProperty.call(foo, 'bar'); // true

// for in 会遍历对象自身属性和原型链上的属性
// foo 变量是上例中的
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
```
