# 深入理解 JavaScript 系列（24）：JavaScript 与 DOM（下）

## 操作元素

```js
/**
 * 设置颜色
 */
var myDocument = document;
var myIntro = myDocument.getElementById('intro');
var myIntroStyles = myIntro.style;

// 现在，我们可以设置颜色了:
myIntroStyles.color = '#FF0000';

/** 用marginTop代替margin-top  */
myIntroStyles.padding = '2px 3px 0 3px';
myIntroStyles.backgroundColor = '#FFF';
myIntroStyles.marginTop = '20px';

/**
 * innerHTML属性
 * 而且在DOM规范里也没有定义，如果你不反感的话请继续使用
 */
var myIntro = document.getElementById('intro');

// 替换当前的内容
myIntro.innerHTML = 'New content for the <strong>amazing</strong> paragraph!';

// 添加内容到当前的内容里
myIntro.innerHTML += '... some more content...';
```

## Node 节点

```js
/**
 * 创建节点并添加内容
 */
var myIntro = document.getElementById('intro');

// 添加内容
var someText = 'This is the text I want to add';
var textNode = document.createTextNode(someText);
myIntro.appendChild(textNode);

/**
 * 节点添加详细案例
 */
var myIntro = document.getElementById('intro');

// 添加新连接到文本节点
// 首先，创建新连接元素
var myNewLink = document.createElement('a'); // <a/>
myNewLink.href = 'http://google.com'; // <a href="http://google.com"/>
myNewLink.appendChild(document.createTextNode('Visit Google'));
// <a href="http://google.com">Visit Google</a>

// 将内容附件到文本节点
myIntro.appendChild(myNewLink);

/**
 * insertBefore方法用于再节点前面附件内容
 */
// 'Target'是DOM里已经存在的元素
// 'Bullet'是要插入的新元素

function insertAfter(target, bullet) {
  target.nextSibling
    ? target.parentNode.insertBefore(bullet, target.nextSibling)
    : target.parentNode.appendChild(bullet);
}

// 使用了3目表达式:
// 格式：条件?条件为true时的表达式：条件为false时的表达式
```

## Event 事件

```js
/**
## 鼠标事件
‘mousedown’ – 鼠标设备按下一个元素的时候触发mousedown事件。
‘mouseup’ – 鼠标设备从按下的元素上弹起的时候触发mouseup事件。
‘click’ – 鼠标点击元素的时候触发click事件。
‘dblclick’ – 鼠标双击元素的时候触发dblclick事件。
‘mouseover’ – 鼠标移动到某元素上的时候触发mouseover事件。
‘mouseout’ – 鼠标从某元素离开的时候触发mouseout事件。
‘mousemove’ – 鼠标在某元素上移动但未离开的时候触发mousemove事件。

## 键盘事件
‘keypress’ – 按键按下的时候触发该事件。
‘keydown’ – 按键按下的时候触发该事件，并且在keypress事件之前。
‘keyup’ – 按键松开的时候触发该事件，在keydown和keypress事件之后。

## 表单事件
‘select’ – 文本字段（input, textarea等）的文本被选择的时候触发该事件。
‘change’ – 控件失去input焦点的时候触发该事件（或者值被改变的时候）。
‘submit’ – 表单提交的时候触发该事件。
‘reset’ – 表单重置的时候触发该事件。
‘focus’ – 元素获得焦点的时候触发该事件，通常来自鼠标设备或Tab导航。
‘blur’ – 元素失去焦点的时候触发该事件，通常来自鼠标设备或Tab导航。

## 其它事件
‘load’ – 页面加载完毕（包括内容、图片、frame、object）的时候触发该事件。
‘resize’ – 页面大小改变的时候触发该事件（例如浏览器缩放）。
‘scroll’ – 页面滚动的时候触发该事件。
‘unload’ – 从页面或frame删除所有内容的时候触发该事件（例如离开一个页面）。
  */
```

- 事件处理

```js
/**
 * 基本事件注册：
 */
var myElement = document.getElementById('my-button');

// 事件处理句柄:
function buttonClick() {
  alert('You just clicked the button!');
}

// 注册事件
myElement.onclick = buttonClick;

/**
 * 高级事件注册：
 */
var myIntro = document.getElementById('intro');
myIntro.addEventListener('click', introClick, false);

/**
 * 跨浏览器通用的事件注册函数
 */
function addEvent(elem, type, fn) {
  if (elem.attachEvent) {
    elem.attachEvent('on' + type, fn);
    return;
  }
  if (elem.addEventListener) {
    elem.addEventListener(type, fn, false);
  }
}

/**
 * 跨浏览器的删除事件句柄
 */
function removeEvent(elem, type, fn) {
  if (elem.detachEvent) {
    elem.detachEvent('on' + type, fn);
    return;
  }
  if (elem.removeEventListener) {
    elem.removeEventListener(type, fn, false);
  }
}

/**
 * 只在第一次点击的时候触发
 */
var myIntro = document.getElementById('intro');
addEvent(myIntro, 'click', oneClickOnly);

function oneClickOnly() {
  alert('WOW!');
  removeEvent(myIntro, 'click', oneClickOnly);
}

/**
 * 取消事件监听 如果是匿名函数
 * arguments对象包含了所有传递进来的参数以及该函数自身(callee
 */
addEvent(myIntro, 'click', function() {
  alert('WOW!');
  removeEvent(myIntro, 'click', arguments.callee);
});
```

## Event 对象

```js
/**
 * 当事件发生的时候出发某个函数，该Event对象将自动在函数内可用
 */
function myEventHandler(e) {
  // 注意参数e
  // 该函数调用的时候e是event对象（W3C实现）

  // 兼容IE的代码
  e = e || window.event;

  // 现在e就可以兼容各种浏览器了
}

// 这里可以自由地绑定事件了

/**
 * 阻止默认行为
 */
function myEventHandler(e) {
  e = e || window.event;
  // 防止默认行为
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    e.returnValue = false;
  }
}
```

## 事件冒泡

```js
/**
 * 事件冒泡，就是事件触发的时候通过DOM向上冒泡
 * 不是所有的事件都有冒泡
 * 事件在一个目标元素上触发的时候，该事件将触发一一触发祖先节点元素，直到最顶层的元素
 */

function myParagraphEventHandler(e) {
  e = e || window.event;

  // 停止向上冒泡
  if (e.stopPropagation) {
    // W3C实现
    e.stopPropagation();
  } else {
    // IE实现
    e.cancelBubble = true;
  }
}

// 使用我们自定义的addEvent函数将myParagraphEventHandler绑定到click事件上：
addEvent(
  document.getElementsByTagName('p')[0],
  'click',
  myParagraphEventHandler
);
```

## 事件委托

```js
/**
 * 如果你有一个很多行的大表格，在每个<tr>上绑定点击事件是个非常危险的想法，因为性能是个大问题。
 * 事件委托描述的是将事件绑定在容器元素上，然后通过判断点击的target子元素的类型来触发相应的事件。
 * 事件委托依赖于事件冒泡，如果事件冒泡到table之前被禁用的话，那上面的代码就无法工作了。
 */
var myTable = document.getElementById('my-table');

myTable.onclick = function() {
  // 处理浏览器兼容
  e = e || window.event;
  var targetNode = e.target || e.srcElement;

  // 测试如果点击的是TR就触发
  if (targetNode.nodeName.toLowerCase() === 'tr') {
    alert('You clicked a table row!');
  }
};
```
