# 深入理解 JavaScript 系列（3）：全面解析 Module 模式

## 关于浏览器

```js
/**
 * 浏览器端，加载 JavaScript 最佳、最容易的方式是在 document 中插入<script> 标签。但脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载。
 */
```

## 关于 CommonJS

```js
/**
 * NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。
 * NPM作为Node的包管理器也要遵循CommonJS规范
 * CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}
 * Browserify 是目前最常用的 CommonJS 格式转换的工具。
 */

/* CommonJS简单实现原理 要实现下面四个变量 
module 代表模块本身。
exports 对象用于导出当前模块的方法或变量，唯一的导出口
require 引入外部模块
global
*/
var module = {
  exports: {}
};

(function(module, exports) {
  exports.multiply = function(n) {
    return n * 1000;
  };
})(module, module.exports);

var f = module.exports.multiply;
f(5); // 5000
```

- Browserify 的实现原理

```js
/** main.js 模块加载 foo.js 模块。  */
// foo.js
module.exports = function(x) {
  console.log(x);
};

// main.js
var foo = require('./foo');
foo('Hi');

/** 使用下面的命令，就能将main.js转为浏览器可用的格式。  */
browserify main.js > compiled.js

/** 通过安装一下browser-unpack解包查看源码
 * 安装 npm install browser-unpack -g
 * 解包 browser-unpack < compiled.js
 *
 * browerify 将所有模块放入一个数组，id 属性是模块的编号，source 属性是模块的源码，deps 属性是模块的依赖。
 *
 *  main.js 里面加载了 foo.js，所以 deps 属性就指定 ./foo 对应1号模块。
 *  执行的时候，浏览器遇到 require('./foo') 语句，就自动执行1号模块的 source 属性，并将执行后的 module.exports 属性值输出。
*/

[
  {
    "id":1,
    "source":"module.exports = function(x) {\n  console.log(x);\n};",
    "deps":{}
  },
  {
    "id":2,
    "source":"var foo = require(\"./foo\");\nfoo(\"Hi\");",
    "deps":{"./foo":1},
    "entry":true
  }
]

```

- 纯浏览器的 CommonJS 模块加载器 tiny-browser-require

```js
/**
 * 虽然 Browserify 很强大，但不能在浏览器里操作，有时就很不方便。
 * 它的逻辑非常简单，就是把模块读入数组，加载路径就是模块的id。
 */
function require(p) {
  var path = require.resolve(p);
  var mod = require.modules[path];
  if (!mod) throw new Error('failed to require "' + p + '"');
  if (!mod.exports) {
    mod.exports = {};
    mod.call(mod.exports, mod, mod.exports, require.relative(path));
  }
  return mod.exports;
}

require.modules = {};

require.resolve = function(path) {
  var orig = path;
  var reg = path + '.js';
  var index = path + '/index.js';
  return (
    (require.modules[reg] && reg) || (require.modules[index] && index) || orig
  );
};

require.register = function(path, fn) {
  require.modules[path] = fn;
};

require.relative = function(parent) {
  return function(p) {
    if ('.' != p.charAt(0)) return require(p);
    var path = parent.split('/');
    var segs = p.split('/');
    path.pop();

    for (var i = 0; i < segs.length; i++) {
      var seg = segs[i];
      if ('..' == seg) path.pop();
      else if ('.' != seg) path.push(seg);
    }

    return require(path.join('/'));
  };
};

/** 使用样例  */
require.register('./foo.js', function(module, exports, require) {
  module.exports = function(x) {
    console.log(x);
  };
});

var foo = require('./foo.js');
foo('Hi');
```

## 关于 AMD 规范

- 实现原理

```js
/**
 * 它采用异步方式加载模块，模块的加载不影响它后面语句的运行。
 * 所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
 * 主要有两个Javascript库实现了AMD规范：require.js和curl.js。
 */

// math.add()与math模块加载不是同步的，浏览器不会发生假死。
require(['math'], function(math) {
  math.add(2, 3);
});
```

- require.js 的加载

```js
/**
 * require.js的诞生，就是为了解决这两个问题：
 * 实现js文件的异步加载，避免网页失去响应；
 * 管理模块之间的依赖性，便于代码的编写和维护。
 */

// 加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：
// async属性表明这个文件需要异步加载，避免网页失去响应。
// IE不支持这个属性，只支持defer，所以把defer也写上。
<script src="js/require.js" defer async="true" />

// 加载main.js文件
// data-main属性的作用是，指定网页程序的主模块。可以省略后缀名
<script src="js/require.js" data-main="js/main"></script>

// main.js
require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC){
   // some code here
});

// 假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：
require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone){
// some code here
});
```

## 关于 CMD 规范

- CMD 的特点

```js
/**
 * 执行时机处理不同
 * CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，
 * CMD是就近依赖，而AMD是前置依赖。也就是说AMD要在一开始就加载所有的依赖，而CMD是一级一级的加载。
 * SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行
 * SeaJS只会在真正需要使用(依赖)模块时才执行该模块
 * SeaJS是异步加载模块的没错, 但执行模块的顺序也是严格按照模块在代码中出现(require)的顺序,
 * 模块的加载都是并行的, 没有区别, 区别在于执行模块的时机, 或者说是解析.


 * RequireJS的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码, 因此执行结果只会"停顿"1次, 完成整个过程是会比SeaJS要快.
 * SeaJS一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析, 这里耗费了时间, 因为这个特例中的模块巨大, 因此造成"停顿"2次的现象, 这就是我所说的SeaJS中的"懒执行".
 * 
 */
```

## 关于 UMD 规范

- UMD 的特点

```js
/**
 * 兼容AMD和CommonJS的规范，还兼容全局引用的方式。因此在浏览器和服务器的环境都可以应用此规范。
 * 实际上就是一个兼容性的写法
 */
(function(name, definition) {
  // 检测上下文环境是否为AMD或CMD
  if (typeof define === 'function' && (define.amd || define.cmd)) {
    define(definition);

    // 检测上下文环境是否为Node
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = definition();
  } else {
    // 将模块的执行结果在window变量中，在浏览器中this指向window对象
    this[name] = definition();
  }
})('hello', function() {
  var hello = function() {};
  return hello;
});
```

## 通过匿名闭包实现模块化

```js
/**
 * 模块的基本写法
 */
var module1 = (function() {
  var _count = 0;

  var m1 = function() {
    //...
  };

  var m2 = function() {
    //...
  };

  return {
    m1: m1,
    m2: m2
  };
})();

/**
 * 简单的模块化代码示例
 */
var blogModule = (function() {
  var my = {},
    privateName = '博客园';

  function privateAddTopic(data) {
    // 这里是内部处理代码
  }

  my.Name = privateName;
  my.AddTopic = function(data) {
    privateAddTopic(data);
  };

  return my;
})();

console.log(blogModule);

/**
 * 松耦合扩展
 */
var blogModule = (function(my) {
  my.AddPhoto = function() {
    //添加内部代码
  };
  return my;
})(blogModule || {});

/**
 * 紧耦合扩展(重写某些属性和方法)
 */
var blogModule = (function(my) {
  var oldAddPhotoMethod = my.AddPhoto;

  my.AddPhoto = function() {
    // 重载方法，依然可通过oldAddPhotoMethod调用旧的方法
  };

  return my;
})(blogModule);

/**
 * 创建子模块
 */
blogModule.CommentSubModule = (function() {
  var my = {};
  // ...

  return my;
})();

/**
 * 输入全局变量 把全局变量当做参数传入
 * 保证模块的独立性，还使得模块之间的依赖关系变得明显
 */
var module1 = (function($, YAHOO) {
  //...
})(jQuery, YAHOO);
```

## AMD 规范

- AMD 规范原理

```js
/**
 * define(id?, dependencies?, factory);
 * id: 模块标识，可以省略。
 * dependencies: 所依赖的模块，可以省略。
 * factory: 模块的实现，或者一个JavaScript对象。
 * id遵循CommonJS Module Identifiers 。dependencies元素的顺序和factory参数一一对应。
 *
 *
 * 实现原理
 * requirejs 导入模块的方式实际就是创建脚本标签
 * 使用 onload 和 onerror 事件可以监听脚本加载完成，以异步的事件来处理异步的事件；
 */
function myRequire(deps, callback) {
  //记录模块加载数量
  var ready = 0;
  //创建脚本标签
  function load(url) {
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.async = true;
    script.src = url;
    return script;
  }
  var nodes = [];
  for (var i = deps.length - 1; i >= 0; i--) {
    nodes.push(load(deps[i]));
  }
  //加载脚本
  for (var i = nodes.length - 1; i >= 0; i--) {
    nodes[i].addEventListener(
      'load',
      function(event) {
        ready++;
        //如果所有依赖脚本加载完成，则执行回调函数；
        if (ready === nodes.length) {
          callback();
        }
      },
      false
    );
    document.head.appendChild(nodes[i]);
  }
}
```

- 模块化之 AMD 规范

```js
/**
 * AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。
 * 采用异步方式加载模块，模块的加载不影响它后面语句的运行。
 * 所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
 * 反复 require 相同的模块，它只加载一次
 */

/**
 * AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：
 * require([module], callback);
 * 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；
 * 第二个参数callback，则是加载成功之后的回调函数。
 */
require(['math'], function(math) {
  math.add(2, 3);
});
```

- require.js 一个实现 AMD 模块化规范的 js 库

```js
/**
 * 实现js文件的异步加载，避免网页失去响应；
 */

// 引入 require.js
// async属性表明这个文件需要异步加载
// IE不支持这个属性，只支持defer，所以把defer也写上。
<script src="js/require.js" defer async="true" />

// 引入 入口文件main.js
// data-main属性的作用是，指定网页程序的主模块。
// 这个文件会第一个被require.js加载
// require.js默认的文件后缀名是js，所以可以把main.js简写成main
<script src="js/require.js" data-main="js/main"></script>

// 实际上只需要这句话就行了
<script type="text/javascript" src="scripts/require.js" data-main="scripts/main.js"></script>

// main.js
// require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；
// 它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题
// 加载的模块会以参数形式传入回调函数
require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC){
});


// 模块的加载
// 主模块的依赖模块是['jquery', 'underscore', 'backbone']
// require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载

// 使用require.config()方法，我们可以对模块的加载行为进行自定义。
// require.config()就写在主模块（main.js）的头部。
require.config({
  paths: {
    "jquery": "jquery.min",
    "underscore": "underscore.min",
    "backbone": "backbone.min"
  }
});

// 如果这些模块在其他目录，比如js/lib目录
require.config({
  paths: {
    "jquery": "lib/jquery.min",
    "underscore": "lib/underscore.min",
    "backbone": "lib/backbone.min"
  }
});

// 另一种则是直接改变基目录（baseUrl）。
require.config({
baseUrl: "js/lib",
  paths: {
  "jquery": "jquery.min",
  "underscore": "underscore.min",
  "backbone": "backbone.min"
  }
});

// 如果某个模块在另一台主机上，也可以直接指定它的网址
require.config({
  paths: {
    "jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min"
  }
});

// 当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。



/**
 * require.js 子模块 的 AMD模块的写法
 * 模块必须采用特定的define()函数来定义
 */

// 模块不依赖于其他的模块
// math.js
define(function () {
  var add = function (x, y) {
    return x + y;
  };
  return {
    add: add
  };
});

// main.js 中使用
require(['math'], function (math) {
  alert(math.add(1, 1));
});

// 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性
// require()函数加载上面这个模块的时候，就会先加载myLib.js文件
define(['myLib'], function (myLib) {
  function foo() {
    myLib.doSomething();
  }
  return {
    foo: foo
  };
});

// 加载非规范的模块
// 模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征
// shim属性，专门用来配置不兼容的模块
// 1.exports值（输出的变量名），表明这个模块外部调用时的名称；
// 2.deps数组，表明该模块的依赖性。
require.config({
  shim: {
    'underscore': {
      exports: '_'
    },
    'backbone': {
      deps: ['underscore', 'jquery'],
      exports: 'Backbone'
    },
    // 异步加载jquery插件
    'jquery.scroll': {
    deps: ['jquery'],
      exports: 'jQuery.fn.scroll'
    }
  }
});

/**
 * require.js还提供一系列插件，实现一些特定的功能。
 */

// domready插件，可以让回调函数在页面DOM结构加载完成后再运行。
require(['domready!'], function(doc) {
  // called once the DOM is ready
});

// text和image插件，则是允许require.js加载文本和图片文件
define(['text!review.txt', 'image!cat.jpg'], function(review, cat) {
  console.log(review);
  document.body.appendChild(cat);
});

```

## CommonJS 规范

- CommonJs 规范

```js
/**
 * 所有代码都运行在模块作用域，不会污染全局作用域。
 * 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
 * 模块加载的顺序，按照其在代码中出现的顺序。
 * 通过require来加载模块；
 * 通过exports和modul.exports来暴露模块中的内容；
 */
var math = require('sum');
var x = 5;
var addX = math.add();
module.exports.x = x;
module.exports.addX = addX;
```

- module 对象

```js
/**
 * 每个模块内部，都有一个module对象，代表当前模块 有如下属性
 * module.id 模块的识别符，通常是带有绝对路径的模块文件名。
 * module.filename 模块的文件名，带有绝对路径。
 * module.loaded 返回一个布尔值，表示模块是否已经完成加载。
 * module.parent 返回一个对象，表示调用该模块的模块。
 * module.children 返回一个数组，表示该模块要用到的其他模块。
 * module.exports 表示模块对外输出的值。
 */
```

- module.exports

```js
/**
 * module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。
 *
 * 为了方便，Node为每个模块提供一个exports变量，指向module.exports。
 * var exports = module.exports;
 */

var invisible = function() {
  console.log('invisible');
};

exports.message = 'hi';

exports.say = function() {
  console.log(message);
};

// 不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系
exports = function(x) {
  console.log(x);
};
```

- require 命令

```js
/**
 * require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。
 */

var foo = require('foo');
//  等同于
var foo = require('foo.js');

/**
 * 所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。
 */
// 删除指定模块的缓存
delete require.cache[moduleName];

// 删除所有模块的缓存
Object.keys(require.cache).forEach(function(key) {
  delete require.cache[key];
});

/**
 * 模块的循环加载
 * 如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。
 */

/**
 * require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。
 * 直接执行的时候（node module.js），require.main属性指向模块本身。
 */
require.main === module; // true
```

- 模块的加载机制

```js
/**
 * CommonJS模块的加载机制是，输入的是被输出的值的拷贝。
 * 也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
 */
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter
};

// main.js
var counter = require('./lib').counter;
var incCounter = require('./lib').incCounter;

console.log(counter); // 3
incCounter();
console.log(counter); // 3
```

- require 的内部处理流程

```js
/**
 * 其实不是一个全局命令，而是指向当前模块的module.require命令
 * 而后者又调用Node的内部命令Module._load。
 * 
    require(): 加载外部模块
    require.resolve()：将模块名解析到一个绝对路径
    require.main：指向主模块
    require.cache：指向所有缓存的模块
    require.extensions：根据文件的后缀名，调用不同的执行函数
 */
Module._load = function(request, parent, isMain) {
  // 1. 检查 Module._cache，是否缓存之中有指定模块
  // 2. 如果缓存之中没有，就创建一个新的Module实例
  // 3. 将它保存到缓存
  // 4. 使用 module.load() 加载指定的模块文件，
  //    读取文件内容之后，使用 module.compile() 执行文件代码
  // 5. 如果加载/解析过程报错，就从缓存删除该模块
  // 6. 返回该模块的 module.exports
};

// Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。
Module.prototype._compile = function(content, filename) {
  // 1. 生成一个require函数，指向module.require
  // 2. 加载其他辅助方法到require
  // 3. 将文件内容放到一个函数之中，该函数可调用 require
  // 4. 执行该函数
};

// 一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。
(function(exports, require, module, __filename, __dirname) {
  // YOUR CODE INJECTED HERE!
});
```

## require 和 ES6 import 的区别

- 区别

```js
/**
 * 主要区别
 * import是ES6标准中的模块化解决方案，require是node中遵循CommonJS规范的模块化解决方案
 *
 * import 不支持动态引入但是已经有提案
 * require支持动态引入，也就是require(${path}/xx.js)
 *
 * import是关键词，require不是
 *
 * import是编译时加载，必须放在模块顶部，在性能上会比后者好一些，
 * require是运行时加载，理论上来说放在哪里都可以
 *
 * import采用的是实时绑定方式，即导入和导出的值都指向同一个内存地址，所以导入值会随着导出值变化。
 * require在导出时是值的拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入
 *
 * import会编译成require/exports来执行
 */
```

- ES6 模块化的优势

```js
/**
 * CommonJS 和 AMD 模块，都只能在运行时确定依赖关系
 * CommonJS 模块就是对象，输入时必须查找对象属性。
 * 导致完全没办法在编译时做“静态优化”。
 */
// CommonJS模块
// 实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），
let { stat, exists, readFile } = require('fs');

// 然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，
// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;

/**
 * ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
 * ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。
 */
// ES6模块
// 实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载
import { stat, exists, readFile } from 'fs';
```

- export 命令

```js
/**
 * export命令用于规定模块的对外接口
 * import命令用于输入其他模块提供的功能(接口)
 */

// 使用export命令输出变量
export var firstName = 'Michael';

// export命令除了输出变量，还可以输出函数或类（class）
export function multiply(x, y) {
  return x * y;
}

// 使用as关键字重命名
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};



/**
 * export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系
*/

// 报错
// 第一种写法直接输出 1，
export 1;

// 报错
// 通过变量m，还是直接输出 1。1只是一个值，不是接口。
var m = 1;
export m;

/**
 * 正确的写法
 * 下面三种写法都是正确的，规定了对外的接口m。
 * 其他脚本可以通过这个接口，取到值1。
 * 它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。
 */


// 写法一
export var m = 1;

// 写法二
var m = 1;
export {m};

// 写法三
var n = 1;
export {n as m};


/**
 * 输出class
  */
// 报错
function f() {}
export f;

// 正确
export function f() {};

// 正确
function f() {}
export {f};


/**
 * export语句输出的接口，与其对应的值是动态绑定关系，
 * 即通过该接口，可以取到模块内部实时的值。
 * 输出变量foo，值为bar，500 毫秒之后变成baz
 * CommonJS 模块输出的是值的缓存，不存在动态更新
 */
export var foo = 'bar';
setTimeout(() => foo = 'baz', 500);


// export命令可以出现在模块的任何位置，只要处于模块顶层就可以。
// 如果处于块级作用域内，就会报错，
// 这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。
function foo() {
  export default 'bar' // SyntaxError
}
foo()
```

- import 命令

```js
/**
 * 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。
 * import命令是编译阶段执行的，在代码运行之前。
 * import语句会执行所加载的模块
 */
import { firstName, lastName, year } from './profile.js';

function setName(element) {
  element.textContent = firstName + ' ' + lastName;
}

/** 使用as关键字，将输入的变量重命名。  */
import { lastName as surname } from './profile.js';

/**
 * import命令输入的变量都是只读的，因为它的本质是输入接口。
 * 不允许在加载模块的脚本里面，改写接口
 */
import { a } from './xxx.js';
a = {}; // Syntax Error : 'a' is read-only;

// 如果a是一个对象，改写a的属性是允许的。
// a的属性可以成功改写，并且其他模块也可以读到改写后的值。
import { a } from './xxx.js';
a.foo = 'hello'; // 合法操作

/**
 * import命令具有提升效果，会提升到整个模块的头部，首先执行。
 * import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，
 * .js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。
 */
foo();
import { foo } from 'my_module';

/**
 * 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构
 * 表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。
 */
 // 报错
import { 'f' + 'oo' } from 'my_module';

// 报错
let module = 'my_module';
import { foo } from module;

// 报错
if (x === 1) {
  import { foo } from 'module1';
} else {
  import { foo } from 'module2';
}

/**
  * import语句会执行所加载的模块
  * 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。
  */
import 'lodash';

// 虽然foo和bar在两个语句中加载
import { foo } from 'my_module';
import { bar } from 'my_module';

// 等同于
import { foo, bar } from 'my_module';
```

- import 之 模块的整体加载

```js
/**
 * 用星号（*）指定一个对象，所有输出值都加载在这个对象上面
 */
import * as circle from './circle';

console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));

/**
 * 模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。
 */
import * as circle from './circle';

// 下面两行都是不允许的
circle.foo = 'hello';
circle.area = function() {};
```

- export default 命令

```js
/**
 * export default命令，为模块指定默认输出。
 */

// 默认输出是一个函数
export default function() {
  console.log('foo');
}

// 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。
// 这时import命令后面，不使用大括号。
import customName from './export-default';
customName(); // 'foo'

/**
 * export default命令其实只是输出一个叫做default的变量
 * 它后面不能跟变量声明语句。
 */
// 正确
export var a = 1;

// 正确
var a = 1;
export default a; // export default a的含义是将变量a的值赋给变量default。

// 错误
export default var a = 1;

// 可以直接将一个值写在export default之后。
// export default命令的本质是将后面的值，赋给default变量
// 指定对外接口为default。
// 正确
export default 42;
// 报错
export 42;

/**
  * 一条import语句中，同时输入默认方法和其他接口
  */
import _, { each, forEach } from 'lodash';

export default function (obj) {
  // ···
}

export function each(obj, iterator, context) {
  // 暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。
}

export { each as forEach };

/**
 * export default也可以用来输出类。
 */
export default class { ... }

// main.js
import MyClass from 'MyClass';
let o = new MyClass();
```

- export 与 import 的复合写法

```js
/**
 * 在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。
 * foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。
 */
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };


/**
 * 模块的接口改名和整体输出
 */
// 接口改名
export { foo as myFoo } from 'my_module';

// 整体输出
export * from 'my_module';

// 默认接口
export { default } from 'foo';

// 具名接口改为默认接口的写法
export { es6 as default } from './someModule';

// 等同于
import { es6 } from './someModule';
export default es6;

// 默认接口也可以改名为具名接口
export { default as es6 } from './someModule';

/**
 * 下面三种import语句，没有对应的复合写法。
 */
import * as someIdentifier from "someModule";
import someIdentifier from "someModule";
import someIdentifier, { namedIdentifier } from "someModule";
```

- 模块的继承

```js
/**
 * circleplus模块，继承了circle模块
 */

// export *，表示再输出circle模块的所有属性和方法。
// export *命令会忽略circle模块的default方法。
export * from 'circle';
export var e = 2.71828182846;
export default function(x) {
  return Math.exp(x);
}

// 以将circle的属性或方法，改名后再输出
// 只输出circle模块的area方法，且将其改名为circleArea。
export { area as circleArea } from 'circle';

// 加载上面模块的写法
import * as math from 'circleplus';
import exp from 'circleplus';
console.log(exp(math.e));
```

- 跨模块常量

```js
/**
 * 常规写法
 */
// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from './constants';
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import { A, B } from './constants';
console.log(A); // 1
console.log(B); // 3

/**
 * 如果要使用的常量非常多，可以建一个专门的constants目录，
 * 将各种常量写在不同的文件里面，保存在该目录下。
 */
// constants/db.js
export const db = {
  url: 'http://my.couchdbserver.local:5984',
  admin_username: 'admin',
  admin_password: 'admin password'
};

// constants/user.js
export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];

// constants/index.js 合并在index.js文件里面 对外转发模块
export {db} from './db';
export {users} from './users';

// script.js 使用的时候，直接加载index.js
import {db, users} from './constants/index';
```

- import()

```js
/**
 * 实现语句的动态加载 引入了import() 还在提案中并未标准化
 * import()返回一个 Promise 对象
 * import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。
 * import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。
 * import()是异步加载 require方法是同步加载。
 * import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。
 */
if (condition) {
  import('moduleA').then(...);
} else {
  import('moduleB').then(...);
}

/**
 * 使用解构赋值的方法
 */
import('./myModule.js')
.then(({export1, export2}) => {
  // ...·
});

/**
 * 获取default输出接口
  */
// 用参数直接获得
import('./myModule.js')
.then(myModule => {
  console.log(myModule.default);
});

// 具名输入的形式
import('./myModule.js')
.then(({default: theDefault}) => {
  console.log(theDefault);
});

// 同时加载多个模块
Promise.all([
  import('./module1.js'),
  import('./module2.js'),
  import('./module3.js'),
])
.then(([module1, module2, module3]) => {
   ···
});

// async 函数之中
async function main() {
  const myModule = await import('./myModule.js');
  const {export1, export2} = await import('./myModule.js');
  const [module1, module2, module3] =
    await Promise.all([
      import('./module1.js'),
      import('./module2.js'),
      import('./module3.js'),
    ]);
}
main();
```

## Module 的加载实现

- 浏览器加载模块

```js
/**
 * 脚本两种异步加载的语法
 * defer与async的区别是：
 * defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行
 * async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染
 * defer是“渲染完再执行”，async是“下载完就执行”
 *
 * 有多个defer脚本，会按照它们在页面出现的顺序加载
 * 多个async脚本是不能保证加载顺序的
 */
<script src="path/to/myModule.js" defer></script>
<script src="path/to/myModule.js" async></script>
```

- 浏览器加载 ES6 模块

```js
/**
 * 加入type="module"属性
 * 于带有type="module"的<script>，都是异步加载
 * 等到整个页面渲染完，再执行模块脚本
 * 有多个<script type="module">，它们会按照在页面出现的顺序依次执行
 * <script>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。
 * <script type="module" src="./foo.js" async></script>
 * 一旦使用了async属性，<script type="module">就不会按照在页面出现的顺序执行
 */
<script type="module" src="./foo.js" />

/** ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。  */
<script type="module">
  import utils from "./utils.js";
</script>
```

- 关于外部模块脚本

```js
/**
 * 代码是在模块作用域,模块内部的顶层变量，外部不可见。
 * 模块脚本自动采用严格模式，不管有没有声明use strict。
 * 模块之中，可以使用import命令加载其他模块 .js后缀不可省略
 * 也可以使用export命令输出对外接口
 * 模块之中，顶层的this关键字返回undefined，而不是指向window。
 * 同一个模块如果加载多次，将只执行一次。
 */

import utils from 'https://example.com/js/utils.js';

const x = 1;

console.log(x === window.x); //false
console.log(this === undefined); // true

/** 侦测当前代码是否在 ES6 模块之中。  */
const isNotModuleScript = this !== undefined;
```

- ES6 模块与 CommonJS 模块的差异

```js
/**
 * CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
 * 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。
 * CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
 * ES6加载的那个模块原始值变了，import加载的值也会跟着变。
 * ES6输出的接口是只读的 不允许重新赋值
 *
 *
 *
 * CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
 * ES6 模块不是对象，它的对外接口只是一种静态定义,在代码静态解析阶段就会生成。
 */
```

- Node 加载

```js
/**
 * ES6 模块和 CommonJS 采用各自的加载方案。
 * 只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。
 * require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。
 * 反过来，.mjs文件里面也不能使用require命令，必须使用import。
 *
 * 安装 Node v8.5.0 或以上版本，要用--experimental-modules参数才能打开该功能。
 * $ node --experimental-modules my-app.mjs
 *
 * 和浏览器一样 Node 的.mjs文件支持 URL 路径
 * import './foo?query=1'; // 加载 ./foo 传入参数 ?query=1
 * 只要参数不同，就会被加载多次，并且保存成不同的缓存。(:、%、#、?)
 * Node 的import命令只支持加载本地模块（file:协议），不支持加载远程模块。
 *
 * Node 的import命令是异步加载，这一点与浏览器的处理方法相同。
 */
```

- 内部变量

```js
/**
 * ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。
 * ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。
 *
 * 某些顶层变量在 ES6 模块之中都是不存在的
 * arguments require module exports __filename __dirname
 *
 */
```

- ES6 模块加载 CommonJS 模块

```js
/**
 * Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，
 * 即等同于export default xxx。
 * module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象{ default: module.exports }
 */
// a.js
module.exports = {
  foo: 'hello',
  bar: 'world'
};

// 等同于
export default {
  foo: 'hello',
  bar: 'world'
};

/** 拿到 CommonJS 模块的module.exports。  */
// 写法一
import baz from './a';
// baz = {foo: 'hello', bar: 'world'};

// 写法二
import { default as baz } from './a';
// baz = {foo: 'hello', bar: 'world'};

// 写法三
// 可以通过baz.default拿到module.exports。
import * as baz from './a';
// baz = {
//   get default() {return module.exports;},
//   get foo() {return this.default.foo}.bind(baz),
//   get bar() {return this.default.bar}.bind(baz)
// }

/** CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。  */
// foo.js
// module.exports将一直是123，而不会变成null。
module.exports = 123;
setTimeout(_ => (module.exports = null));

/** CommonJS 模块是运行时确定输出接口，所以采用import命令加载 CommonJS 模块时，不允许采用下面的写法。  */
// 不正确
import { readFile } from 'fs';

// 正确的写法一
import * as express from 'express';
const app = express.default();

// 正确的写法二
import express from 'express';
const app = express();
```

- CommonJS 模块加载 ES6 模块

```js
/**
 * CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。
 * ES6 模块的所有输出接口，会成为输入对象的属性。
 */

/** 示例一  */
// es.js
export let foo = { bar: 'my-default' };
export { foo as bar };
export function f() {}
export class c {}

// cjs.js
const es_namespace = await import('./es');
// es_namespace = {
//   get foo() {return foo;}
//   get bar() {return foo;}
//   get f() {return f;}
//   get c() {return c;}
// }

/** 示例二  */
// es.mjs
let foo = { bar: 'my-default' };
export default foo;

// cjs.js
const es_namespace = await import('./es.mjs');
// es_namespace = {
//   get default() {
//     ...
//   }
// }
console.log(es_namespace.default);
// { bar:'my-default' }
```

- 循环加载

```js
/**
 * 循环加载是指a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。
 * 
 * CommonJS 模块的加载原理：
 * CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。
 * 以后需要用到这个模块的时候，就会到exports属性上面取值
 * 即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。除非手动清除系统缓存。
 {
  id: '...', // 对象的id属性是模块名
  exports: { ... }, // exports属性是模块输出的各个接口
  loaded: true, // loaded属性是一个布尔值，表示该模块的脚本是否执行完毕
  ...
}
 */
```

- CommonJS 模块的循环加载

```js
/**
 * 一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。
 * CommonJS 输入的是被输出值的拷贝，不是引用
 */

/** a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。  */
exports.done = false;
var b = require('./b.js');
console.log('在 a.js 之中，b.done = %j', b.done);
exports.done = true;
console.log('a.js 执行完毕');

/**  b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，
 * 因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 即exports.done = false;
 * 对于b.js来说，它从a.js只输入一个变量done，值为false。
 * 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。
 * a.js接着往下执行，直到执行完毕。
 */
exports.done = false;
var a = require('./a.js');
console.log('在 b.js 之中，a.done = %j', a.done);
exports.done = true;
console.log('b.js 执行完毕');

/** 在main.js中执行  */

var a = require('./a.js');
var b = require('./b.js');
console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);

// 输出结果
// 在 b.js 之中，a.done = false
// b.js 执行完毕
// 在 a.js 之中，b.done = true
// a.js 执行完毕
// 在 main.js 之中, a.done=true, b.done=true

/**
 * CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。
 * require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。
 */

var a = require('a'); // 安全的写法
var foo = require('a').foo; // 危险的写法
```

- ES6 模块的循环加载

```js
/**
 * ES6 模块是动态引用
 * 而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
 */

// a.mjs
import { bar } from './b';
console.log('a.mjs');
console.log(bar);
export let foo = 'foo';

// b.mjs
import { foo } from './a';
console.log('b.mjs');
console.log(foo);
export let bar = 'bar';

/** 执行a.mjs，结果如下。
 * 执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。
 * 执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。
 * 执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。
 */

$ node --experimental-modules a.mjs
b.mjs
ReferenceError: foo is not defined

/**
 * 这可以通过将foo写成函数来解决报错问题
 * 因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，
 */
// a.mjs
import {bar} from './b';
console.log('a.mjs');
console.log(bar());
function foo() { return 'foo' }
export {foo};

// b.mjs
import {foo} from './a';
console.log('b.mjs');
console.log(foo());
function bar() { return 'bar' }
export {bar};

// $ node --experimental-modules a.mjs
// b.mjs
// foo
// a.mjs
// bar
```

- ES6 模块的转码

```js
/**
 * 将 ES6 模块转为 CommonJS 模块或 AMD 模块的写法
 * Babel 可以用来转码
 * ES6 module transpiler
 * SystemJS可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。它在后台调用的是 Google 的 Traceur 转码器。
 * System.import使用异步加载，返回一个 Promise 对象，
 */

/* 使用时，先在网页内载入system.js文件。 */
<script src="system.js"></script>

/* 然后，使用System.import方法加载模块文件。 */
<script>
  System.import('./app.js');
</script>

/* System.import使用异步加载，返回一个 Promise 对象， */
export class q {
  constructor() {
    this.es6 = 'hello';
  }
}

<script>
System.import('app/es6-file').then(function(m) {
  console.log(new m.q().es6); // hello
});
</script>
```

## 关于 seajs 的使用(CMD 规范的实现库)

- CMD 规范(简单使用案例)

```js
/**
 * 通过 exports 暴露接口。这意味着不需要命名空间了，更不需要全局变量。这是一种彻底的命名冲突解决方案。
 * 通过 require 引入依赖。这可以让依赖内置，开发者只需关心当前模块的依赖，其他事情 Sea.js 都会自动处理好。
 * 跨环境共享模块。CMD 模块定义规范与 Node.js 的模块规范非常相近。通过 Sea.js 的 Node.js 版本，可以很方便实现模块的跨服务器和浏览器共享。
 */

// 在 hello.html 页尾，通过 script 引入 sea.js 后，有一段配置代码：
// seajs 的简单配置
seajs.config({
  base: "../sea-modules/",
  alias: {
    "jquery": "jquery/jquery/1.10.1/jquery.js"
  }
})

// 加载入口模块
seajs.use("../static/hello/src/main")

// spinning.js 和 main.js，遵循统一的写法
// 所有模块都通过 define 来定义
define(function(require, exports, module) {

  // 通过 require 引入依赖
  var $ = require('jquery');
  var Spinning = require('./spinning');

  // 通过 exports 对外提供接口
  exports.doSomething = ...

  // 或者通过 module.exports 提供整个接口
  module.exports = ...

});

// 加载多个模块，在加载完成时，执行回调
seajs.use(['./a', './b'], function(a, b) {
  a.doSomething();
  b.doSomething();
});

// require.async 用来在模块内部异步加载一个或多个模块。
define(function(require) {

  // 异步加载一个模块，在加载完成时，执行回调
  require.async('./b', function(b) {
    b.doSomething();
  });

  // 异步加载多个模块，在加载完成时，执行回调
  require.async(['./c', './d'], function(c, d) {
    c.doSomething();
    d.doSomething();
  });

});

```

- 让 Node 环境可以加载执行 CMD 模块

```js
/** a.js 就可以是一个用 define 包裹起来的 CMD 模块
 * 没有用到浏览器环境下的特有属性

 * Node.js 里，require 是懒加载 + 懒执行的。在 Sea.js 里是提前加载好 + 懒执行。
 * Sea.js 里，require(id) 中的 id 必须是字符串直接量。Node.js 里没这个限制。
 */
require('seajs');
var a = require('./a');
```

- CommonJS 的模块需要跑在浏览器端时，通过简单封装就行

```js
/**
 *  a.js 没有利用到服务器特有属性和模块，比如 __dirname、process
 * RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念
 * RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。
 */
define(function(require, exports, module) {
  // a.js 原来的代码
});
```

## 参考链接

[AMD 的 WIKI 中文版](<https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%8())

[CMD - seajs 中文文档](https://seajs.github.io/seajs/docs/)
