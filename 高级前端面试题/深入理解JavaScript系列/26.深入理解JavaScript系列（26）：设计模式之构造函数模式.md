# 深入理解 JavaScript 系列（26）：设计模式之构造函数模式

## 基本用法

```js
/**
 * 在构造函数内部，this关键字引用的是新创建的对象。
 * 构造函数通常是认为用来实现实例的
 */
function Car(model, year, miles) {
  this.model = model;
  this.year = year;
  this.miles = miles;
}

/*
注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype
主要是用来避免重写定义原型prototype对象
*/
Car.prototype.output = function() {
  return this.model + '走了' + this.miles + '公里';
};

var tom = new Car('大叔', 2009, 20000);
var dudu = new Car('Dudu', 2010, 5000);

console.log(tom.output());
console.log(dudu.output());

/**
 * 如果不适用new直接调用函数的话，this指向的是全局对象window
 */
function Car(model, year, miles) {
  this.model = model;
  this.year = year;
  this.miles = miles;
  // 自定义一个output输出内容
  this.output = function() {
    return this.model + '走了' + this.miles + '公里';
  };
}

//方法1：作为函数调用
Car('大叔', 2009, 20000); //添加到window对象上
console.log(window.output());

//方法2：在另外一个对象的作用域内调用
var o = new Object();
Car.call(o, 'Dudu', 2010, 5000);
console.log(o.output());

//作为函数调用
var tom = Car('大叔', 2009, 20000);
console.log(typeof tom); // "undefined"
console.log(window.output()); // "大叔走了20000公里"

//使用new 关键字
var tom = new Car('大叔', 2009, 20000);
console.log(typeof tom); // "object"
console.log(tom.output()); // "大叔走了20000公里"
```

## 强制使用 new

```js
function Car(model, year, miles) {
  if (!(this instanceof Car)) {
    return new Car(model, year, miles);
  }
  this.model = model;
  this.year = year;
  this.miles = miles;
  this.output = function() {
    return this.model + '走了' + this.miles + '公里';
  };
}

var tom = new Car('大叔', 2009, 20000);
var dudu = Car('Dudu', 2010, 5000);

console.log(typeof tom); // "object"
console.log(tom.output()); // "大叔走了20000公里"
console.log(typeof dudu); // "object"
console.log(dudu.output()); // "Dudu走了5000公里"
```

## 原始包装函数

```js
// 使用原始包装函数
var s = new String('my string');
var n = new Number(101);
var b = new Boolean(true);

// 推荐这种
var s = 'my string';
var n = 101;
var b = true;

/**
 * 推荐，只有在想保留数值状态的时候使用这些包装函数，
 */
// 原始string
var greet = 'Hello there';
// 使用split()方法分割
greet.split(' ')[0]; // "Hello"
// 给原始类型添加新属性不会报错
greet.smile = true;
// 但没法获取这个值（18章ECMAScript实现里我们讲了为什么）
console.log(typeof greet.smile); // "undefined"

// 原始string
var greet = new String('Hello there');
// 使用split()方法分割
greet.split(' ')[0]; // "Hello"
// 给包装函数类型添加新属性不会报错
greet.smile = true;
// 可以正常访问新属性
console.log(typeof greet.smile); // "boolean"
```
