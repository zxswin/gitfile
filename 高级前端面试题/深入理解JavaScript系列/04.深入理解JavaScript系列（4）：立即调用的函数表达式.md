# 深入理解 JavaScript 系列（4）：立即调用的函数表达式

## 函数自执行的简单示例

- 后面加个括号并不意味着就可以执行了

```js
/**
 * 解析器解析全局的function或者function内部function关键字的时候，默认是认为function声明
 * 如果你不显示告诉编译器，它默认会声明成一个缺少名字的function,因为function声明需要一个名字。
 */

// 因为想下面第一个声明的function可以在后面加一个括弧()就可以自己执行了，比如foo()，
// 因为foo仅仅是function() { /* code */ }这个表达式的一个引用

var foo = function(){ /* code */ }

// ...是不是意味着后面加个括弧都可以自动执行？

function(){ /* code */ }(); // SyntaxError: Unexpected token (
//
```

- ()也可以是分组操作符

```js
/**
 * 在一个表达式后面加上括号()，该表达式会立即执行
 * 在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符
 */

// 下面这个function在语法上是没问题的，但是依然只是一个语句
// 加上括号()以后依然会报错，因为分组操作符需要包含表达式

function foo(){ /* code */ }(); // SyntaxError: Unexpected token )

// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出
// 但是foo函数依然不会执行
function foo(){ /* code */ }( 1 );

// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式：
function foo(){ /* code */ }

( 1 );
```

- 自执行函数表达式

```js
/**
 * 用大括弧将代码的代码全部括住,JavaScript里括弧()里面不能包含语句
 * 解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明
 */

// 下面2个括弧()都会立即执行

(function() {
  /* code */
})(); // 推荐使用这个
(function() {
  /* code */
})(); // 但是这个也是可以用的

// 由于括弧()和JS的&&，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的
// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了
// 不过，请注意下一章节的内容解释

var i = (function() {
  return 10;
})();
true &&
  (function() {
    /* code */
  })();
0,
  (function() {
    /* code */
  })();

// 如果你不在意返回值，或者不怕难以阅读
// 你甚至可以在function前面加一元操作符号

!(function() {
  /* code */
})();
~(function() {
  /* code */
})();
-(function() {
  /* code */
})();
+(function() {
  /* code */
})();

// 还有一个情况，使用new关键字,也可以用，但我不确定它的效率
// http://twitter.com/kuvos/status/18209252090847232

new (function() {
  /* code */
})();
new (function() {
  /* code */
})(); // 如果需要传递参数，只需要加上括弧()
```

- 用闭包保存状态

```js
/**
 * 闭包lock住的传入参数，自执行函数表达式可以有效地保存状态
 * 但闭包内部的lockedInIndex值是没有改变，因为他已经执行完毕了
 */

// 这个代码是错误的，因为变量i从来就没背locked住
// 相反，当循环执行以后，我们在点击的时候i才获得数值
// 因为这个时候i操真正获得值
// 所以说无论点击那个连接，最终显示的都是I am link #10（如果有10个a元素的话）

var elems = document.getElementsByTagName('a');

for (var i = 0; i < elems.length; i++) {
  elems[i].addEventListener(
    'click',
    function(e) {
      e.preventDefault();
      alert('I am link #' + i);
    },
    'false'
  );
}

// 这个是可以用的，因为他在自执行函数表达式闭包内部
// i的值作为locked的索引存在，在循环执行结束以后，尽管最后i的值变成了a元素总数（例如10）
// 但闭包内部的lockedInIndex值是没有改变，因为他已经执行完毕了
// 所以当点击连接的时候，结果是正确的

var elems = document.getElementsByTagName('a');

for (var i = 0; i < elems.length; i++) {
  (function(lockedInIndex) {
    elems[i].addEventListener(
      'click',
      function(e) {
        e.preventDefault();
        alert('I am link #' + lockedInIndex);
      },
      'false'
    );
  })(i);
}

// 你也可以像下面这样应用，在处理函数那里使用自执行函数表达式
// 而不是在addEventListener外部
// 但是相对来说，上面的代码更具可读性

var elems = document.getElementsByTagName('a');

for (var i = 0; i < elems.length; i++) {
  elems[i].addEventListener(
    'click',
    (function(lockedInIndex) {
      return function(e) {
        e.preventDefault();
        alert('I am link #' + lockedInIndex);
      };
    })(i),
    'false'
  );
}
```
