# 深入理解 JavaScript 系列（16）：闭包（Closures）

## 一些定义和概念

- 函数式参数 与 高阶函数

```js
/**
 * 函数式参数（“Funarg”） —— 是指值为函数的参数。
 * 接受函数式参数的函数称为高阶函数
 */
function exampleFunc(funArg) {
  funArg();
}

exampleFunc(function() {
  alert('funArg');
});
```

- 带函数值的函数

```js
/**
 * 这类以函数为返回值的函数称为带函数值的函数
 * 在ECMAScript中，所有的函数都是第一类对象(第一类函数)。
 */
(function functionValued() {
  return function() {
    alert('returned function is called');
  };
})()();
```

- 自应用函数

```js
/**
 * 接受自己作为参数的函数，称为自应用函数
 */
function selfApplicative(funArg) {

  if (funArg && funArg === selfApplicative) {
    alert('self-applicative');
    return;
  }

  selfApplicative(selfApplicative);

})();
```

- 自复制函数

```js
/**
 * 以自己为返回值的函数称为自复制函数
 * 自复制函数的运用：接受集合的一个项作为参数来接受从而代替接受集合本身。
 * 即本来需要接收集合的通过自复制函数可以通过传递一个参数注册并且支持链式调用
 */
(function selfReplicative() {
  return selfReplicative;
})();

// 自复制函数的声明
function modes(mode) {
  registerMode(mode); // 注册一个mode
  return modes; // 返回函数自身
}

// 用法，modes链式调用
modes('roster')('accounts')('groups');

//有点类似：jQueryObject.addClass("a").toggle().removClass("b")
```

## ECMAScript 闭包的实现

- ECMAScript 只使用静态（词法）作用域

```js
/**
 * ECMAScript只使用静态（词法）作用域
 */
var x = 10;

function foo() {
  alert(x);
}

(function(funArg) {
  var x = 20;

  // 变量"x"在(lexical)上下文中静态保存的，在该函数创建的时候就保存了
  funArg(); // 10, 而不是20
})(foo);

/**
 * 函数的[[Scope]]属性，对应有一个非标准的 __parent__属性
 */
var global = this;
var x = 10;

var foo = (function() {
  var y = 20;

  return function() {
    alert(y);
  };
})();

foo(); // 20
alert(foo.__parent__.y); // 20

foo.__parent__.y = 30;
foo(); // 30

// 可以通过作用域链移动到顶部
alert(foo.__parent__.__parent__ === global); // true
alert(foo.__parent__.__parent__.x); // 10
```

- 所有对象都引用一个[[Scope]]

```js
/**
 * 所有对象都引用一个[[Scope]]
 * 在同一个父函数中某个闭包对其中[[Scope]]的变量做修改会影响到其他闭包对其变量的读取
 */
var firstClosure;
var secondClosure;

function foo() {
  var x = 1;

  firstClosure = function() {
    return ++x;
  };
  secondClosure = function() {
    return --x;
  };

  x = 2; // 影响 AO["x"], 在2个闭包公有的[[Scope]]中

  alert(firstClosure()); // 3, 通过第一个闭包的[[Scope]]
}

foo();

alert(firstClosure()); // 4
alert(secondClosure()); // 3

/**
 * 经典闭包使用案例步骤解析
 * 函数“_helper”创建出来之后，通过传入参数“k”激活。其返回值也是个函数，该函数保存在对应的数组元素中
 * 每次“_helper”都会创建一个新的变量对象，其中含有参数“x”，“x”的值就是传递进来的“k”的值。
data[0].[[Scope]] === [
  ... // 其它变量对象
  父级上下文中的活动对象AO: {data: [...], k: 3},
  _helper上下文中的活动对象AO: {x: 0}
];

data[1].[[Scope]] === [
  ... // 其它变量对象
  父级上下文中的活动对象AO: {data: [...], k: 3},
  _helper上下文中的活动对象AO: {x: 1}
];

data[2].[[Scope]] === [
  ... // 其它变量对象
  父级上下文中的活动对象AO: {data: [...], k: 3},
  _helper上下文中的活动对象AO: {x: 2}
];
 */
var data = [];

for (var k = 0; k < 3; k++) {
  data[k] = (function _helper(x) {
    return function() {
      alert(x);
    };
  })(k); // 传入"k"值
}

// 现在结果是正确的了
data[0](); // 0
data[1](); // 1
data[2](); // 2

/** 另外一种获取正确K值的方法  */
var data = [];

for (var k = 0; k < 3; k++) {
  (data[k] = function() {
    alert(arguments.callee.x);
  }).x = k; // 将k作为函数的一个属性
}

// 结果也是对的
data[0](); // 0
data[1](); // 1
data[2](); // 2
```

## 闭包用法实战

```js
/**
 * 理论上所有的函数都是闭包
 * 从实践角度：以下函数才算是闭包：
 * 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
 * 在代码中引用了自由变量
 */

/** 函数式参数的使用  */
someCollection.find(function(element) {
  return element.someProperty == 'searchCondition';
});

/** 延迟调用  */
var a = 10;
setTimeout(function() {
  alert(a); // 10, after one second
}, 1000);

/** 回调函数  */
//...
var x = 10;
// only for example
xmlHttpRequestObject.onreadystatechange = function() {
  // 当数据就绪的时候，才会调用;
  // 这里，不论是在哪个上下文中创建
  // 此时变量“x”的值已经存在了
  alert(x); // 10
};
//...

/** 创建封闭的作用域  */
var foo = {};

// 初始化
(function(object) {
  var x = 10;

  object.getX = function _getX() {
    return x;
  };
})(foo);

alert(foo.getX()); // 获得闭包 "x" – 10
```
