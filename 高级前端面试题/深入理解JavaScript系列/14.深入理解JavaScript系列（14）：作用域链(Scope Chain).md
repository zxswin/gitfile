# 深入理解 JavaScript 系列（14）：作用域链(Scope Chain)

- 定义

```js
/**
 * 变量对象
 * 一个执行上下文 的数据（变量、函数声明和函数的形参）作为属性存储在变量对象中
 * 变量对象在每次进入上下文时创建，并填入初始值，值的更新出现在代码执行阶段。

 * 函数作用域链
 * 函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。
 */

 activeExecutionContext = {
    VO: {...}, // or AO
    this: thisValue,
    Scope: [ // Scope chain
      // 所有变量对象的列表
      // for identifiers lookup
    ]
};
```

- 函数的生命周期

```js
/**
 * 函数的的生命周期分为创建和激活阶段（调用时）

 * 函数创建：
 * 函数内部的[[scope]]属性
 * [[scope]]是所有父变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。
 * [[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁。
 * 函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中。
 * [[scope]]是函数的一个属性而不是上下文。

 * 函数激活(函数执行)
 * 活动对象是作用域数组的第一个对象，即添加到作用域的前端。
 * Scope = [AO].concat([[Scope]]);
 * 作用域中变量对象的连续查找，从最深的上下文开始，绕过作用域链直到最上层。
 */

/** 一个复杂的例子  */
var x = 10;

function foo() {
  var y = 20;

  function bar() {
    var z = 30;
    alert(x + y + z);
  }

  bar();
}

foo(); // 60


/**  全局上下文的变量对象是： */
globalContext.VO === Global = {
  x: 10
  foo: <reference to function>
};


/** 在“foo”创建时，“foo”的[[scope]]属性是：  */
foo.[[Scope]] = [
  globalContext.VO
];

/** 在“foo”激活时（进入上下文），“foo”上下文的活动对象是：  */
fooContext.AO = {
  y: 20,
  bar: <reference to function>
};

/** “foo”上下文的作用域链为： */
fooContext.Scope = fooContext.AO + foo.[[Scope]] // i.e.:

fooContext.Scope = [
  fooContext.AO,
  globalContext.VO
];

/** 内部函数“bar”创建时，其[[scope]]为：  */
bar.[[Scope]] = [
  fooContext.AO,
  globalContext.VO
];

/** 在“bar”激活时，“bar”上下文的活动对象为：  */
barContext.AO = {
  z: 30
};

/** “bar”上下文的作用域链为：  */
barContext.Scope = barContext.AO + bar.[[Scope]] // i.e.:

barContext.Scope = [
  barContext.AO,
  fooContext.AO,
  globalContext.VO
];

/** 对“x”、“y”、“z”的标识符解析如下：  */
- "x"
-- barContext.AO // not found
-- fooContext.AO // not found
-- globalContext.VO // found - 10

- "y"
-- barContext.AO // not found
-- fooContext.AO // found - 20

- "z"
-- barContext.AO // found - 30
```

- 通过构造函数创建的函数的[[scope]] Function()

```js
/**
 * 通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。
 */
var x = 10;

function foo() {
  var y = 20;

  function barFD() {
    // 函数声明
    alert(x);
    alert(y);
  }

  var barFE = function() {
    // 函数表达式
    alert(x);
    alert(y);
  };

  var barFn = Function('alert(x); alert(y);');

  barFD(); // 10, 20
  barFE(); // 10, 20
  barFn(); // 10, "y" is not defined
}

foo();
```

- 二维作用域链查找

```js
/**
 * 如果一个属性在对象中没有直接找到，查询将在原型链中继续。即常说的二维链查找。
 * （1）作用域链环节；（2）每个作用域链－－深入到原型链环节。
 */
function foo() {
  alert(x);
}

Object.prototype.x = 10;

foo(); // 10
```

- 代码执行时对作用域链的影响

```js
/**
 * 代码执行阶段有两个声明能修改作用域链
 * with声明添加到作用域链的最前端
 */

/* 作用域链修改成这样：

Scope = foo + AO|VO + [[Scope]] */
var foo = { x: 10, y: 20 };

with (foo) {
  alert(x); // 10
  alert(y); // 20
}
```
