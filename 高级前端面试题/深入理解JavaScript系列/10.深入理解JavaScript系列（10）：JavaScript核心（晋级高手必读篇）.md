# 深入理解 JavaScript 系列（10）：JavaScript 核心（晋级高手必读篇）

## 对象 Object

- 原型链

```js
/**
 * 一个Object的prototype是一个内部的[[prototype]]属性的引用。
 * 使用__<内部属性名>__ 下划线来代替双括号，例如__proto__

 * 如果一个对象的prototype没有显示的声明过或定义过，那么__prototype__的默认值就是object.prototype, 
 * object.prototype也会有一个__prototype__, 这个就是原型链的终点了，被设置为null。
 */

var a = {
  x: 10,
  calculate: function(z) {
    return this.x + this.y + z;
  }
};

var b = {
  y: 20,
  __proto__: a
};

var c = {
  y: 30,
  __proto__: a
};

// 调用继承过来的方法
b.calculate(30); // 60
c.calculate(40); // 80
```

- 构造函数(Constructor)

```js
/**
 * 除了创建对象，构造函数(constructor) 还做了另一件有用的事情—自动为创建的新对象设置了原型对象(prototype object)
 * 原型对象存放于 ConstructorFunction.prototype 属性中。
 */

 // 构造函数
function Foo(y) {
  // 构造函数将会以特定模式创建对象：被创建的对象都会有"y"属性
  this.y = y;
}

// "Foo.prototype"存放了新建对象的原型引用
// 所以我们可以将之用于定义继承和共享属性或方法
// 所以，和上例一样，我们有了如下代码：

// 继承属性"x"
Foo.prototype.x = 10;

// 继承方法"calculate"
Foo.prototype.calculate = function (z) {
  return this.x + this.y + z;
};

// 使用foo模式创建 "b" and "c"
var b = new Foo(20);
var c = new Foo(30);

// 调用继承的方法
b.calculate(30); // 60
c.calculate(40); // 80

// 让我们看看是否使用了预期的属性

console.log(

  b.__proto__ === Foo.prototype, // true
  c.__proto__ === Foo.prototype, // true

  // "Foo.prototype"自动创建了一个特殊的属性"constructor"
  // 指向a的构造函数本身
  // 实例"b"和"c"可以通过授权找到它并用以检测自己的构造函数

  b.constructor === Foo, // true
  c.constructor === Foo, // true
  Foo.prototype.constructor === Foo // true

  b.calculate === b.__proto__.calculate, // true
  b.__proto__.calculate === Foo.prototype.calculate // true

);
```

## 执行上下文栈(Execution Context Stack)

- 执行上下文

```js
/**
 * 调用相同的function，每次都会产生3个不同的上下文
 *（包含不同的状态，例如参数bar的值）
 */
function foo(bar) {}

foo(10);
foo(20);
foo(30);
```

- 上下文栈

```js
/**
 * 激活其它上下文的某个上下文被称为 调用者(caller)
 * 被激活的上下文被称为被调用者(callee)

 * 当一个caller激活了一个callee，那么这个caller就会暂停它自身的执行，然后将控制权交给这个callee. 于是这个callee被放入堆栈，
 * 当这个callee的上下文结束之后，会把控制权再次交给它的caller，然后caller会在刚才暂停的地方继续执行。
 * 一个callee可以用返回（return）或者抛出异常（exception）来结束自身的上下文。

 * 一个执行上下文堆栈[execution context (EC) stack]。堆栈的顶部就是处于激活状态的上下文。
 */
```

- 上下文结构

```js
/**
 * 变量对象(variable object)，this指针(this value)，作用域链(scope chain)
 * 行上下文根据具体实现还可以具有任意额外属性

 * 变量对象(Variable Object)
 * 用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。

 * 变量对象被表示为活动对象(activation object)。
 * 当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。
 * 包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。
 * 函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象arguments 。
 */
function foo(x, y) {
  var z = 30;
  function bar() {} // 函数声明
  (function baz() {}); // 函数表达式
}

foo(10, 20);
```

- 作用域链(Scope Chains)

```js
/**
 * 如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层（沿着作用域链向上找）
 * 自由变量[free variable]:当前函数作用域中没有出现的变量

 * 作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量VO和活动对象（activation object）。
 * 执行期间，动态加入作用域链中的—例如with或者catch语句(临时作用域对象,导致作用域变更)
 */
var x = 10;

(function foo() {
  var y = 20;
  (function bar() {
    var z = 30;
    // "x"和"y"是自由变量
    // 会在作用域链的下一个对象中找到（函数”bar”的互动对象之后）
    console.log(x + y + z);
  })();
})();

/**
 * 父级变量是被存在函数的[[Scope]]属性中的
 * 作用域链 = 活动对象 + [[Scope]]

 * 在代码执行过程中，如果使用with或者catch语句就会改变作用域链。
 * 作用域链会从两个维度来搜寻。
    首先在原本的作用域链
    每一个链接点的作用域的链（如果这个链接点是有prototype的话）
 */
Object.prototype.x = 10;

var w = 20;
var y = 30;

// 在SpiderMonkey全局对象里
// 例如，全局上下文的变量对象是从"Object.prototype"继承到的
// 所以我们可以得到“没有声明的全局变量”
// 因为可以从原型链中获取

console.log(x); // 10

(function foo() {
  // "foo" 是局部变量
  var w = 40;
  var x = 100;

  // "x" 可以从"Object.prototype"得到，注意值是10哦
  // 因为{z: 50}是从它那里继承的

  with ({ z: 50 }) {
    console.log(w, x, y, z); // 40, 10, 30, 50
  }

  // 在"with"对象从作用域链删除之后
  // x又可以从foo的上下文中得到了，注意这次值又回到了100哦
  // "w" 也是局部变量
  console.log(x, w); // 100, 40

  // 在浏览器里
  // 我们可以通过如下语句来得到全局的w值
  console.log(window.w); // 20
})();
```

## 闭包(Closures)

- 关于闭包

```js
/**
 * 闭包的概念
 * 闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。

  
 * 函数在被创建时保存外部作用域，是因为这个 被保存的作用域链(saved scope chain) 将会在未来的函数调用中用于变量查找。
 * 这种形式的作用域称为静态作用域[static/lexical scope]。
 * EMCAScript不使用动态作用域。
 */
function foo() {
  var x = 10;
  return function bar() {
    console.log(x);
  };
}

// "foo"返回的也是一个function
// 并且这个返回的function可以随意使用内部的变量x

var returnedFunction = foo();

// 全局变量 "x"
var x = 20;

// 支持返回的function
returnedFunction(); // 结果是10而不是20

/**
 * 使用静态作用域是闭包的一个强制性要求
 */
// 全局变量 "x"
var x = 10;

// 全局function
function foo() {
  console.log(x);
}

(function(funArg) {
  // 局部变量 "x"
  var x = 20;

  // 这不会有歧义
  // 因为我们使用"foo"函数的[[Scope]]里保存的全局变量"x",
  // 并不是caller作用域的"x"

  funArg(); // 10, 而不是20
})(foo); // 将foo作为一个"funarg"传递下去
```

## This 指针

```js
/**
 * this适合执行的上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象[context object](激活执行上下文的上下文)。
 * this是执行上下文环境的一个属性，而不是某个变量对象的属性

 * 当你在代码中使用了this,这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。
 * this的值只取决中进入上下文时的情况。

 * this会由每一次caller提供,caller是通过调用表达式[call expression]产生的（也就是这个函数如何被激活调用的）
 * 不同的caller引起this的不同。
 */

// "foo"函数里的alert没有改变
// 但每次激活调用的时候this是不同的

function foo() {
  alert(this);
}

// caller 激活 "foo"这个callee，
// 并且提供"this"给这个 callee

foo(); // 全局对象
foo.prototype.constructor(); // foo.prototype

var bar = {
  baz: foo
};

bar.baz(); // bar

bar.baz(); // also bar
(bar.baz = bar.baz)(); // 这是一个全局对象
(bar.baz, bar.baz)(); // 也是全局对象
(false || bar.baz)(); // 也是全局对象

var otherFoo = bar.baz;
otherFoo(); // 还是全局对象
```
