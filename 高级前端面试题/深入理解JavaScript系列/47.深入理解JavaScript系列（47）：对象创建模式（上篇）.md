# 深入理解 JavaScript 系列（47）：对象创建模式（上篇）

## 模式 1：命名空间（namespace）

```js
/**
 * 命名空间可以减少全局命名所需的数量，避免命名冲突或过度
 */
// 不安全，可能会覆盖已有的MYAPP对象
var MYAPP = {};
// 还好
if (typeof MYAPP === 'undefined') {
  var MYAPP = {};
}
// 更简洁的方式
var MYAPP = MYAPP || {};

//定义通用方法
MYAPP.namespace = function(ns_string) {
  var parts = ns_string.split('.'),
    parent = MYAPP,
    i;

  // 默认如果第一个节点是MYAPP的话，就忽略掉，比如MYAPP.ModuleA
  if (parts[0] === 'MYAPP') {
    parts = parts.slice(1);
  }

  for (i = 0; i < parts.length; i += 1) {
    // 如果属性不存在，就创建
    if (typeof parent[parts[i]] === 'undefined') {
      parent[parts[i]] = {};
    }
    parent = parent[parts[i]];
  }
  return parent;
};

// 调用代码，非常简单：

// 通过namespace以后，可以将返回值赋给一个局部变量
var module2 = MYAPP.namespace('MYAPP.modules.module2');
console.log(module2 === MYAPP.modules.module2); // true

// 跳过MYAPP
MYAPP.namespace('modules.module51');

// 非常长的名字
MYAPP.namespace('once.upon.a.time.there.was.this.long.nested.property');
```

## 模式 2：定义依赖

```js
/**
 * 一个模块或者函数可能要引用第三方的一些模块或者工具，这时候最好将这些依赖模块在刚开始的时候就定义好
 */
var myFunction = function() {
  // 依赖模块
  var event = YAHOO.util.Event,
    dom = YAHOO.util.dom;

  // 其它函数后面的代码里使用局部变量event和dom
};
```

## 模式 3：私有属性和私有方法

```js
/**
 * JavaScript本书不提供特定的语法来支持私有属性和私有方法，但是我们可以通过闭包来实现
 */
function Gadget() {
  // 私有对象
  var name = 'iPod';
  // 公有函数
  this.getName = function() {
    return name;
  };
}
var toy = new Gadget();

// name未定义，是私有的
console.log(toy.name); // undefined

// 公有方法访问name
console.log(toy.getName()); // "iPod"

var myobj; // 通过自执行函数给myobj赋值
(function() {
  // 自由对象
  var name = 'my, oh my';

  // 实现了公有部分，所以没有var
  myobj = {
    // 授权方法
    getName: function() {
      return name;
    }
  };
})();
```

## 模式 4：Revelation 模式

```js
/**
 * 在外部先声明一个变量，然后在内部给变量赋值公有方法
 */
var myarray;

(function() {
  var astr = '[object Array]',
    toString = Object.prototype.toString;

  function isArray(a) {
    return toString.call(a) === astr;
  }

  function indexOf(haystack, needle) {
    var i = 0,
      max = haystack.length;
    for (; i < max; i += 1) {
      if (haystack[i] === needle) {
        return i;
      }
    }
    return -1;
  }

  //通过赋值的方式，将上面所有的细节都隐藏了
  myarray = {
    isArray: isArray,
    indexOf: indexOf,
    inArray: indexOf
  };
})();

//测试代码
console.log(myarray.isArray([1, 2])); // true
console.log(myarray.isArray({ 0: 1 })); // false
console.log(myarray.indexOf(['a', 'b', 'z'], 'z')); // 2
console.log(myarray.inArray(['a', 'b', 'z'], 'z')); // 2

myarray.indexOf = null;
console.log(myarray.inArray(['a', 'b', 'z'], 'z')); // 2
```

## 模式 5：链模式

```js
/**
 * 链模式你可以连续调用一个对象的方法，比如obj.add(1).remove(2).delete(4).add(2)这样的形式，其实现思路非常简单，就是将this原样返回
 */
var obj = {
  value: 1,
  increment: function() {
    this.value += 1;
    return this;
  },
  add: function(v) {
    this.value += v;
    return this;
  },
  shout: function() {
    console.log(this.value);
  }
};

// 链方法调用
obj
  .increment()
  .add(3)
  .shout(); // 5

// 也可以单独一个一个调用
obj.increment();
obj.add(3);
obj.shout();
```
