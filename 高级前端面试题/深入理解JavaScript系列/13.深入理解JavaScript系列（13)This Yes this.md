# 深入理解 JavaScript 系列（13）：This? Yes,this!

- this 是执行上下文中的一个属性

```js
/**
 * this与上下文中可执行代码的类型有直接关系，this值在进入上下文时确定，并且在上下文运行期间永久不变。
 * this是执行上下文中的一个属性：
 */
activeExecutionContext = {
  VO: {...},
  this: thisValue
};
```

- 全局代码中的 this

```js
/**
 * 在全局代码中，this始终是全局对象本身
 */
// 显示定义全局对象的属性
this.a = 10; // global.a = 10
alert(a); // 10

// 通过赋值给一个无标示符隐式
b = 20;
alert(this.b); // 20

// 也是通过变量声明隐式声明的
// 因为全局上下文的变量对象是全局对象自身
var c = 30;
alert(this.c); // 30
```

- 函数代码中的 this

```js
/**
 * 通常的函数调用中,this取决于调用函数的方式。
 * this是由激活上下文代码的调用者来提供的，即调用函数的父上下文(parent context )
 *
 * 引用类型（Reference type）
 * 使用伪代码表示的引用类型
    var valueOfReferenceType = {
      base: <base object>,
      propertyName: <property name>
    };
  * 引用类型的值只有两种情况：
    1.当我们处理一个标示符时
    2.或一个属性访问器

  * 标识符
  * 标示符总数返回一个引用类型的值
  * 标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名
  *
  * 引用类型的值与函数上下文中的this值的关联
  * 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。
  * 如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object）
  * 在其他情况下（与引用类型不同的任何其它属性），这个值为null。
  * 当this的值为null的时候，其值会被隐式转换为全局对象(ES5已经不强迫转换成全局变量了，而是赋值为undefined。)
 */

/** 定义标识符  */
var foo = 10;
function bar() {}
/** 引用类型对应的值 */
var fooReference = {
  base: global,
  propertyName: 'foo'
};

var barReference = {
  base: global,
  propertyName: 'bar'
};

/** 使用伪代码中的GetValue方法从引用类型中得到一个对象真正的值  */
function GetValue(value) {

  if (Type(value) != Reference) {
    return value;
  }

  var base = GetBase(value);

  if (base === null) {
    throw new ReferenceError;
  }

  return base.[[Get]](GetPropertyName(value));

}
/** 内部的[[Get]]方法返回对象属性真正的值，包括对原型链中继承的属性分析  */
GetValue(fooReference); // 10
GetValue(barReference); // function object "bar"

/** 从引用类型中得到一个对象真正的值 流程细节示例  */
foo.bar();

// 在中间计算的返回值中，我们有了引用类型的值。
var fooBarReference = {
  base: foo,
  propertyName: 'bar'
};

GetValue(fooBarReference); // function object "bar"
```

- 表达式的不同形式激活同一个函数会不同的 this 值，答案在于引用类型（type Reference）不同的中间值。

```js
function foo() {
  alert(this);
}

foo(); // global, because

var fooReference = {
  base: global,
  propertyName: 'foo'
};

alert(foo === foo.prototype.constructor); // true

// 另外一种形式的调用表达式

foo.prototype.constructor(); // foo.prototype, because

var fooPrototypeConstructorReference = {
  base: foo.prototype,
  propertyName: 'constructor'
};
```

- 函数调用和非引用类型

```js
/**
 * 当调用括号的左边不是引用类型而是其它类型，这个值自动设置为null，结果为全局对象
 */
(function() {
  alert(this); // null => global
})();

/**
 * 更加复杂的例子
 */

var foo = {
  bar: function() {
    alert(this);
  }
};

/** 第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。  */
foo.bar(); // Reference, OK => foo

/** 在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。  */
// (foo.bar)(); // Reference, OK => foo

/** 赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。  */
(foo.bar = foo.bar)(); // global
/** 逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。  */
(false || foo.bar)(); // global
(foo.bar, foo.bar)(); // global
```

- 引用类型和 this 为 null

```js
/**
 * 当调用表达式限定了call括号左边的引用类型的值， 尽管this被设定为null，但结果被隐式转化成global。
 */
function foo() {
  console.log(this); // global
}
foo.call(null);

/**
 * 局部变量、内部函数、形式参数储存在给定函数的激活对象中
 * 活动对象总是作为this返回，值为null——（即伪代码的AO.bar()相当于null.bar()）
 */
function foo() {
  function bar() {
    alert(this); // global
  }
  bar(); // the same as AO.bar()
}

/**
 * 如果with对象包含一个函数名属性，在with语句的内部块中调用函数。
 * With语句添加到该对象作用域的最前端，即在活动对象的前面。
 * 相应地，也就有了引用类型（通过标示符或属性访问器）， 其base对象不再是活动对象，而是with语句的对象。
 */
var x = 10;

with ({
  foo: function() {
    alert(this.x);
  },
  x: 20
}) {
  foo(); // 20
}

// because

var fooReference = {
  base: __withObject,
  propertyName: 'foo'
};

/**
 * 在递归调用中，base对象应该是存储着函数表达式可选名称的特定对象。但是，在这种情况下，this总是指向全局对象。
 */
(function foo(bar) {
  console.log(this);

  !bar && foo(1); // "should" be special object, but always (correct) global
})(); // global
```

- 作为构造器调用的函数中的 this

```js
/**
 * new运算符调用“A”函数的内部的[[Construct]] 方法，接着，在对象创建后，调用内部的[[Call]] 方法。
 * 所有相同的函数“A”都将this的值设置为新创建的对象。
 */
function A() {
  alert(this); // "a"对象下创建一个新属性
  this.x = 10;
}

var a = new A();
alert(a.x); // 10
```

- 函数调用中手动设置 this(.apply 和.call 方法)

```js
/**
 * 对于.apply，第二个参数必须是数组（或者是类似数组的对象，如arguments，
 * 反过来，.call能接受任何参数。两个方法必须的参数是第一个——this。
 */
var b = 10;

function a(c) {
  alert(this.b);
  alert(c);
}

a(20); // this === global, this.b == 10, c == 20

a.call({ b: 20 }, 30); // this === {b: 20}, this.b == 20, c == 30
a.apply({ b: 30 }, [40]); // this === {b: 30}, this.b == 30, c == 40
```
