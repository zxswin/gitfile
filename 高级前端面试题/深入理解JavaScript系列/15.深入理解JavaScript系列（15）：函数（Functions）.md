# 深入理解 JavaScript 系列（15）：函数（Functions）

## 函数类型

- 函数声明

```js
/**
 * 函数声明的特点：
 * 有一个特定的名称
 * 在源码中的位置：要么处于程序级（Program level），要么处于其它函数的主体（FunctionBody）中
 * 在进入上下文阶段创建
 * 影响变量对象


 * 函数声明在源码中的位置：
 * 1.直接在全局上下文中
 * 2.或者在一个函数的函数体内
 * 3.不可能在表达式位置或一个代码块中定义它
 */

// 函数可以在如下地方声明：
// 1) 直接在全局上下文中
function globalFD() {
  // 2) 或者在一个函数的函数体内
  function innerFD() {}
}

/* 例如（函数在其声明之前被调用） 即函数提升*/

foo();

function foo() {
  alert('foo');
}
```

- 函数表达式

```js
/**
 * 函数表达式的特点
 * 在源码中须出现在表达式的位置
 * 有可选的名称
 * 不会影响变量对象
 * 在代码执行阶段创建
 */

/** 一个简单的函数表达式
 * 匿名函数表达式赋值给变量foo，然后该函数可以用foo这个名称进行访问——foo()
 */
var foo = function() {};

/** 一个拥有名称的函数表达式
 * 函数外部通过foo()来访问
 * 函数内部通过_foo()来访问(用于递归)
 */
var foo = function _foo() {};

/** 函数表达式只能在代码执行阶段创建而且不存在于变量对象中
 * 各种函数表达式
 */
// 圆括号（分组操作符）内只能是表达式
(function foo() {});

// 在数组初始化器内只能是表达式
[function bar() {}];

// 逗号也只能操作表达式
1, function baz() {};

/** 创建”私有”数据和隐藏辅助实体  */
(function() {
  // 初始化作用域
})();

/** 圆括号的问题
 * 在函数声明后面他确实是一个分组操作符
 * 在函数表达式后面它表示调用这个函数
 */

// 这才是调用，不是分组操作符
(function foo(x) {
  alert(x);
})(1);

// "foo" 是一个函数声明，在进入上下文的时候创建
alert(foo); // 函数
function foo(x) {
  alert(x);
}
1; // 这只是一个分组操作符，不是函数调用！

foo(10); // 这才是一个真正的函数调用，结果是10

// 函数声明
function foo(x) {
  alert(x);
}

// 一个分组操作符，包含一个表达式1
1;

// 另外一个操作符，包含一个function表达式
(function() {});

// 这个操作符里，包含的也是一个表达式"foo"
('foo');

/** 命名函数表达式的特性
 * 命名函数表达式在递归调用中可以通过名称调用自身
 *
 * 当解释器在代码执行阶段遇到 命名函数表达式时
 * 在创建命名函数表达式之前,创建了辅助的特定对象,并添加到当前作用域链的最前端
 * 然后创建命名函数表达式
 * 命名函数表达式的名称添加到特定对象上作为唯一的属性
 * 这个属性的值是引用到命名函数表达式
 * 特定对象已经存储在函数的[[scope]]中，在那里名称是可用的(在父作用域中并不存在)
 * 从父作用域链中移除那个特定的对象
 * 
specialObject = {};
Scope = specialObject + Scope;
foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}
delete Scope[0]; // 从作用域链中删除定义的特殊对象specialObject
 */

(function foo(bar) {
  if (bar) {
    return;
  }

  foo(true); // "foo" 是可用的
})();

// 在外部，是不可用的
foo(); // "foo" 未定义
```

- 通过函数构造器创建的函数

```js
/**
 * 这种函数的[[Scope]]属性仅包含全局对象
 */
var x = 10;

function foo() {
  var x = 20;
  var y = 30;

  var bar = new Function('alert(x); alert(y);');

  bar(); // 10, "y" 未定义
}

/** 通过函数构造器创建的函数总是需要更多的内存资源(会生成不同的引用类型) */
var a = [];

for (var k = 0; k < 100; k++) {
  a[k] = Function(''); // 一直是100个不同的函数
}
```

## 创建函数的算法

```js
/**
 * F.[[Prototype]]是函数（构造器）的一个原型，F.prototype是通过这个函数创建的对象的原型
  */
F = new NativeObject();

// 属性[[Class]]是"Function"
F.[[Class]] = "Function"

// 函数对象的原型是Function的原型
F.[[Prototype]] = Function.prototype

// 运用到函数自身
// 调用表达式F的时候激活[[Call]]
// 并且创建新的执行上下文
F.[[Call]] = <reference to function>

// 在对象的普通构造器里编译
// [[Construct]] 通过new关键字激活
// 并且给新对象分配内存
// 然后调用F.[[Call]]初始化作为this传递的新创建的对象
F.[[Construct]] = internalConstructor

// 当前执行上下文的作用域链
// 例如，创建F的上下文
F.[[Scope]] = activeContext.Scope
// 如果函数通过new Function(...)来创建，
// 那么
F.[[Scope]] = globalContext.Scope

// 传入参数的个数
F.length = countParameters

// F对象创建的原型
__objectPrototype = new Object();
__objectPrototype.constructor = F // {DontEnum}, 在循环里不可枚举x
F.prototype = __objectPrototype

return F
```
