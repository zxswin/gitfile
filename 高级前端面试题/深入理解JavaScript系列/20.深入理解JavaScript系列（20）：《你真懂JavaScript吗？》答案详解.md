# 深入理解 JavaScript 系列（20）：《你真懂 JavaScript 吗？》答案详解

## 题目 1

```js
/**
 * 实际结果是“undefined”
 * 变量声明被提前了，但变量赋值没有
 */
if (!('a' in window)) {
  var a = 1;
}
alert(a); // 实际结果是“undefined”
```

## 题目 2

```js
/**
 * alert的结果是1；
 * 函数表达式没有提前，就相当于平时的变量赋值。
 * 填充VO的顺序是: 函数的形参 -> 函数声明 -> 变量声明。
 */
var a = 1,
  b = function a(x) {
    x && a(--x);
  };
alert(a); // alert的结果是1；
```

## 题目 3

```js
/**
 * 函数声明会覆盖变量声明，但不会覆盖变量赋值，
 * 函数声明的优先级高于变量声明的优先级
 * 函数声明和变量声明的关系和影响，遇到同名的函数声明，VO不会重新定义
 */
function value() {
  return 1;
}
var value;
alert(typeof value); //"function"

/**
 * 变量赋值初始化就覆盖了函数声明
 */
function value() {
  return 1;
}
var value = 1;
alert(typeof value); //"number"
```

## 题目 4

```js
/**
 * 活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。
 * arguments属性的值是Arguments对象：
    1.callee — 指向当前函数的引用
    2.length — 真正传递的参数个数
    3.properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。
 * 这个共享其实不是真正的共享一个内存地址，而是2个不同的内存地址，使用JavaScript引擎来保证2个值是随时一样的
 */
function b(x, y, a) {
  arguments[2] = 10;
  alert(a);
}
b(1, 2, 3); // 10

/**
 * 但如下代码弹出的结果依然是10，因为和a没有关系。
 */
function b(x, y, a) {
  arguments[2] = 10;
  alert(arguments[2]);
}
b(1, 2);
```

## 题目 5

```js
/**
 * 如果第一个参数传入的对象调用者是null或者undefined的话，call方法将把全局对象（也就是window）作为this的值
 */
function a() {
  alert(this);
}
a.call(null); // [object Window]
```
