# 深入理解 JavaScript 系列（45）：代码复用模式（避免篇）

## 要避免的模式

- 模式 1：默认模式

```js
/**
 * 这种模式的缺点是Child不能传进参数，基本上也就废了。
 */
function inherit(C, P) {
  C.prototype = new P();
}

// 父构造函数
function Parent(name) {
  this.name = name || 'Adam';
}
// 给原型添加say功能
Parent.prototype.say = function() {
  return this.name;
};
// Child构造函数为空
function Child(name) {}

// 执行继承
inherit(Child, Parent);

var kid = new Child();
console.log(kid.say()); // "Adam"

var kiddo = new Child();
kiddo.name = 'Patrick';
console.log(kiddo.say()); // "Patrick"

// 缺点:不能让参数传进给Child构造函数
var s = new Child('Seth');
console.log(s.say()); // "Adam"
```

- 模式 2：借用构造函数

```js
/**
 * 缺点也很明显，say方法不可用，因为没有继承过来。
 */
// 父构造函数
function Parent(name) {
  this.name = name || 'Adam';
}

// 给原型添加say功能
Parent.prototype.say = function() {
  return this.name;
};

// Child构造函数
function Child(name) {
  Parent.apply(this, arguments);
}

var kid = new Child('Patrick');
console.log(kid.name); // "Patrick"

// 缺点：没有从构造函数上继承say方法
console.log(typeof kid.say); // "undefined"
```

- 模式 3：借用构造函数并设置原型

```js
/**
 * Parent构造函数执行了两次，所以说，虽然程序可用，但是效率很低。
 */
// 父构造函数
function Parent(name) {
  this.name = name || 'Adam';
}

// 给原型添加say功能
Parent.prototype.say = function() {
  return this.name;
};

// Child构造函数
function Child(name) {
  Parent.apply(this, arguments);
}

Child.prototype = new Parent();

var kid = new Child('Patrick');
console.log(kid.name); // "Patrick"
console.log(typeof kid.say); // function
console.log(kid.say()); // Patrick
console.dir(kid);
delete kid.name;
console.log(kid.say()); // "Adam"
```

- 模式 4：共享原型

```js
/**
 * Child的参数没有正确接收到。
 */
function inherit(C, P) {
  C.prototype = P.prototype;
}

// 父构造函数
function Parent(name) {
  this.name = name || 'Adam';
}

// 给原型添加say功能
Parent.prototype.say = function() {
  return this.name;
};

// Child构造函数
function Child(name) {}

inherit(Child, Parent);

var kid = new Child('Patrick');
console.log(kid.name); // undefined
console.log(typeof kid.say); // function
kid.name = 'Patrick';
console.log(kid.say()); // Patrick
console.dir(kid);
```

- 模式 5：临时构造函数

```js
/**
 * 问题照旧，Child不能正常接收参数。
 */
/* 闭包 */
var inherit = (function() {
  var F = function() {};
  return function(C, P) {
    F.prototype = P.prototype;
    C.prototype = new F();
    C.uber = P.prototype;
    C.prototype.constructor = C;
  };
})();

function Parent(name) {
  this.name = name || 'Adam';
}

// 给原型添加say功能
Parent.prototype.say = function() {
  return this.name;
};

// Child构造函数
function Child(name) {}

inherit(Child, Parent);

var kid = new Child();
console.log(kid.name); // undefined
console.log(typeof kid.say); // function
kid.name = 'Patrick';
console.log(kid.say()); // Patrick
var kid2 = new Child('Tom');
console.log(kid.say());
console.log(kid.constructor.name); // Child
console.log(kid.constructor === Parent); // false
```
