# 深入理解 JavaScript 系列（12）：变量对象（Variable Object）

- ECMAScript 里的 for 循环并不能创建一个局部的上下文

```js
for (var k in { a: 1, b: 2 }) {
  console.log('k', k);
}

console.log('外部', k); // 尽管循环已经结束但变量k依然在当前作用域 b
```

- 关于执行上下文中的变量对象

```js
/**
 * 变量对象(缩写为VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：
    变量 (var, 变量声明);
    函数声明 (FunctionDeclaration, 缩写为FD);
    函数的形参
  */
```

- 关于全局对象

```js
/**
 * 全局对象(Global object) 是在进入任何执行上下文之前就已经创建了的对象；
 * 这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。
 */

String(10); // 就是global.String(10);

// 带有前缀
window.a = 10; // === global.window.a = 10 === global.a = 10;
this.b = 20; // global.b = 20;
```

- 关于活动对象

```js
/**
 * 活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：

 * Arguments对象是活动对象的一个属性，它包括如下属性：
    callee — 指向当前函数的引用
    length — 真正传递的参数个数
    properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。
  */
function foo(x, y, z) {
  // 声明的函数参数数量arguments (x, y, z)
  alert(foo.length); // 3

  // 真正传进来的参数个数(only x, y)
  alert(arguments.length); // 2

  // 参数的callee是函数自身
  alert(arguments.callee === foo); // true

  // 参数共享

  alert(x === arguments[0]); // true
  alert(x); // 10

  arguments[0] = 20;
  alert(x); // 20

  x = 30;
  alert(arguments[0]); // 30

  // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的

  z = 40;
  alert(arguments[2]); // undefined

  arguments[2] = 50;
  alert(z); // 40
}

foo(10, 20);
```

- 进入执行上下文

```js
/**
 * 当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性(前面已经说了)：

    函数的所有形参(如果我们是在函数执行上下文中)

    — 由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和undefined值组成的一种变量对象的属性也将被创建。

    所有函数声明(FunctionDeclaration, FD)

    —由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。

    所有变量声明(var, VariableDeclaration)

    — 由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。

    AO/VO已经拥有了属性(不过，并不是所有的属性都有值，大部分属性的值还是系统默认的初始值undefined )。
 */

function test(a, b) {
  var c = 10;
  function d() {}
  var e = function _e() {};
  (function x() {});
}

test(10); // call

AO(test) = {
  a: 10,
  b: undefined,
  c: undefined,
  d: <reference to FunctionDeclaration "d">
  e: undefined
};
```

- 代码执行

```js
/**
 * 变量声明在顺序上跟在函数声明和形式参数声明之后，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明
 */
alert(x); // function

var x = 10;
alert(x); // 10

x = 20;

function x() {}

alert(x); // 20
```

- 关于变量

```js
/**
 * 任何时候，变量只能通过使用var关键字才能声明。

 * 这仅仅是给全局对象创建了一个新属性(但它不是变量)。
 * a = 10;

 */

/* 因为“b”不是一个变量，所以在这个阶段根本就没有“b”，“b”将只在代码执行阶段才会出现 */
alert(a); // undefined
alert(b); // "b" 没有声明

b = 10;
var a = 20;

/* 变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。 */
a = 10;
alert(window.a); // 10

alert(delete a); // true

alert(window.a); // undefined

var b = 20;
alert(window.b); // 20

alert(delete b); // false

alert(window.b); // still 20

/* 但是这个规则在有个上下文里不起走样，那就是eval上下文，变量没有{DontDelete}特性。 */
eval('var a = 10;');
alert(window.a); // 10

alert(delete a); // true

alert(window.a); // undefined
```
