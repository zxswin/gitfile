# 深入理解 JavaScript 系列（50）：Function 模式（下篇）

## 初始化模式和性能模式

- 立即执行的函数

```js
/**
 * 立即执行的函数 总结
 */
// 声明完函数以后，立即执行该函数
(function() {
  console.log('watch out!');
})();

//这种方式声明的函数，也可以立即执行
!(function() {
  console.log('watch out!');
})();

// 如下方式也都可以哦
~(function() {
  /* code */
})();
-(function() {
  /* code */
})();
+(function() {
  /* code */
})();
```

- 立即执行的对象初始化

```js
/**
 * 在声明一个对象（而非函数）的时候，立即执行对象里的某一个方法来进行初始化工作
 */
({
  // 这里你可以定义常量，设置其它值
  maxwidth: 600,
  maxheight: 400,

  //  当然也可以定义utility方法
  gimmeMax: function() {
    return this.maxwidth + 'x' + this.maxheight;
  },

  // 初始化
  init: function() {
    console.log(this.gimmeMax());
    // 更多代码...
  }
}.init()); // 这样就开始初始化咯
```

- 分支初始化

```js
/**
 * 分支初始化是指在初始化的时候，根据不同的条件（场景）初始化不同的代码，也就是所谓的条件语句赋值。
 */

// 首先我们要定义两个接口，一个用来add事件句柄，一个用来remove事件句柄
var utils = {
  addListener: null,
  removeListener: null
};

if (typeof window.addEventListener === 'function') {
  utils.addListener = function(el, type, fn) {
    el.addEventListener(type, fn, false);
  };
} else if (typeof document.attachEvent !== 'undefined') {
  // IE
  utils.addListener = function(el, type, fn) {
    el.attachEvent('on' + type, fn);
  };
  utils.removeListener = function(el, type, fn) {
    el.detachEvent('on' + type, fn);
  };
} else {
  // 其它旧浏览器
  utils.addListener = function(el, type, fn) {
    el['on' + type] = fn;
  };
  utils.removeListener = function(el, type, fn) {
    el['on' + type] = null;
  };
}
```

- 自声明函数

```js
/**
 * 大家使用这种模式时，一定要非常小心才行，否则实际结果很可能和你期望的结果不一样
 */

// 一般是在函数内部，重写同名函数代码，比如：
var scareMe = function() {
  alert('Boo!');
  scareMe = function() {
    alert('Double boo!');
  };
};

// 这种代码，非常容易使人迷惑
// 1. 添加新属性
scareMe.property = 'properly';
// 2. scareMe赋与一个新值
var prank = scareMe;
// 3. 作为一个方法调用
var spooky = {
  boo: scareMe
};
// 使用新变量名称进行调用
prank(); // "Boo!"
prank(); // "Boo!"
console.log(prank.property); // "properly"
// 使用方法进行调用
spooky.boo(); // "Boo!"
spooky.boo(); // "Boo!"
console.log(spooky.boo.property); // "properly"

// 通过执行结果，可以发现，将定于的函数赋值与新变量（或内部方法），代码并不执行重载的scareMe代码，而如下例子则正好相反：

// 使用自声明函数
scareMe(); // Double boo!
scareMe(); // Double boo!
console.log(scareMe.property); // undefined
```

- 内存优化

```js
/**
 * 该模式主要是利用函数的属性特性来避免大量的重复计算
 */

// 或者如果你传入的参数是多个的话，可以将这些参数通过JSON的stringify方法生产一个cachekey值进行存储，代码如下：

var myFunc = function() {
  var cachekey = JSON.stringify(Array.prototype.slice.call(arguments)),
    result;
  if (!myFunc.cache[cachekey]) {
    result = {};
    // ... 复杂操作 ...
    myFunc.cache[cachekey] = result;
  }
  return myFunc.cache[cachekey];
};

// cache 存储
myFunc.cache = {};
```
