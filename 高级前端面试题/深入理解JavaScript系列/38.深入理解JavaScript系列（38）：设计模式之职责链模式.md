# 深入理解 JavaScript 系列（38）：设计模式之职责链模式

## 基本实现

```js
/**
 * 请求以后，从第一个对象开始，链中收到请求的对象要么亲自处理它，要么转发给链中的下一个候选者。
 * DOM里的事件冒泡机制也和此好像有点类似
 */

/** 利用其原型特性来实现职责链模式。  */
var NO_TOPIC = -1;
var Topic;

function Handler(s, t) {
  this.successor = s || null;
  this.topic = t || 0;
}

Handler.prototype = {
  handle: function() {
    if (this.successor) {
      this.successor.handle();
    }
  },
  has: function() {
    return this.topic != NO_TOPIC;
  }
};

/**
 * 改代码通过原型特性，调用代码从button.handle()->dialog.handle()->app.handle()->参数里的handle()，
 * 也就是说其实只有最后一层才处理
 */
var app = new Handler(
  {
    handle: function() {
      console.log('app handle');
    }
  },
  3
);

var dialog = new Handler(app, 1);
dialog.handle = function() {
  console.log('dialog before ...');
  // 这里做具体的处理操作
  console.log('dialog after ...');
};

var button = new Handler(dialog, 2);

button.handle();

/**
 * 想先自身处理，然后再调用继任者处理的话，就在末尾执行Handler.prototype.handle.call(this);
 */
var app = new Handler(
  {
    handle: function() {
      console.log('app handle');
    }
  },
  3
);

var dialog = new Handler(app, 1);
dialog.handle = function() {
  console.log('dialog before ...');
  // 这里做具体的处理操作
  Handler.prototype.handle.call(this); //继续往上走
  console.log('dialog after ...');
};

var button = new Handler(dialog, 2);
button.handle = function() {
  console.log('button before ...');
  // 这里做具体的处理操作
  Handler.prototype.handle.call(this);
  console.log('button after ...');
};

button.handle();
```
