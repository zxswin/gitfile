# 闭包

## 函数

- 函数

```js
/**
 * 函数(Function)基本有属性和方法,可用被调用并且有返回值
 * 函数中没有使用return语句，则它默认返回undefined
 * 使用 return 语句来指定一个要返回的值
 * 使用new关键字调用一个构造函数会隐式返回指向自己的this
 * 在函数执行时，this 关键字并不会指向正在运行的函数本身，而是指向调用该函数的对象。
 *
 * Function构造函数应尽可能地避免使用
 * 通过函数表达式定义的函数和通过函数声明定义的函数只会被解析一次(调用的时候)
 * 每次构造函数被调用，传递给Function构造函数的函数体字符串都要被解析一次 。
 * 此函数表达式仍然要快于"new Function(...)"
 */
```

- 函数声明

```js
/**
 * 一个被函数声明创建的函数是一个 Function 对象，具有 Function 对象的所有属性、方法和行为。
 * 函数声明会被提升,可用在函数声明前调用函数
 */
hoisted(); // "foo"

function hoisted() {
  console.log('foo');
}

/**
 * 函数声明经常意外地转换为函数表达式
 */
// 函数声明
function foo() {}

// 函数表达式
(function bar() {});

// 函数表达式
x = function hello() {};

if (x) {
  // 函数表达式
  function world() {}
}

// 函数声明
function a() {
  // 函数声明
  function b() {}
  if (0) {
    //函数表达式
    function c() {}
  }
}
```

- 函数表达式

```js
/**
 * 函数表达式
 * 函数表达式不能被提升(不可以在函数被定义前使用)
 * 通过var定义的变量会被提升到函数的顶部(声明被提升值是undefined)
 */

notHoisted(); // 报错 TypeError: notHoisted is not a function

var notHoisted = function() {
  console.log('bar');
};

/**
 * 函数表达式与函数声明的最主要区别是函数名称，在函数表达式中可省略它，从而创建匿名函数
 * 函数表达式可用用作即时调用的函数表达式），它一旦定义就运行
 */

// 创建自动执行的匿名函数
var foo = (function(i) {
  console.log(i);
})(1);

// 函数声明必须要带函数名
function () { } // 直接这样声明是会报错的
function name() {} // 这样才对

/**
 * 被函数声明赋值的那个变量会有一个name属性
 * 函数是一个匿名函数，那name属性的值就是被赋值的变量的名称（隐藏值）
 * 如果函数不是匿名的话，那name属性的是就是这个函数的名称（显性值）
 */

// 这是一个函数表达式
var foo = function() {};

foo.name; // "foo"

// 赋值给其他变量name属性的值也不会改变
var foo2 = foo;
foo2.name; // "foo"

var bar = function baz() {};
bar.name; // "baz"

console.log(foo === foo2); //true
console.log(typeof baz); // undefined
console.log(bar === baz); // false (errors because baz == undefined)
```

## JS 的内存管理

```js
/**
 * JavaScript创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。
 * JavaScript 在定义变量时就完成了内存分配
 */
var n = 123; // 给数值变量分配内存
var s = 'azerty'; // 给字符串分配内存
```

- js 的垃圾回收机原理(引用计数垃圾)

```js
/**
 * 引用计数垃圾收集
 * 如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
 * 该算法有个限制：无法处理循环引用。
 */

// 创建一个对象并通过o引用它
var o = {
  a: 1
};

// 那个对象现在也是零引用了 会被垃圾回收机制回收
o = 1;

/**
 * 引用计数垃圾收集无法处理循环引用的问题
 */
function f() {
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return 'azerty';
}

f();
```

- 标记-清除算法

```js
/**
 * 一般来说没有被引用的对象就是垃圾，就是要被清除，
 * 垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象
 * 什么是根：一组基本的固有可达值，由于显而易见的原因无法删除
    1.本地函数的局部变量和参数
    2.当前嵌套调用链上的其他函数的变量和参数
    3.全局变量
 * 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的
 * 垃圾回收器，它监视所有对象，并删除那些不可访问的对象
 */

var o = {
  a: 1
};

o = null;

// 没有被引用了将会被垃圾回收机制回收销毁
// {
//   a: 1
// };
```

- 垃圾回收机制在函数执行后的作用

```js
/**
 * 一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,
 * 这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.
 */
```

## 函数的作用域链

- 执行上下文

```js
/**
 * 执行上下文具备：变量对象(变量的解析)，作用域链(变量作用域)，this指针(函数this的指向)
 * 上下文栈:
   开始执行一个函数之前，js都要创建一个上下文对象，并将其压入上下文栈中
   当前上下文总是在栈顶,这个函数一执行完，上下文就会从栈中弹出
   代码开始运行时，栈顶会先放入一个全局上下文，全局上下文同样有变量对象，作用域链和this指针。
 */

/**
 * 示例分析
 * 开始执行时：
  栈顶：全局上下文
  代码执行到fun1();时，创建fun1的上下文，压入栈。这时栈变成：
  栈顶：fun1上下文 / 全局上下文
  代码执行到fun2();时，创建fun2的上下文，压入栈。这时栈变成：
  栈顶：fun2上下文 / fun1上下文 / 全局上下文
  fun2执行完毕，fun2上下文弹出：
  栈顶：fun1上下文 / 全局上下文
  (这时执行权回到fun1内，栈顶也恰好回到了fun1上下文。可见这种机制能保证正在执行的函数的上下文总是在栈顶)
  fun1执行完毕，fun1上下文弹出，执行权回到全局区域：
  栈顶：全局上下文
  所有代码都执行完毕，全局上下文弹出，栈为空。

  */
function fun2() {
  var b = 222;
}
function fun1() {
  var a = 111;
  fun2();
}
fun1();
c = 333;

/**
 * 变量对象
 * 函数还未开始执行（创建上下文的期间）时叫变量对象，函数开始执行以后就叫活动对象
 * 变量对象让js有变量提升的特性
 * 创建变量对象的过程
 * 建立arguments对象：属性名是'0'、'1'、'2'.....，属性值就是实际传入的参数。此外arguments.length是实际参数的个数。
 * 找到这个将要执行的函数内的所有函数声明，储存在变量对象中，属性名就是函数名，属性值就是函数的引用（所在的内存地址）。
 * 找到这个将要执行的函数内的所有变量声明，储存在变量对象中，属性名就是变量名，属性值是undefined。
 */
function fun1(var arg) {
    // 创建变量对象：{arg:987, fun2:fun2的地址, a:undefinded}
    console.log(a);  // 打印undefinded，因为活动对象中有键值对：a:undefinded。
    var a = 111;      // 如果将这一语句删除，上一句会直接报错！
    console.log(a);  // 打印111，因为活动对象中有键值对：a:111
    fun2();          // 打印in fun2! 因为活动对象中有键值对：fun2：某个内存地址
    return;          // 即使是在return之后的声明，也会被放入变量对象！
    function fun2() {
        console.log('in fun2!');
    }
}
fun1(987);
// 输出为：
// undefined
// 111
// in fun2!
```

- 作用域链

```js
/**
 * 作用域链就是变量对象的数组！
 * 一个是当前函数的活动对象
 * 第二个是当前活动函数的父亲上下文的活动对象
 * 第三个是当前活动函数的爷爷上下文的活动对象
 * ……最后一个是全局上下文的活动对象
 * 
 * 作用域链这个数组可以分成两部分：
 * 第一个元素就是本函数的变量对象
 * 后面的所有元素都是上层上下文的变量对象（按照由近到远的顺序排列
 * 第一部分是在函数执行之前创建的。第二部分其实在函数声明的时候就已经确定了
 * [[Scope]]是函数的一个属性，从函数声明到函数销毁一直存在，且不会改变。
 * 
 开始执行outter()之前，创建的执行上下文.作用域链是：
 [outter的变量对象， 全局的变量对象]
解析global_var的时候，在outter的变量对象中没有找到，因此在全局的变量对象中找，找到这个属性，所以可以打印出它的值-1。
解析outter_var的时候，在outter的变量对象中就找到了，因此不用往后找了，直接打印111。

inner的执行上下文.作用域链是：
[inner的变量对象，outter的变量对象， 全局的变量对象]
变量解析的过程同上。

 */

var global_var = -1;

function outter() {
  var outter_var = 111;
  console.log(
    'in outter, global_var = ' + global_var + ', outter_var = ' + outter_var
  );

  function inner() {
    var inner_var = 333;
    console.log(
      'in inner, global_var = ' +
        global_var +
        ', outter_var = ' +
        outter_var +
        ', inner_var = ' +
        inner_var
    );
  }
  inner();
}
outter();
// 输出
// in outter, global_var = -1, outter_var = 111
// in inner, global_var = -1, outter_var = 111, inner_var = 333
```

## delete

- 简单实用范例

```js
/**
 * delete 操作符用于删除对象的某个属性
 * 对于所有情况都是true(即使是删除的属性不存在也是会返回true)
 * 除非属性是一个自己不可配置的属性，在这种情况下，非严格模式返回 false。
 */
var Employee = {
  firstname: 'John',
  lastname: 'Doe'
};

console.log(Employee.firstname);
// expected output: "John"

delete Employee.firstname;

console.log(Employee.firstname);
// expected output: undefined

/**
 * 任何使用 var 声明的属性不能从全局作用域或函数的作用域中删除。
 * 全局作用域中的函数不能被删除
 * 任何用let或const声明的属性不能够从它被声明的作用域中删除。
 * 设置不可配置属性不能被删除
 * 删除一个对象的自己的属性，而原型链上具有相同名称的属性可用(这个属性仍然是可用的)
 */
// 设置不可配置属性
Object.defineProperty(Employee, 'name', { configurable: false });
// 通过以下方法获取全局属性:
Object.getOwnPropertyDescriptor(window, 'nameOther');
```

## 参考文章

```bash
[汤姆大叔的博客] http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html
[js垃圾回收机制] https://www.cnblogs.com/fundebug/p/javascript-memory-garbage-collection.html
```

## 单词

```pug
closures 闭包
scope 范围 作用域
callee 受访者
```
