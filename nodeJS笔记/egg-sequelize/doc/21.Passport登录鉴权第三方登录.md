# Passport 登录鉴权第三方登录

## egg-passport 插件

- 把初始化、鉴权成功后的回调处理等通用逻辑封装掉
- 开发者仅需调用几个 API 即可方便的使用 Passport

## Passport 的执行时序如下：

```bash
用户访问页面
检查 Session
拦截跳鉴权登录页面
Strategy 鉴权
校验和存储用户信息
序列化用户信息到 Session
跳转到指定页面
```

## 使用 egg-passport

### 安装

```js
$ npm i --save egg-passport
$ npm i --save egg-passport-github
```

### 开启插件：

```js
// config/plugin.js
module.exports.passport = {
  enable: true,
  package: 'egg-passport'
};

module.exports.passportGithub = {
  enable: true,
  package: 'egg-passport-github'
};
```

### 配置

- egg-passport 标准化了配置字段，统一为 key 和 secret

```js
// config/default.js
config.passportGithub = {
  key: 'your_clientID',
  secret: 'your_clientSecret'
  // callbackURL: '/passport/github/callback',
  // proxy: false,
};
```

### 挂载路由

```js
// app/router.js
module.exports = app => {
  const { router, controller } = app;

  // 挂载鉴权路由
  app.passport.mount('github');

  // 上面的 mount 是语法糖，等价于
  // const github = app.passport.authenticate('github', {});
  // router.get('/passport/github', github);
  // router.get('/passport/github/callback', github);
};
```

### 用户信息处理

- 首次登录时，一般需要把用户信息进行入库，并记录 Session 。
- 二次登录时，从 OAuth 或 Session 拿到的用户信息，读取数据库拿到完整的用户信息。

```js
// app.js
module.exports = app => {
  app.passport.verify(async (ctx, user) => {
    // 检查用户
    assert(user.provider, 'user.provider should exists');
    assert(user.id, 'user.id should exists');

    // 从数据库中查找用户信息
    //
    // Authorization Table
    // column   | desc
    // ---      | --
    // provider | provider name, like github, twitter, facebook, weibo and so on
    // uid      | provider unique id
    // user_id  | current application user id
    const auth = await ctx.model.Authorization.findOne({
      uid: user.id,
      provider: user.provider
    });
    const existsUser = await ctx.model.User.findOne({ id: auth.user_id });
    if (existsUser) {
      return existsUser;
    }
    // 调用 service 注册新用户
    const newUser = await ctx.service.user.register(user);
    return newUser;
  });

  // 将用户信息序列化后存进 session 里面，一般需要精简，只保存个别字段
  app.passport.serializeUser(async (ctx, user) => {
    // 处理 user
    // ...
    // return user;
  });

  // 反序列化后把用户信息从 session 中取出来，反查数据库拿到完整信息
  app.passport.deserializeUser(async (ctx, user) => {
    // 处理 user
    // ...
    // return user;
  });
};
```

### egg-passport 提供了以下扩展：

```bash
ctx.user - 获取当前已登录的用户信息
ctx.isAuthenticated() - 检查该请求是否已授权
ctx.login(user, [options]) - 为用户启动一个登录的 session
ctx.logout() - 退出，将用户信息从 session 中清除
ctx.session.returnTo= - 在跳转验证前设置，可以指定成功后的 redirect 地址
```

### egg-passport API：

- app.passport.authenticate 中，未设置 options.successRedirect 或者 options.successReturnToOrRedirect 将默认跳转 /

```bash
app.passport.verify(async (ctx, user) => {}) - 校验用户
app.passport.serializeUser(async (ctx, user) => {}) - 序列化用户信息后存储进 session
app.passport.deserializeUser(async (ctx, user) => {}) - 反序列化后取出用户信息
app.passport.authenticate(strategy, options) - 生成指定的鉴权中间件
  options.successRedirect - 指定鉴权成功后的 redirect 地址
  options.loginURL - 跳转登录地址，默认为 /passport/${strategy}
  options.callbackURL - 授权后回调地址，默认为 /passport/${strategy}/callback
app.passport.mount(strategy, options) - 语法糖，方便开发者配置路由
```

### 使用 Passport 生态
