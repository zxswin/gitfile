# 一个简单的网络聊天室案例

## websocket 的特点

```bash
（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
```

## 客户端 websocket 使用

- 客户端 websocket 事件

```bash
open	Socket.onopen	连接建立时触发
message	Socket.onmessage	客户端接收服务端数据时触发
error	Socket.onerror	通信发生错误时触发
close	Socket.onclose	连接关闭时触发
```

- WebSocket 方法

```bash
Socket.send()	 使用连接发送数据
Socket.close()	关闭连接
```

- 如果要指定多个回调函数，可以使用 addEventListener 方法。

```js
ws.onopen = function() {
  ws.send('Hello Server!');
};

ws.addEventListener('open', function(event) {
  ws.send('Hello Server!');
});
```

## 服务器端转发消息

- 消息群发 和 消息一对一发送思路

```bash
# 可以通过广播把消息群发给所有监听ws的客户端
# ws 会提供一个clients列表 通过用户id 区分是哪个用户 就可以单独发消息给特定用户
```

## 案例实现代码

- 路由部分

```js
let index = 0;

module.exports = {
  'GET /ws': async (ctx, next) => {
    let names = '甲乙丙丁戊己庚辛壬癸';
    let name = names[index % 10];
    ctx.render('ws.html', { name: `路人${name}` });
  },

  // 登录后设置缓存用于用户标示 非常重要
  'POST /wsin': async (ctx, next) => {
    index++;
    let name = ctx.request.body.name || '路人甲';
    let user = {
      type: '游客',
      id: index,
      name: name,
      image: index % 10
    };
    let value = Buffer.from(JSON.stringify(user)).toString('base64');
    console.log(`Set cookie value: ${value}`);
    ctx.cookies.set('name', value);
    ctx.body = {
      code: 0,
      data: '登录成功'
    };
  },

  // 用户退出清空缓存
  'GET /wsout': async (ctx, next) => {
    ctx.cookies.set('name', '');
    ctx.body = {
      code: 0,
      data: '退出成功'
    };
  }
};
```

- 服务端代码

```js
const url = require('url');

const ws = require('ws');

const Cookies = require('cookies');

const Koa = require('koa');

const bodyParser = require('koa-bodyparser');

const controller = require('./controller');

const templating = require('./templating');

const WebSocketServer = ws.Server;

const app = new Koa();

// 打印URL 和请求方法
app.use(async (ctx, next) => {
  console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
  await next();
});

// 从cookies中解析出 name 字段用于做用户标示
app.use(async (ctx, next) => {
  ctx.state.user = parseUser(ctx.cookies.get('name') || '');
  await next();
});

// 解析静态资源
let staticFiles = require('./static-files');
app.use(staticFiles('/static/', __dirname + '/static'));

// 解析出body参数
app.use(bodyParser());

// 添加 nunjucks 作为模板引擎
app.use(
  templating('views', {
    noCache: true,
    watch: true
  })
);

// 添加控制器中间件
app.use(controller());

let server = app.listen(3000);

// 读取缓存中的相关字段用于用户标示
function parseUser(obj) {
  if (!obj) {
    return;
  }
  let s = '';
  if (typeof obj === 'string') {
    s = obj;
  } else if (obj.headers) {
    let cookies = new Cookies(obj, null);
    console.log('namenamenamenamename', cookies.get('name'));
    s = cookies.get('name');
  }
  if (s) {
    try {
      let user = JSON.parse(Buffer.from(s, 'base64').toString());
      return user;
    } catch (e) {}
  }
}

// 创建websocke服务器
function createWebSocketServer(
  server,
  onConnection,
  onMessage,
  onClose,
  onError
) {
  let wss = new WebSocketServer({
    // websocket和koa监听的是同一个端口
    // 如果请求的http普通请求交给koa处理
    // 如果请求是ws请求则交给websocket处理
    server: server
  });

  // 向有用户广播信息
  wss.broadcast = function broadcast(data) {
    wss.clients.forEach(function each(client) {
      // 这里可以通过 过滤用户id 向指定的用户发送消息
      client.send(data);
    });
  };

  // 连接事件触发
  onConnection =
    onConnection ||
    function() {
      console.log('[WebSocket] connected.');
    };

  // 发送消息事件触发
  onMessage =
    onMessage ||
    function(msg) {
      console.log('[WebSocket] message received: ' + msg);
    };

  // 关闭消息事件触发
  onClose =
    onClose ||
    function(code, message) {
      console.log(`[WebSocket] closed: ${code} - ${message}`);
    };

  // 发送错误事件触发
  onError =
    onError ||
    function(err) {
      console.log('[WebSocket] error: ' + err);
    };

  // 响应连接事件
  wss.on('connection', function(ws) {
    let location = url.parse(ws.upgradeReq.url, true);
    console.log('[WebSocketServer] connection: ' + location.href);
    ws.on('message', onMessage); // this对象时ws
    ws.on('close', onClose); // this对象时ws
    ws.on('error', onError); // this对象时ws

    let user = parseUser(ws.upgradeReq);
    if (!user) {
      ws.close(4001, 'Invalid user');
    }
    ws.user = user;
    ws.wss = wss;
    onConnection.apply(ws); // 通过继承的方式使用对象冒充 onConnection函数中的this 为ws
  });
  return wss;
}

var messageIndex = 0;

// 创建要发送的消息类型
function createMessage(type, user, data) {
  messageIndex++;
  return JSON.stringify({
    id: messageIndex,
    type: type,
    user: user,
    data: data
  });
}

function onConnection() {
  // 通过继承的方式使用对象冒充 onConnection函数中的this 为ws
  let user = this.user;
  let msg = createMessage('join', user, `${user.name} joined.`);
  // 向每一个用户去广播了这一条消息
  this.wss.broadcast(msg);
  let users = this.wss.clients.map(function(client) {
    return client.user;
  });

  // 发送用户列表
  this.send(createMessage('list', user, users));
}

function onMessage(message) {
  // 用户发送消息
  if (message && message.trim()) {
    let msg = createMessage('chat', this.user, message.trim());
    // 向每一个用户去广播了这一条消息
    this.wss.broadcast(msg);
  }
}

function onClose() {
  // 用户离开
  let user = this.user;
  let msg = createMessage('left', user, `${user.name} is left.`);
  // 向每一个用户去广播了这一条消息
  this.wss.broadcast(msg);
}

// 创建websocket 服务
app.wss = createWebSocketServer(server, onConnection, onMessage, onClose);

console.log('app started at port 3000...');
```

- 客户端代码

```js
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="/static/js/jquery.min.js"></script>
    <title>网络聊天室</title>
  </head>
  <body>
    <p>{{ name }}</p>
    <button id="signin">登入</button>
    <button id="signout">退出</button>
    <input type="text" id="mes" placeholder="请输入信息" />
    <button id="go">发送消息</button>
  </body>
  <script>
    $(function() {
      console.log('{{ name }}');
      let ws = null;
      // 点击按钮发送信息
      $('#go').on('click', function() {
        console.log('已经点击了发送消息按钮');
        // 客户端发送的信息
        if (ws) {
          ws.send($('#mes').val());
        }
      });

      // 点击按钮登入
      $('#signin').on('click', function() {
        console.log('点击了登入按钮');
        $.ajax({
          url: '/wsin',
          method: 'post',
          dataType: 'json',
          data: { name: '{{ name }}' },
          success: function(data) {
            if (data.code === 0) {
              console.log('登录成功');
              webSocket();
            }
          }
        });
      });

      // 点击按钮退出
      $('#signout').on('click', function() {
        console.log('点击了退出按钮');
        $.ajax({
          url: '/wsout',
          method: 'get',
          success: function(data) {
            if (data.code === 0) {
              console.log('退出成功');
              if (ws) {
                ws.send('Goodbye!'); //客户端发送的信息
                ws.close(); // 关闭webSocket链接
              }
            }
          }
        });
      });

      function webSocket() {
        // 创建webScoket对象 此时就会去连接到服务器
        // ws 请求的所有连接均会触发websocket 如ws://127.0.0.1:3000/ws
        ws = new WebSocket('ws://127.0.0.1:3000');

        // 客户端接收到的信息
        ws.onmessage = function(message) {
          console.log(`接收到了服务端端发送过来的消息: ${message.data}`);
        };

        // 关闭websocket
        ws.onclose = function(evt) {
          console.log('关闭websocket');
        };

        // websocket 发生错误
        ws.onerror = function(code, msg) {
          console.log('websocket 发生错误');
        };
      }
    });
  </script>
</html>

```

## nginx 服务器中的配置

```js
server {
    listen      80;
    server_name localhost;

    gzip            on;
    gzip_min_length 1024;
    gzip_buffers    4 8k;
    gzip_types      text/css application/x-javascript application/json;

    sendfile on;

    location ^~ /static/ {
        root /path/to/ws-with-koa;
    }

    location ^~ /ws/ {
        proxy_pass         http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header   Upgrade $http_upgrade;
        proxy_set_header   Connection "upgrade";
    }

    location / {
        proxy_pass       http://127.0.0.1:3000;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

```
