一.如何对外输出及引用变量
1.简单的demo
============================================hello.js============================================
'use strict';     //启用严格模式
var s = 'Hello';
function greet(name) {
    console.log(s + ', ' + name + '!');
}
module.exports = greet; //把函数greet作为模块的输出暴露出去

============================================app.js============================================
'use strict';
var greet = require('./hello'); // 引入hello模块: 不要忘了写相对目录!
var s = 'Michael';
greet(s); // Hello, Michael!


二.基本模板及使用
1.global： Node.js环境中，也有唯一的全局对象

2.process也是Node.js提供的一个对象，它代表当前Node.js进程
  process === global.process;   //true
  process.version;  //'v8.11.4'
  process.platform;  //'win32'
  process.arch; //'x64'
  process.cwd(); //'C:\\Users\\ZXS\\Desktop\\NodeJS学习笔记\\demo'
  process.chdir('/private/tmp'); // 切换当前工作目录

3.process简单运用代码

//判断JavaScript执行环境
if (typeof(window) === 'undefined') {
  console.log('node.js');
} else {
  console.log('browser');
}

// process.nextTick()将在下一轮事件循环中调用:
process.nextTick(function () {
  console.log('nextTick callback!');
});
console.log('nextTick was set!');


// 程序即将退出时的回调函数:
process.on('exit', function (code) {
  console.log('about to exit with code: ' + code);
});

三.fs模块
Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。

1.文件的读取
当正常读取时，err参数为null，data参数为读取到的String。
当读取发生错误时，err参数代表一个错误对象，data为undefined。

======================================异步读取文本文件======================================
var fs = require('fs');
fs.readFile('sample.txt', 'utf-8', function (err, data) {
    if (err) {
        console.log(err);
    } else {
        console.log(data);
    }
});

======================================同步读取图像等二进制文件======================================
当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。
在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。

var fs = require('fs');
fs.readFile('sample.png', function (err, data) {
    if (err) {
        console.log(err);
    } else {
        console.log(data);
        console.log(data.length + ' bytes');
    }
});

=================Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：=================
var text = data.toString('utf-8');
console.log(text);

=================把一个String转换成Buffer=================
var buf = Buffer.from(text, 'utf-8');
console.log(buf);

======================================同步读文件======================================
如果同步读取文件发生错误，则需要用try...catch捕获该错误：
try {
    var data = fs.readFileSync('sample.txt', 'utf-8');
    console.log(data);
} catch (err) {
    // 出错了
}


2.写文件
writeFile()的参数依次为文件名、数据和回调函数。
如果传入的数据是String，默认按UTF-8编码写入文本文件，
如果传入的参数是Buffer，则写入的是二进制文件。

======================================异步写入文件======================================
var fs = require('fs');
var data = 'Hello, Node.js';
fs.writeFile('output.txt', data, function (err) {
    if (err) {
        console.log(err);
    } else {
        console.log('ok.');
    }
});


======================================同步写入文件======================================
var fs = require('fs');
var data = 'Hello, Node.js';
fs.writeFileSync('output.txt', data);


3.如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：

======================================fs.stat()获取文件信息======================================
var fs = require('fs');
fs.stat('sample.txt', function (err, stat) {
    if (err) {
        console.log(err);
    } else {
        // 是否是文件:
        console.log('isFile: ' + stat.isFile());
        // 是否是目录:
        console.log('isDirectory: ' + stat.isDirectory());
        if (stat.isFile()) {
            // 文件大小:
            console.log('size: ' + stat.size);
            // 创建时间, Date对象:
            console.log('birth time: ' + stat.birthtime);
            // 修改时间, Date对象:
            console.log('modified time: ' + stat.mtime);
        }
    }
});


4.总结：
绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码
服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码



四.stream 支持“流”这种数据结构
所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable
1.从文件流读取文本内容
data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。
data事件可能会有多次，每次传递的chunk是流的一部分数据。
var fs = require('fs');
// 打开一个流:
var rs = fs.createReadStream('sample.txt', 'utf-8');
rs.on('data', function (chunk) {
    console.log('DATA:')
    console.log(chunk);
});

rs.on('end', function () {
    console.log('END');
});

rs.on('error', function (err) {
    console.log('ERROR: ' + err);
});

3.要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：
var fs = require('fs');

var ws1 = fs.createWriteStream('output1.txt', 'utf-8');
ws1.write('使用Stream写入文本数据...\n');
ws1.write('END.');
ws1.end();

var ws2 = fs.createWriteStream('output2.txt');
ws2.write(new Buffer('使用Stream写入二进制数据...\n', 'utf-8'));
ws2.write(new Buffer('END.', 'utf-8'));
ws2.end();

4.所有的数据自动从Readable流进入Writable流，这种操作叫pipe。
Readable流有一个pipe()方法，就是用来干这件事的
var fs = require('fs');
var rs = fs.createReadStream('sample.txt');
var ws = fs.createWriteStream('copied.txt');
rs.pipe(ws);

默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。
如果我们不希望自动关闭Writable流，需要传入参数：
readable.pipe(writable, { end: false });


五.HTTP模块
request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；
response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。

1.实现一个简单的HTTP服务器程序
// 导入http模块:
var http = require('http');

// 创建http server，并传入回调函数:
var server = http.createServer(function (request, response) {
    // 回调函数接收request和response对象,
    // 获得HTTP请求的method和url:
    console.log(request.method + ': ' + request.url);
    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:
    response.writeHead(200, {'Content-Type': 'text/html'});
    // 将HTTP响应的HTML内容写入response:
    response.end('<h1>Hello world!</h1>');
});

// 让服务器监听8080端口:
server.listen(8080);

console.log('Server is running at http://127.0.0.1:8080/');

2.文件服务器
url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象
var url = require('url');
console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));

Url {
  protocol: 'http:',   //协议
  slashes: true,  //斜线
  auth: 'user:pass',  //作者
  host: 'host.com:8080',
  port: '8080',
  hostname: 'host.com',
  hash: '#hash',
  search: '?query=string',
  query: 'query=string',
  pathname: '/path/to/file',
  path: '/path/to/file?query=string',
  href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' }

处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：
var path = require('path');
// 解析当前目录:
var workDir = path.resolve('.'); 
// 组合完整的文件路径:当前目录+'pub'+'index.html':
var filePath = path.join(workDir, 'pub', 'index.html');
console.log('workDir',workDir);   // '/Users/michael'
console.log('filePath',filePath); // '/Users/michael/pub/index.html'

简单实例代码如下(一个简单的服务器程序)
var
    fs = require('fs'),
    url = require('url'),
    path = require('path'),
    http = require('http');

// 从命令行参数获取root目录，默认是当前目录:
console.log('process.argv',process.argv);
console.log('process.argv[2]',process.argv[2]);
var root = path.resolve(process.argv[2] || '.');

console.log('Static root dir: ' + root);

// 创建服务器:
var server = http.createServer(function (request, response) {
    // 获得URL的path，类似 '/css/bootstrap.css':
    var pathname = url.parse(request.url).pathname;
    // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':
    var filepath = path.join(root, pathname);
    // 获取文件状态:
    fs.stat(filepath, function (err, stats) {
        if (!err && stats.isFile()) {
            // 没有出错并且文件存在:
            console.log('200 ' + request.url);
            // 发送200响应:
            response.writeHead(200);
            // 将文件流导向response:
            fs.createReadStream(filepath).pipe(response);
        } else if(!err && stats.isDirectory()){
          // 如果遇到请求的路径是目录，则自动在目录下依次搜索index.html、default.html，如果找到了，就返回HTML文件的内容
              console.log('200 '+ request.url);
              response.writeHead(200);
              let files = fs.readdirSync(filepath);
              console.log('files888',files)
              files.forEach(v => {
                if(v==='index.html'){
                  fs.createReadStream(path.join(filepath, 'index.html')).pipe(response); 
                }else if(v==='default.html'){
                  fs.createReadStream(path.join(filepath, 'default.html')).pipe(response); 
                }
              });
          }else {
            // 出错了或者文件不存在:
            console.log('404 ' + request.url);
            // 发送404响应:
            response.writeHead(404);
            response.end('404 Not Found');
        }
    });
});

server.listen(8080);
console.log('Server is running at http://127.0.0.1:8080/');


六.crypto模块的目的是为了提供通用的加密和哈希算法。
Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。

const crypto = require('crypto');
const hash = crypto.createHash('md5');
// 可任意多次调用update():
hash.update('Hello, world!');
hash.update('Hello, nodejs!');

console.log(hash.digest('hex')); // 7e1977739c748beac0c0fd14fd26a544


==================================Web开发技术选型==================================
一.koa   -- koa2版本
1.koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。

二.koa的安装及使用
1.npm install koa 

2.koa简单代码示例
// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:
const Koa = require('koa');

// 创建一个Koa对象表示web app本身:
const app = new Koa();

// 对于任何请求，app将调用该异步函数处理请求：
app.use(async (ctx, next) => {
    await next();
    ctx.response.type = 'text/html';
    ctx.response.body = '<h1>Hello, koa2!</h1>';
});

// 在端口3000监听:
app.listen(3000);
console.log('app started at port 3000...');


3.执行多个异步函数示例
参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数。
koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。
我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。
ctx对象有一些简写的方法，例如ctx.url相当于ctx.request.url，ctx.type相当于ctx.response.type。
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx, next) => {
    console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印URL
    await next(); // 调用下一个middleware
});

app.use(async (ctx, next) => {
    const start = new Date().getTime(); // 当前时间
    await next(); // 调用下一个middleware
    const ms = new Date().getTime() - start; // 耗费时间
    console.log(`Time: ${ms}ms`); // 打印耗费时间
});

app.use(async (ctx, next) => {
    await next();
    ctx.response.type = 'text/html';
    ctx.response.body = '<h1>Hello, koa2!</h1>';
});

// 在端口3000监听:
app.listen(3000);
console.log('app started at port 3000...');


二.处理URL 并实现页面分离
1.单纯使用koa2实现对各类不同的URL的处理
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx, next) => {
    if (ctx.request.path === '/') {
        ctx.response.body = 'index page';
    } else {
        await next();
    }
});

app.use(async (ctx, next) => {
    if (ctx.request.path === '/test') {
        ctx.response.body = 'TEST page';
    } else {
        await next();
    }
});

app.use(async (ctx, next) => {
    if (ctx.request.path === '/error') {
        ctx.response.body = 'ERROR page';
    } else {
        await next();
    }
});

2.koa-router 为了处理URL，我们需要引入koa-router这个middleware，让它负责处理URL映射。
npm install  koa-router #安装
注意导入koa-router的语句最后的()是函数调用：注意require('koa-router')返回的是函数:
const router = require('koa-router')()
const Koa = require('koa');

// 注意require('koa-router')返回的是函数:
const router = require('koa-router')();

const app = new Koa();

// log request URL:
app.use(async (ctx, next) => {
    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
    await next();
});

// add url-route:
router.get('/hello/:name', async (ctx, next) => {
    var name = ctx.params.name;
    ctx.response.body = `<h1>Hello, ${name}!</h1>`;
    //示范url http://127.0.0.1:3000/hello/mmmddd
});

router.get('/', async (ctx, next) => {
    ctx.response.body = '<h1>Index</h1>';
});

// add router middleware:
app.use(router.routes());

app.listen(3000);
console.log('app started at port 3000...');

3.koa-bodyparser处理post请求
用router.get('/path', async fn)处理的是get请求。如果要处理post请求，可以用router.post('/path', async fn)。
解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中
npm install koa-bodyparser -S #安装
app.use(bodyParser()); #使用

4.一个简单的初步案例
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const router = require('koa-router')();
const app = new Koa();
// log request URL:
app.use(async (ctx, next) => {
console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
await next();
});
// parse request body:
app.use(bodyParser());
// add url-route:
router.get('/hello/:name', async (ctx, next) => {
var name = ctx.params.name;
ctx.response.body = `<h1>Hello, ${name}!</h1>`;
});
router.get('/', async (ctx, next) => {
ctx.response.body = `<h1>Index</h1>
<form action="/signin" method="post">
<p>Name: <input name="name" value="koa"></p>
<p>Password: <input name="password" type="password"></p>
<p><input type="submit" value="Submit"></p>
</form>`;
});
router.post('/signin', async (ctx, next) => {
var
name = ctx.request.body.name || '',
password = ctx.request.body.password || '';
console.log(`signin with name: ${name}, password: ${password}`);
if (name === 'koa' && password === '12345') {
ctx.response.body = `<h1>Welcome, ${name}!</h1>`;
} else {
ctx.response.body = `<h1>Login failed!</h1>
<p><a href="/">Try again</a></p>`;
}
});
// add router middleware:
app.use(router.routes());
app.listen(3000);
console.log('app started at port 3000...');

5.实现代码逻辑分离

1.app.js
const Koa = require('koa');
const bodyParser = require('koa-bodyparser');
const controller = require('./controller');
const app = new Koa();

// 打印出请求的url 开始启动web服务功能:
app.use(async (ctx, next) => {
    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
    await next();
});

// 解析请求体:
app.use(bodyParser());

// 加入控制器:
app.use(controller());

app.listen(3000);
console.log('app started at port 3000...');

2.hello.js   业务逻辑代码

var fn_hello = async (ctx, next) => {
    var name = ctx.params.name;
    ctx.response.body = `<h1>Hello, ${name}!</h1>`;
};

module.exports = {
    'GET /hello/:name': fn_hello //暴露出对于的url及方法
};

3.index.js   业务逻辑代码
var fn_index = async (ctx, next) => {
    ctx.response.body = `<h1>Index</h1>
        <form action="/signin" method="post">
            <p>Name: <input name="name" value="koa"></p>
            <p>Password: <input name="password" type="password"></p>
            <p><input type="submit" value="Submit"></p>
        </form>`;
};

var fn_signin = async (ctx, next) => {
    var
        name = ctx.request.body.name || '',
        password = ctx.request.body.password || '';
    console.log(`signin with name: ${name}, password: ${password}`);
    if (name === 'koa' && password === '12345') {
        ctx.response.body = `<h1>Welcome, ${name}!</h1>`;
    } else {
        ctx.response.body = `<h1>Login failed!</h1>
        <p><a href="/">Try again</a></p>`;
    }
};

module.exports = {
    //暴露出对于的url及方法
    'GET /': fn_index,
    'POST /signin': fn_signin
};

4.controller.js 
const fs = require('fs');
// add url-route in /controllers:

function addMapping(router, mapping) {
    for (var url in mapping) {
        if (url.startsWith('GET ')) {
            var path = url.substring(4);
            router.get(path, mapping[url]);
            console.log(`register URL mapping: GET ${path}`);
        } else if (url.startsWith('POST ')) {
            var path = url.substring(5);
            router.post(path, mapping[url]);
            console.log(`register URL mapping: POST ${path}`);
        } else if (url.startsWith('PUT ')) {
            var path = url.substring(4);
            router.put(path, mapping[url]);
            console.log(`register URL mapping: PUT ${path}`);
        } else if (url.startsWith('DELETE ')) {
            var path = url.substring(7);
            router.del(path, mapping[url]);
            console.log(`register URL mapping: DELETE ${path}`);
        } else {
            console.log(`invalid URL: ${url}`);
        }
    }
}

function addControllers(router, dir) {
    fs.readdirSync(__dirname + '/' + dir).filter((f) => {
        return f.endsWith('.js'); //获取说有的js文件
    }).forEach((f) => {
        console.log(`process controller: ${f}...`);
        let mapping = require(__dirname + '/' + dir + '/' + f);
        addMapping(router, mapping);
    });
}

module.exports = function (dir) {
    let
        controllers_dir = dir || 'controllers',
        router = require('koa-router')();
    addControllers(router, controllers_dir);
    return router.routes();   //暴露出router.routes()给app.js使用
};





三.Nunjucks
Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端
因为Nunjucks就是用JavaScript重新实现了jinjia2。
1.是一个模板引擎,
2.对特殊字符要转义，避免受到XSS攻击。
3.对不同类型的变量要格式化
4.Nunjucks默认就使用同步IO读取模板文件
设置noCache: false这个参数。 模板文件最多读取一次，就会放在内存中

4.使用
npm install nunjucks -S #安装

- app.js
const nunjucks = require('nunjucks');

function createEnv(path, opts) {
    var
        autoescape = opts.autoescape === undefined ? true : opts.autoescape,
        noCache = opts.noCache || false,
        watch = opts.watch || false,
        throwOnUndefined = opts.throwOnUndefined || false,
        env = new nunjucks.Environment( 
          //env表示模板引擎对象
            new nunjucks.FileSystemLoader(path, {
              //创建一个文件系统加载器，从views目录读取模板
                noCache: noCache,
                watch: watch,
            }), {
                autoescape: autoescape,
                throwOnUndefined: throwOnUndefined
            });
    if (opts.filters) {
        for (var f in opts.filters) {
            env.addFilter(f, opts.filters[f]);
        }
    }
    return env;
}

var env = createEnv('views', {
    watch: true,
    filters: {
        hex: function (n) {
            return '0x' + n.toString(16);
        }
    }
});

//传入view和model两个参数，并返回字符串。
var s = env.render('hello.html', {
    name: '<Nunjucks>',
    fruits: ['Apple', 'Pear', 'Banana'],
    count: 12000
});

console.log(s);

console.log(env.render('extend.html', {
    header: 'Hello',
    body: 'bla bla bla...'
}));

/views/hello.html
<html>
<head>
    <title>Hello {{ name }}</title>
</head>
<body>
    <h3>Fruits List</h3>
    {% for f in fruits %}
    <p>{{ f }}</p>
    {% endfor %}
    <p>Total: {{ count|hex }}</p>
</body>
</html>

/views/base.html
<html><body>
{% block header %} <h3>Unnamed</h3> {% endblock %}
{% block body %} <div>No body</div> {% endblock %}
{% block footer %} <div>copyright</div> {% endblock %}
</body>

/views/extend.html
{% extends 'base.html' %}
{% block header %}<h1>{{ header }}</h1>{% endblock %}
{% block body %}<p>{{ body }}</p>{% endblock %}


四.使用MVC
npm i mime -S #安装mime依赖 用于获取文件类型
npm i mz -S #安装mz依赖 封装了fs对应的函数，并改为Promise,用await调用mz的函数，而不需要任何回调
process.env.NODE_ENV === 'production';生产环境上必须配置环境变量NODE_ENV = 'production'，而开发环境不需要配置


1.app.js 
const Koa = require('koa');

const bodyParser = require('koa-bodyparser');

const controller = require('./controller');

const templating = require('./templating');

const app = new Koa();

const isProduction = process.env.NODE_ENV === 'production';

app.use(async (ctx, next) => {
    //web服务程序开始 返回响应时间
    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
    var
        start = new Date().getTime(),
        execTime;
    await next();
    execTime = new Date().getTime() - start;
    ctx.response.set('X-Response-Time', `${execTime}ms`);
});

if (! isProduction) {
    //如果是在开发环境下
    let staticFiles = require('./static-files');
    app.use(staticFiles('/static/', __dirname + '/static'));  //去获取必要的静态资源
}

// 解析请求体
app.use(bodyParser());

// 输出视图: 这里仅仅给ctx定义了render方法可以生成视图
app.use(templating('views', {
    noCache: !isProduction,
    watch: !isProduction
}));

// url控制器解析 实际生成视图
app.use(controller());

app.listen(3000); //网络端口监听
console.log('app started at port 3000...');


2.controller.js

const fs = require('fs');

// add url-route in /controllers:

function addMapping(router, mapping) {
    //对路径及访问该路径应该执行的逻辑做处理
    for (var url in mapping) {
        if (url.startsWith('GET ')) {
            var path = url.substring(4);
            router.get(path, mapping[url]);
            console.log(`register URL mapping: GET ${path}`);
        } else if (url.startsWith('POST ')) {
            var path = url.substring(5);
            router.post(path, mapping[url]);
            console.log(`register URL mapping: POST ${path}`);
        } else if (url.startsWith('PUT ')) {
            var path = url.substring(4);
            router.put(path, mapping[url]);
            console.log(`register URL mapping: PUT ${path}`);
        } else if (url.startsWith('DELETE ')) {
            var path = url.substring(7);
            router.del(path, mapping[url]);
            console.log(`register URL mapping: DELETE ${path}`);
        } else {
            console.log(`invalid URL: ${url}`);
        }
    }
}

function addControllers(router, dir) {
    fs.readdirSync(__dirname + '/' + dir).filter((f) => {
        return f.endsWith('.js');  //过滤出js文件 返回一个js文件数组
    }).forEach((f) => {
        console.log(`process controller: ${f}...`);
        let mapping = require(__dirname + '/' + dir + '/' + f);  //获取js文件中对外暴露的模块方法
        addMapping(router, mapping);
    });
}

module.exports = function (dir) {
    let
        controllers_dir = dir || 'controllers',
        router = require('koa-router')();
    addControllers(router, controllers_dir);
    return router.routes();  //返回后在app.js中可以 app.use(controller());这么使用
};

3.templating.js 

const nunjucks = require('nunjucks');

function createEnv(path, opts) {
    var
        autoescape = opts.autoescape === undefined ? true : opts.autoescape,
        noCache = opts.noCache || false,
        watch = opts.watch || false,
        throwOnUndefined = opts.throwOnUndefined || false,
        env = new nunjucks.Environment(
            new nunjucks.FileSystemLoader(path, {
                noCache: noCache,
                watch: watch,
            }), {
                autoescape: autoescape,
                throwOnUndefined: throwOnUndefined
            });
    if (opts.filters) {
        for (var f in opts.filters) {
            env.addFilter(f, opts.filters[f]);
        }
    }
    return env;
}

function templating(path, opts) {
    var env = createEnv(path, opts);
    return async (ctx, next) => {
        ctx.render = function (view, model) {
            //ctx 本省是没有render方法的 这里给它加上render方法
            //Object.assign({}, ctx.state || {}, model || {})  使程序便于拓展
            console.log('view',view);
            console.log('model',model);

            ctx.response.body = env.render(view, Object.assign({}, ctx.state || {}, model || {})); //把字符串返回给响应体
            ctx.response.type = 'text/html';
        };
        await next();
    };
}

module.exports = templating;


4.static-file.js 
const path = require('path');
const mime = require('mime');
const fs = require('mz/fs');

function staticFiles(url, dir) {
    return async (ctx, next) => {
        //有响应就会执行
        let rpath = ctx.request.path;  //获取请求路径
        console.log('请求的路径',rpath);
        if (rpath.startsWith(url)) { 
            //如果路径中包含了url参数字符串
            let fp = path.join(dir, rpath.substring(url.length)); //获取文件所在路径
            console.log('获取文件所在路径',fp);
            if (await fs.exists(fp)) {
                //如果这个文件时存在的
                ctx.response.type = mime.getType(rpath); //响应文件类型
                ctx.response.body = await fs.readFile(fp); //读取文件内容 传给 响应体
            } else {
                ctx.response.status = 404; //如果文件不存在则返回404
            }
        } else {
            await next(); //等待下一个异步函数执行
        }
    };
}

module.exports = staticFiles;  //暴露出staticFiles方法

5.index.js
// index:

module.exports = {
    'GET /': async (ctx, next) => {
        ctx.render('index.html', {
            title: 'Welcome'
        });
    }
};

6.signin.js 
// sign in:

module.exports = {
    'POST /signin': async (ctx, next) => {
        var
            email = ctx.request.body.email || '',
            password = ctx.request.body.password || '';
        if (email === 'admin@example.com' && password === '123456') {
            console.log('signin ok!');
            ctx.render('signin-ok.html', {
                title: 'Sign In OK',
                name: 'Mr Node'
            });
        } else {
            console.log('signin failed!');
            ctx.render('signin-failed.html', {
                title: 'Sign In Failed'
            });
        }
    }
};

7.其他html模板文件
base.html
index.html
signin-failed.html
signin-ok.html


==================================mysql访问数据库==================================
一.使用Sequelize
1.安装依赖
npm install mysql -S #安装mysql数据库驱动
npm install sequelize -S #安装sequelize可简化对mysql数据库的操作
Sequelize 是一个基于 promise 的 Node.js ORM, 目前支持 Postgres, MySQL, SQLite 和 Microsoft SQL Server. 它具有强大的事务支持, 关联关系, 读取和复制等功能.
$ npm install --save pg pg-hstore
$ npm install --save mysql2
$ npm install --save sqlite3
$ npm install --save tedious // MSSQL

ORM技术 Object-Relational Mapping  Object-Relational Mapping 返回json对象无需再做低层处理



2.创建数据库(SQL语句)
use test;
create table pets (
    id varchar(50) not null,
    name varchar(100) not null,
    gender bool not null,
    birth varchar(10) not null,
    createdAt bigint not null,
    updatedAt bigint not null,
    version bigint not null,
    primary key (id)
) engine=innodb;


3.Sequelize简单实用案例
const Sequelize = require('sequelize');
const sequelize = new Sequelize('test', 'root', 'root', {
  host: 'localhost',
  //Dialect needs to be explicitly supplied as of v4.0.0 报错解决
  dialect: 'mysql',// pick one of 'mysql','sqlite','postgres','mssql',

  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  },

  // 仅限 SQLite
  storage: 'path/to/database.sqlite',

  // 请参考 Querying - 查询 操作符 章节
  operatorsAliases: false
});

const Pet = sequelize.define('pet', {
  id: {
      type: Sequelize.STRING(50),
      primaryKey: true
  },
  name: Sequelize.STRING(100),
  gender: Sequelize.BOOLEAN,
  birth: Sequelize.STRING(10),
  createdAt: Sequelize.BIGINT,
  updatedAt: Sequelize.BIGINT,
  version: Sequelize.BIGINT
});


var now = Date.now();

sequelize.sync()
  .then(() => Pet.create({
    id: 'g-' + now,
    name: 'Gaffey',
    gender: false,
    birth: '2007-07-07',
    createdAt: now,
    updatedAt: now,
    version: 0
  }))
  .then(jane => {
    console.log('jane',jane,jane.toJSON());
  });


2.教程中的使用案例 await 可直接返回结果
如果要更新数据，可以对查询到的实例调用save()方法：
如果要删除数据，可以对查询到的实例调用destroy()方法：

const Sequelize = require('sequelize');

const config = require('./config');

console.log('init sequelize...');

//对链接数据库信息进行配置
var sequelize = new Sequelize(config.database, config.username, config.password, {
    host: config.host,
    dialect: 'mysql',
    pool: {
        max: 5,
        min: 0,
        idle: 30000
    }
});

//定义或创建一个pet的数据表
var Pet = sequelize.define('pet', {
    id: {
        type: Sequelize.STRING(50),
        primaryKey: true
    },
    name: Sequelize.STRING(100),
    gender: Sequelize.BOOLEAN,
    birth: Sequelize.STRING(10),
    createdAt: Sequelize.BIGINT,
    updatedAt: Sequelize.BIGINT,
    version: Sequelize.BIGINT
}, {
        timestamps: false //关闭Sequelize的自动添加timestamp的功能
    });

var now = Date.now();  //获取一个时间戳

Pet.create({
    id: 'g-' + now,
    name: 'Gaffey',
    gender: false,
    birth: '2007-07-07',
    createdAt: now,
    updatedAt: now,
    version: 0
}).then(function (p) {
    console.log('created.' + JSON.stringify(p)); //打印出一个json字符串
}).catch(function (err) {
    console.log('failed: ' + err);
});

(async () => {
    var dog = await Pet.create({
        id: 'd-' + now,
        name: 'Odie',
        gender: false,
        birth: '2008-08-08',
        createdAt: now,
        updatedAt: now,
        version: 0
    });  //await  可直接返回结果
    console.log('created: ' + JSON.stringify(dog));
})();

(async () => {
    //对数据进行查询
    var pets = await Pet.findAll({
        where: {
            name: 'Gaffey'
        }
    });
    console.log(`find ${pets.length} pets:`);
    for (let p of pets) {
      //循环遍历查询结果
        console.log(JSON.stringify(p));
        console.log('update pet...');
        p.gender = true;
        p.updatedAt = Date.now();
        p.version ++;
        await p.save();   //对记录进行更新
        if (p.version === 3) {
            await p.destroy(); //对记录进行删除
            console.log(`${p.name} was destroyed.`);
        }
    }
})();

运行nodejs打印出来的SQL语句
Executing (default): INSERT INTO `pets` (`id`,`name`,`gender`,`birth`,`createdAt`,`updatedAt`,`version`) VALUES ('g-1471961204219','Gaffey',false,'2007-07-07',1471961204219,1471961204219,0);

3.Model
我们把通过sequelize.define()返回的Pet称为Model，它表示一个数据模型。
通过Pet.findAll()返回的一个或一组对象称为Model实例，每个实例都可以直接通过JSON.stringify序列化为JSON字符串。
JSON对象相比，多了一些由Sequelize添加的方法，比如save()和destroy()。调用这些方法我们可以执行更新或者删除操作。


二.建立Model
-统一主键，名称必须是id，类型必须是STRING(50)；
-主键可以自己指定，也可以由框架自动生成（如果为null或undefined）；
-所有字段默认为NOT NULL，除非显式指定；
-统一timestamp机制，每个Model必须有createdAt、updatedAt和version，分别记录创建时间、修改时间和版本号。其中，createdAt和updatedAt以BIGINT存储时间戳，最大的好处是无需处理时区，排序方便。version每次修改时自增。




==================================mocha单元测试==================================
mocha是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。

一.编写测试
1.一个简单的求和函数测试案例 及其原理
// hello.js 一个求和函数
module.exports = function (...rest) {
    var sum = 0;
    for (let n of rest) {
        sum += n;
    }
    return sum;
};

//对这个函数进行测试 使用Node.js提供的assert模块进行断言
const assert = require('assert');
const sum = require('./hello');

assert.strictEqual(sum(), 0);
assert.strictEqual(sum(1), 1);
assert.strictEqual(sum(1, 2), 3);
assert.strictEqual(sum(1, 2, 3), 6);

2.安装mocha的依赖包
npm install mocha -D 

3.编写测试程序 hello-test.js内容如下：
这里我们使用mocha默认的BDD-style的测试。describe可以任意嵌套，以便把相关测试看成一组测试。

const assert = require('assert');

const sum = require('../hello');

describe('#hello.js', () => {

    describe('#sum()', () => {
        //每个it("name", function() {...})就代表一个测试
        it('sum() should return 0', () => {
            assert.strictEqual(sum(), 0);
        });

        it('sum(1) should return 1', () => {
            assert.strictEqual(sum(1), 1);
        });

        it('sum(1, 2) should return 3', () => {
            assert.strictEqual(sum(1, 2), 3);
        });

        it('sum(1, 2, 3) should return 6', () => {
            assert.strictEqual(sum(1, 2, 3), 6);
        });
    });
});



4.用mocha运行测试了

// hello.js文件编写
console.log('init hello.js...');

// a simple function:
// > sum(1, 2, 3)
// 6
module.exports = function (...rest) {
    var sum = 0;
    for (let n of rest) {
        sum += n;
    }
    return sum;
};

//hello-test.js文件编写
//在测试前初始化资源，测试后释放资源是非常常见的。mocha提供了before、after、beforeEach和afterEach来实现这些功能。
实例中输出是这样的
before:
  beforeEach:
      √ sum() should return 0
  afterEach.
  beforeEach:
      √ sum(1) should return 1
  afterEach.
  beforeEach:
      √ sum(1, 2) should return 3
  afterEach.
  beforeEach:
      √ sum(1, 2, 3) should return 6
  afterEach.
after.

const assert = require('assert');

const sum = require('../hello');

describe('#hello.js', () => {

    describe('#sum()', () => {
        before(function () {
            console.log('before:');
        });

        after(function () {
            console.log('after.');
        });

        beforeEach(function () {
            console.log('  beforeEach:');
        });

        afterEach(function () {
            console.log('  afterEach.');
        });

        it('sum() should return 0', () => {
            assert.strictEqual(sum(), 0);
        });

        it('sum(1) should return 1', () => {
            assert.strictEqual(sum(1), 1);
        });

        it('sum(1, 2) should return 3', () => {
            assert.strictEqual(sum(1, 2), 3);
        });

        it('sum(1, 2, 3) should return 6', () => {
            assert.strictEqual(sum(1, 2, 3), 6);
        });
    });
});


mocha默认会执行test目录下的所有测试，不要去改变默认目录。
在package.json文件中配置如下

"devDependencies": {
    "mocha": "^5.2.0"
  },
  "scripts": {
    "test": "mocha"
  },

5.运行 npm test 



二.异步测试
1.编写 hello.js 并对外暴露一个异步函数
console.log('init hello.js...');
const fs = require('mz/fs');
// 输出一个简单的异步函数
module.exports = async () => {
    let expression = await fs.readFile('./data.txt', 'utf-8'); //异步读取文本内容
    let fn = new Function('return ' + expression);
    let r = fn();
    console.log(`Calculate: ${expression} = ${r}`);
    return r;  //返回15
};

2.编写 await-test.js异步测试

const assert = require('assert');

const hello = require('../hello');

describe('#async hello', () => {
    describe('#asyncCalculate()', () => {
        // 进行异步测试需要传入done参数 复杂写法
        it('#async with done', (done) => {
            (async function () {
                try {
                    let r = await hello();
                    assert.strictEqual(r, 15);
                    done();
                } catch (err) {
                    done(err);
                }
            })();
        });

        //进行异步测试的简洁写法 推荐
        it('#async function', async () => {
            let r = await hello();
            assert.strictEqual(r, 15);
        });

        //进行同步测试

        it('#sync function', () => {
            assert(true);
        });
    });
});

三.Http测试
1.安装测试模块supertest
npm i supertest -D
利用mocha的异步测试，配合supertest，我们可以用简单的代码编写端到端的HTTP自动化测试

2.编写http测试用例
====app.js====
const Koa = require('koa');

const app = new Koa();

app.use(async (ctx, next) => {
    const start = new Date().getTime();
    await next();
    const ms = new Date().getTime() - start;
    //打印出请求方法+请求连接+响应时间
    console.log(`${ctx.request.method} ${ctx.request.url}: ${ms}ms`);
    ctx.response.set('X-Response-Time', `${ms}ms`);
});

app.use(async (ctx, next) => {
    var name = ctx.request.query.name || 'world';
    ctx.response.type = 'text/html';
    ctx.response.body = `<h1>Hello, ${name}!</h1>`;  //把连接参数通过响应文本输出
});

module.exports = app; //暴露出app 方便添加测试

====start.js====
//用于启动文本运用
const app = require('./app');

app.listen(3000);
console.log('app started at port 3000...');

====app-test.js====
//Http测试异步测试文件
const
    request = require('supertest'),
    app = require('../app');  //引入web服务程序

describe('#test koa app', () => {

    let server = app.listen(9900);  //让app实例监听在9900端口上，并且获得返回的server实例。

    describe('#test server', () => {

        it('#test GET /', async () => {
            let res = await request(server) //构造一个GET请求，发送给koa的应用，然后获得响应
                .get('/')
                //用supertest提供的expect()更方便地断言响应的HTTP代码、返回内容和HTTP头。断言HTTP头时可用使用正则表达式
                .expect('Content-Type', /text\/html/)
                .expect(200, '<h1>Hello, world!</h1>');
        });

        it('#test GET /path?name=Bob', async () => {
            let res = await request(server)  //构造一个GET请求，发送给koa的应用，然后获得响应
                .get('/path?name=Bob')
                .expect('Content-Type', /text\/html/)
                .expect(200, '<h1>Hello, Bob!</h1>');  //当所有测试运行结束后，app实例会自动关闭，无需清理。
        });
    });
});


==================================WebSocket==================================
一.什么是WebSocket
1.WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。
2.HTTP协议其实也能实现，比如用轮询或者Comet
3.HTML5推出了WebSocket标准，让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。

4.WebSocket协议
-WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求
GET ws://localhost:3000/ws/chat HTTP/1.1
Host: localhost
Upgrade: websocket
Connection: Upgrade
Origin: http://localhost:3000
Sec-WebSocket-Key: client-random-string
Sec-WebSocket-Version: 13
该请求和普通的HTTP请求有几点不同：

GET请求的地址不是类似/path/，而是以ws://开头的地址；
请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；
Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；
Sec-WebSocket-Version指定了WebSocket的协议版本。

-服务器如果接受该请求，就会返回如下响应：
该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。
版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。

5.WebSocket实现原理
实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。
浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。

6.服务器端实现WebSocket
由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。

二.一个简单的WebSocket实现案例
1.安装依赖
cnpm i ws -S

2.app.js实例代码
// 导入WebSocket模块
const WebSocket = require('ws'); 

// 引用Server类
const WebSocketServer = WebSocket.Server;

// 实例化
const wss = new WebSocketServer({
    port: 3000  // 在3000端口上打开一个WebSocket Server
});


// 如果有WebSocket请求接入 wws对象可以响应connection事件来处理这个WebSocket
wss.on('connection', function (ws) {
    console.log(`[SERVER] connection()`);
    ws.on('message', function (message) {
        console.log(`[SERVER] Received: ${message}`);  //服务器接收到的信息
        setTimeout(() => {
            ws.send(`What's your name?`, (err) => { // 服务器发送信息
                if (err) {
                    console.log(`[SERVER] error: ${err}`);
                }
            });
        }, 1000);
    })
});

console.log('ws server started at port 3000...');

// 客户端测试代码 实际代码中并不需要 仅用于测试

let count = 0;

let ws = new WebSocket('ws://localhost:3000/ws/chat');

ws.on('open', function () {
    console.log(`[CLIENT] open()`);
    ws.send('Hello!');
});

ws.on('message', function (message) {
    console.log(`[CLIENT] Received: ${message}`);  // 客户端接收到的信息
    count++;
    if (count > 3) {
        ws.send('Goodbye!'); //客户端发送的信息
        ws.close();
    } else {
        setTimeout(() => {
            ws.send(`Hello, I'm Mr No.${count}!`); // 客户端发送的信息
        }, 1000);
    }
});

3.创建WebSocket连接(测试方法)
执行JavaScript代码的浏览器Console，依次输入代码：
// 打开一个WebSocket:
var ws = new WebSocket('ws://localhost:3000/test');
// 响应onmessage事件:
ws.onmessage = function(msg) { console.log(msg); };
// 给服务器发送一个字符串:
ws.send('Hello!');

4.同源策略
从上面的测试可以看出，WebSocket协议本身不要求同源策略（Same-origin Policy），也就是某个地址为http://a.com的网页可以通过WebSocket连接到ws://b.com。
但是，浏览器会发送Origin的HTTP头给服务器，服务器可以根据Origin拒绝这个WebSocket请求。所以，是否要求同源要看服务器端如何检查。


三.编写聊天室
1.koa 和 WebSocketServer 可以共用一个端口
2.把WebSocketServer绑定到同一个端口的关键代码是先获取koa创建的http.Server的引用，再根据http.Server创建WebSocketServer：

// koa app的listen()方法返回http.Server:
let server = app.listen(3000);

// 创建WebSocketServer:
let wss = new WebSocketServer({
    server: server
});

3.配置反向代理
让 Nginx理解该连接将使用WebSocket协议
server {
    listen      80;
    server_name localhost;

    # 处理静态资源文件:
    location ^~ /static/ {
        root /path/to/ws-with-koa;
    }

    # 处理WebSocket连接:
    location ^~ /ws/ {
        proxy_pass         http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header   Upgrade $http_upgrade;
        proxy_set_header   Connection "upgrade";
    }

    # 其他所有请求:
    location / {
        proxy_pass       http://127.0.0.1:3000;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}



==================================REST==================================
一.什么是REST
1.REST就是一种设计API的模式。
2.通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。
3.把网页视为一种客户端，是REST架构可扩展的一个关键。

二.一个简单的REST实例
1.REST API规范(并不是强制要去)
REST请求仍然是标准的HTTP请求，但是，除了GET请求外，POST、PUT等请求的body是JSON数据格式，请求的Content-Type为application/json；
REST响应返回的结果是JSON数据格式，因此，响应的Content-Type也是application/json。

2.接口路由
获取所有Product的URL GET /api/products
获取某个指定的Product，例如，id为123的Product GET /api/products/123
新建一个Product使用POST请求，JSON数据包含在body中  POST /api/products
更新一个Product使用PUT请求，例如，更新id为123的Product PUT /api/products/123
删除一个Product使用DELETE请求，例如，删除id为123的Product DELETE /api/products/123
资源还可以按层次组织 获取商品的评论  GET /api/products/123/reviews
参数限制返回的结果集  GET /api/products/123/reviews?page=2&size=10&sort=time

3.用法实例
api.js 
var products = [{
    name: 'iPhone',
    price: 6999
}, {
    name: 'Kindle',
    price: 999
}];

module.exports = {
    'GET /api/products': async (ctx, next) => {
        ctx.response.type = 'application/json';
        ctx.response.body = {
            products: products
        };
    },

    'POST /api/products': async (ctx, next) => {
        var p = {
            name: ctx.request.body.name,
            price: ctx.request.body.price
        };
        products.push(p);
        ctx.response.type = 'application/json';
        ctx.response.body = p;
    }
};

app.js
const Koa = require('koa');

const bodyParser = require('koa-bodyparser');

const controller = require('./controller');

const app = new Koa();

// log request URL:
app.use(async (ctx, next) => {
    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);
    await next();
});

// parse request body:
app.use(bodyParser());

// add controller:
app.use(controller());

app.listen(3000);
console.log('app started at port 3000...');

controller.js

const fs = require('fs');

// add url-route in /controllers:

function addMapping(router, mapping) {
    for (var url in mapping) {
        if (url.startsWith('GET ')) {
            var path = url.substring(4);
            router.get(path, mapping[url]);
            console.log(`register URL mapping: GET ${path}`);
        } else if (url.startsWith('POST ')) {
            var path = url.substring(5);
            router.post(path, mapping[url]);
            console.log(`register URL mapping: POST ${path}`);
        } else if (url.startsWith('PUT ')) {
            var path = url.substring(4);
            router.put(path, mapping[url]);
            console.log(`register URL mapping: PUT ${path}`);
        } else if (url.startsWith('DELETE ')) {
            var path = url.substring(7);
            router.del(path, mapping[url]);
            console.log(`register URL mapping: DELETE ${path}`);
        } else {
            console.log(`invalid URL: ${url}`);
        }
    }
}

function addControllers(router, dir) {
    fs.readdirSync(__dirname + '/' + dir).filter((f) => {
        return f.endsWith('.js');
    }).forEach((f) => {
        console.log(`process controller: ${f}...`);
        let mapping = require(__dirname + '/' + dir + '/' + f);
        addMapping(router, mapping);
    });
}

module.exports = function (dir) {
    let
        controllers_dir = dir || 'controllers',
        router = require('koa-router')();
    addControllers(router, controllers_dir);
    return router.routes();
};


三.错误处理机制
1.如何组织URL
一个简单的方法是通过固定的前缀区分。例如，/static/开头的URL是静态资源文件，类似的，/api/开头的URL就是REST API，其他URL是普通的MVC请求。
2.错误信息是一个JSON字符串，例如：
{
    "code": "10000",
    "message": "Bad email address"
}


==================================MVVM==================================






常用api
__dirname 根目录
以同步的方式读取目录下的文件 并 过滤指定后缀名文件
fs.readdirSync(__dirname + '/' + dir).filter((f) => {
    console.log('f',f,__dirname );
    return f.endsWith('.js');
})






1.node -v # 查看node的版本
2.npm -v # 查看npm的版本
3.node --use_strict js文件名   # Node在执行该JavaScript时将使用严格模式


概念：
1.CommonJS规范：
在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突
module.exports = variable; -一个模块想要对外暴露变量（函数也是变量）
var ref = require('module_name')-就拿到了引用模块的变量。






注意：
1.文件不能命名为node.js要不然程序无法执行
2.这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。



原理性的知识点


一.NodeJS模块化实现原理

====Node.js加载了hello.js后 使用闭包原理使模板间的同名变量不冲突====
(function () {
    // 读取的hello.js代码:
    var s = 'Hello';
    var name = 'world';

    console.log(s + ' ' + name + '!');
    // hello.js代码结束
})()

====模块的输出module.exports====
// 准备module对象:
var module = {
    id: 'hello',
    exports: {}
};
var load = function (module) {
    // 读取的hello.js代码:
    function greet(name) {
        console.log('Hello, ' + name + '!');
    }

    module.exports = greet;
    return module.exports;     // hello.js代码结束并输出暴露的模块
};
var exported = load(module);
// 保存module:
save(module, exported);

====默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象{}====
给exports赋值是无效的，因为赋值后，module.exports仍然是空对象{}。
var load = function (exports, module) {
    // hello.js的文件内容
    ...
    // load函数返回:
    return module.exports;
};

var exported = load(module.exports, module);

====结论====
直接对module.exports赋值，可以应对任何情况






单词：
node 节点
strict 严格的
visual 视觉的
studio 工作室
code 代码
automator 自动机
module 模块
launch 发射 开始运用程序
require 需求
common 常见的 普通的 公共的
global 全局的 全球的
process 过程 进程
platform 平台
tick 打上勾 一瞬间
arch 拱门 结构
buffer 缓冲区
directory 目录
stream 流动
stdin 标准输入流
stdout 标准输出流
chunk 块
request 请求
response 响应
parse 解析
protocol 协议
slashes 斜线
auth 作者
resolve 决定
crypto 密码 秘密成员
digest 消化
express 表达 
plain 平原
promise 承诺
middleware 中间件
ware 制品
render 给予 提供
escape 逃脱 逃跑
environment 环境
exec 执行程序
sequelize 续集
transaction 交易
pool 水池
pet 宠物
define 定义
gender 性别
entity 实体
hooks 钩子
assert 断言
describe 描述
launch 发射
expect 期待
comet 彗星
upgrade 升级
accept 接受
socket 插座
received 收到
rest 休息 















