# 评论增删改查项目备忘

## 项目目录结构说明

```bash
config
  - config.json # 数据库配置文件 链接数据库
controllers # 各种接口的逻辑文件
migrations # sequelize-cli 使用 用于创建数据表
models # 模型文件 创建数据表 使用表 均需要
  - index.js # 所有模型的集成文件
public # 所有静态资源存放位置
seeders # 种子文件存放位置 用于添加初始化数据
template # 服务器端渲染的模板文件
app.js # 项目入口 启动文件
controller.js # 接口逻辑集成文件
test.js # 测试文件
package.json # 项目包管理文件
```

## 建立数据库连接
``` js
/** 建立连接  */
const Sequelize = require('sequelize');
/** 引入OP对象  */
const Op = Sequelize.Op;
const sequelize = new Sequelize('tsequelize', 'root', '123456', {
  host: 'localhost',
  dialect: 'mysql',
  operatorsAliases: false,
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  },
  timezone: '+08:00', // 设置时间为东八区时间
});
```

## 创建模型及新建表
* 强制创建需先删除表
>  DROP TABLE IF EXISTS `compas`;
* 创建表 users
>  CREATE TABLE IF NOT EXISTS `users` (`userId` INTEGER auto_increment , `name` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`userId`)) ENGINE=InnoDB;
* 创建表 compas
>  CREATE TABLE IF NOT EXISTS `compas` (`compId` INTEGER auto_increment , `name` VARCHAR(24), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `userId` INTEGER, PRIMARY KEY (`compId`), FOREIGN KEY (`userId`) REFERENCES `users` (`userId`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB;
* ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB
``` bash
delete是指在主键表中删除一条记录 
update 则是主键表中被参考字段的值更新

no action 表示 不做任何操作，
set null 表示在外键表中将相应字段设置为null
set default 表示设置为默认值

cascade 表示级联操作，就是说，如果主键表中被参考字段更新，外键表中也更新，主键表中的记录被删除，外键表中改行也相应删除

```
``` js
const User = sequelize.define('user', {
  userId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING,
  },
});
const Comp = sequelize.define('compa', {
  compId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING(24),
  }
});


User.hasMany(Comp, {foreignKey: 'userId' });
/** 强制创建表  */
await sequelize.sync({ force: true });
```

## Sequelize 增删改查

### 新增
* 插入一条数据
>  INSERT INTO `users` (`userId`,`name`,`createdAt`,`updatedAt`) VALUES (DEFAULT,'666666','2019-03-26 16:59:58','2019-03-26 16:59:58');

* 使用then做链式处理 then 里面可以使用 get() 和 set方法 在外部使用会报错

```js
// 第一种方法 创建持久性实例 自动保存
Task.create({ title: "foo", description: "bar", deadline: new Date() }).then(
  task => {
    // 你现在可以通过变量 task 来访问新创建的 task
    let id = task.get('id');
  }
);

// 第二种方法 构建非持久性实例 不自动保存
await Task.build({ title: "foo" }) // 能自动获取默认值
  .save()
  .then(anotherTask => {
    // 您现在可以使用变量 anotherTask 访问当前保存的任务
    
  })
  .catch(error => {
    // Ooops，做一些错误处理
  });
```

* 不使用then 可以在外部使用 get() 和 set() 方法

``` js
// 第一种方法 创建持久性实例 自动保存
Task.create({ title: "foo", description: "bar", deadline: new Date() });

// 第二种方法 构建非持久性实例 不自动保存
await Task.build({ title: "foo" }).save();

let id = Task.get('id'); // 可以使用get() 方法获取相关属性
Task.set('id' , 1); // 可以通过set() 方法设置相关的字段

```

* create 方法可以限制那些属性可以设置
``` js
User.create({ username: 'barfooz', isAdmin: true }, { fields: [ 'username' ] }).then(user => {
  // 我们假设 isAdmin 的默认值为 false：
  console.log(user.get({
    plain: true
  })) // => { username: 'barfooz', isAdmin: false }
})
```

* bulkCreate 一次插入多行
> INSERT INTO `users` (`userId`,`name`,`createdAt`,`updatedAt`) VALUES (NULL,'1','2019-03-26 17:01:11','2019-03-26 17:01:11'),(NULL,'11','2019-03-26 17:01:11','2019-03-26 17:01:11'),(NULL,'111','2019-03-26 17:01:11','2019-03-26 17:01:11');
``` js
User.bulkCreate([
  { username: 'barfooz', isAdmin: true },
  { username: 'foo', isAdmin: true },
  { username: 'bar', isAdmin: false }
]).then(() => { // 注意: 这里没有凭据, 然而现在你需要...
  return User.findAll();
}).then(users => {
  console.log(users) // ... 以获取 user 对象的数组
})
```

### 修改
* 更新的sql
> UPDATE `users` SET `name`='1000000',`updatedAt`='2019-03-26 16:55:02' WHERE `userId` = 1

* 基本案例
``` js
let user = await User.findById(1);

/** 第一种修改值的方法  */
user.get('name');
user.set('name' , '1000000');
user.save();

/** 第二种修改值的方法  */
user.name = '8888';
user.save();

/** 第三中修改值的方法  */
user.update({
  name: '999999'
});

/** 第四种更新表的方法  */
await User.update(
    {
      name: "666"
    },
    {
      where: {
        name: "11"
      }
    }
  );

```

* 更新值的两种方式
``` js
// 方法 1
task.title = 'a very different title now'
task.save().then(() => {})
 
// 方法 2
task.update({
  title: 'a very different title now'
}).then(() => {})
```

* 也可以限制某些字段值的更新
``` js
task.title = 'foooo'
task.description = 'baaaaaar'
task.save({fields: ['title']}).then(() => {
 // title 现在将是 “foooo”，而 description 与以前一样
})
 
// 使用等效的 update 调用如下所示:
task.update({ title: 'foooo', description: 'baaaaaar'}, {fields: ['title']}).then(() => {
 //  title 现在将是 “foooo”，而 description 与以前一样
})

```

### 删除
* 删除一条记录
> DELETE FROM `users` WHERE `userId` = 1 LIMIT 1

``` js
// 第一种删除的方法
let user = await User.findById(1);
user.destroy();

// 第二种删除的方法
User.destroy({
  where: {
    name: '111'
  }
});
```

### 查询
> SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` WHERE `user`.`name` = '11';
> SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` WHERE `user`.`name` = '11' LIMIT 0, 2;
> SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` WHERE (`user`.`userId` > 2) ORDER BY `user`.`userId` DESC LIMIT 0, 4;

* 原始查询 返回数组
``` js
await Employee.findAll({ 
  where: { name:'name'},
  raw: true, // 只会打印出值得部分
}).then(result => {
  console.log(result); // 返回 查找到的所有条目的数组
});
```

* findById

``` js
/** 获取表中存为 id = 1 的条目内容 没有为null  */
await Employee.findById(1).then((project) => { 
  console.log('project===========================');
  console.log(project);
})
```

* findOne
> SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` LIMIT 1;
``` js
/** 获取表中存为 title = 'title' 的第一个个条目内容 没有为null  */
await Employee.findOne({ where: {title: 'title'} }).then((project) => { 
  console.log('project===========================');
  console.log(project);
})
```

* attributes 返回指定属性内容

``` js
/** 获取表中存为 title = 'title' 的第一个个条目内容 没有为null  */
await Employee.findOne({
  where: { title: 'title' },
  attributes: ['id', 'name'], // 返回的数据仅包含了 id 和 name两个字段内容 不设置为全部返回
}).then((project) => {
  console.log('project===========================');
  console.log(project);
})
```
* findAndCountAll - 在数据库中搜索多个元素，返回数据和总计数
> SELECT count(*) AS `count` FROM `users` AS `user` WHERE `user`.`name` LIKE '%1';
> SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` WHERE `user`.`name` LIKE '%1' LIMIT 0, 10;
``` js
await Employee.findAndCountAll({
  where: {name: 'foosdepold'}, // 查找条件
  offset: 0, // 从索引为0的记录开始查找
  limit: 2 // 最多查找2条记录
}).then(result => {
  console.log(result); // 包含 count rows属性的对象
  console.log(result.count); // 匹配记录条目的总记录数
  console.log(result.rows); // 包含匹配记录条目的数组
});

```

* findAll - 搜索数据库中的多个元素
> SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` WHERE `user`.`name` LIKE '%1' ORDER BY `user`.`userId` DESC LIMIT 0, 4;
``` js
/** 引入OP对象  */
const Op = Sequelize.Op;  

await Employee.findAll({ 
  where: { 
    id: [1,2,3,4,5,6] , // 设置查找条件 设置查找范围
    name: {
      [Op.like]: '%name',         // 包含 '%name'
    }
  },
}).then(result => {
  console.log(result); // 返回 查找到的所有条目的数组
});

```

* 排序
> > SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` WHERE `user`.`name` = '11' ORDER BY `user`.`userId` DESC LIMIT 0, 4;
``` js
await Employee.findAll({ 
  order: [
    ['id', 'ASC'], // 升序
    // ['id', 'DESC'], // 降序
  ]
}).then(result => {
  console.log(result); // 返回 查找到的所有条目的数组
});
```
* OR
> SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` WHERE (`user`.`userId` IN (1, 2));
``` js
await Employee.findAll({ 
  where: { 
    [Op.or]: [
      { id: [1,2,3] },
      { id: { [Op.gt]: 4 } }
    ]
  },
}).then(result => {
  console.log(result); // 返回 查找到的所有条目的数组
});
```

* NOT
> SELECT `userId`, `name`, `createdAt`, `updatedAt` FROM `users` AS `user` WHERE NOT (`user`.`userId` IN (1, 2));
``` js
await Employee.findAll({ 
  where: { 
    [Op.not]: [
      { id: [1,2,3] },
    ]
  },
}).then(result => {
  console.log(result); // 返回 查找到的所有条目的数组
});
```

### 数据类型
* varchar(n)表示n个字符，无论汉字和英文，Mysql都能存入n个字符，仅是实际字节长度有所区别
* mysql的数据类型
``` pug
# 例如，REAL又可以写成FLOAT(24)。
# 还有一些不常用的数据类型，例如，TINYINT（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。
# 通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。

INT	整型	4字节整数类型，范围约+/-21亿
BIGINT	长整型	8字节整数类型，范围约+/-922亿亿
REAL	浮点型	4字节浮点数，范围约+/-1038
DOUBLE	浮点型	8字节浮点数，范围约+/-10308
DECIMAL(M,N)	高精度小数	由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算
CHAR(N)	定长字符串	存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串
VARCHAR(N)	变长字符串	存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串
BOOLEAN	布尔类型	存储True或者False
DATE	日期类型	存储日期，例如，2018-06-22
TIME	时间类型	存储时间，例如，12:20:59
DATETIME	日期和时间类型	存储日期+时间，例如，2018-06-22 12:20:59

```

* sequelize数据类型
``` pug
Sequelize.STRING                      // VARCHAR(255)
Sequelize.STRING(1234)                // VARCHAR(1234)
Sequelize.STRING.BINARY               // VARCHAR BINARY
Sequelize.TEXT                        // TEXT
Sequelize.TEXT('tiny')                // TINYTEXT

Sequelize.INTEGER                     // INTEGER
Sequelize.BIGINT                      // BIGINT
Sequelize.BIGINT(11)                  // BIGINT(11)

Sequelize.FLOAT                       // FLOAT
Sequelize.FLOAT(11)                   // FLOAT(11)
Sequelize.FLOAT(11, 12)               // FLOAT(11,12)

Sequelize.DOUBLE                      // DOUBLE
Sequelize.DOUBLE(11)                  // DOUBLE(11)
Sequelize.DOUBLE(11, 12)              // DOUBLE(11,12)

Sequelize.DECIMAL                     // DECIMAL
Sequelize.DECIMAL(10, 2)              // DECIMAL(10,2)

Sequelize.DATE                        // DATETIME 针对 mysql / sqlite, TIMESTAMP WITH TIME ZONE 针对 postgres
Sequelize.DATE(6)                     // DATETIME(6) 针对 mysql 5.6.4+. 小数秒支持多达6位精度
Sequelize.DATEONLY                    // DATE 不带时间.
Sequelize.BOOLEAN                     // TINYINT(1)

Sequelize.ENUM('value 1', 'value 2')  // 一个允许具有 “value 1” 和 “value 2” 的 ENUM

Sequelize.GEOMETRY                    // 空间列.  仅限于 PostgreSQL (具有 PostGIS) 或 MySQL.
Sequelize.GEOMETRY('POINT')           // 具有几何类型的空间列.  仅限于 PostgreSQL (具有 PostGIS) 或 MySQL.
Sequelize.GEOMETRY('POINT', 4326)     // 具有几何类型和SRID的空间列.  仅限于 PostgreSQL (具有 PostGIS) 或 MySQL.

```

### 关联 

#### 索引
* 索引大大提高了查询速度，同时却会降低更新表的速度
* 建立索引会占用磁盘空间的索引文件
* 索引不会包含有null值的列

* 索引类型
``` bash
# 普通索引 Normal
1.普通索引的索引值可以出现多次
# 唯一索引 Unique
1. 必须唯一 可以为空 mysql中 null=null 返回 null 不相等
# 主键索引 PRIMARY KEY 
1.一个表只能有一个主键(可以是一个字段 也可以是多个字段)
2.必须唯一 且 不得为空 
# 组合索引
1.指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
# 全文索引  Full Text
1.主要用来查找文本中的关键字，而不是直接与索引中的值相比较。
```

##### 普通索引的创建及使用
> CREATE TABLE IF NOT EXISTS `tests` (`id` INTEGER NOT NULL auto_increment , `title` VARCHAR(255), `tag` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;

> ALTER TABLE `tests` ADD INDEX `t_tag` (`tag`) 插入索引

> DROP INDEX [t_tag] ON tests;  删除索引

* 查询语句前加上 explain 可以 查看查询是否有使用索引
1.select_type:SIMPLE，表示这是一次简单的查询，没有join，union，没有中间表
2.type:ALL，表示这次查询进行了全表查询
3.key，mysql使用的索引名，null表示此次SQL查询mysql并没有使用索引
4.rows，这个最关键，表示这个SQL查询了20179条记录
5.使用普通索引的查询语句和普通查询使用方法一致
> explain  SELECT `id`, `title`, `tag`, `createdAt`, `updatedAt` FROM `tests` AS `test` WHERE `test`.`tag` = 'tag2';
``` js
// 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。
/** 创建普通索引  */
const test = sequelize.define("test", {
  title: {
    type: Sequelize.STRING
  },
  tag: {
    type: Sequelize.STRING,
  }
},{
  indexes: [
    {
      name: 't_tag', // 设置索引名
      fields: ['tag'], // 索引对应的栏位
      // method: 'BTREE', // 使用的索引方法
    },
  ]
});
```

##### 唯一索引的创建及使用
* 唯一索引的字段长度不能太长
> CREATE TABLE IF NOT EXISTS `tests` (`id` INTEGER NOT NULL auto_increment , `title` VARCHAR(255), `tag` VARCHAR(40), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
>  ALTER TABLE `tests` ADD UNIQUE INDEX `t_tag` (`tag`)

> SELECT `id`, `title`, `tag`, `createdAt`, `updatedAt` FROM `tests` AS `test` WHERE `test`.`tag` = 'tag2';
> explain SELECT `id`, `title`, `tag`, `createdAt`, `updatedAt` FROM `tests` AS `test` WHERE `test`.`tag` = 'tag2';
``` js
const Test = sequelize.define("test", {
  title: {
    type: Sequelize.STRING
  },
  tag: {
    type: Sequelize.STRING(40),
  }
},{
  indexes: [
    {
      name: 't_tag', // 设置索引名
      fields: ['tag'], // 索引对应的栏位
      unique: true,
      // method: 'BTREE', // 使用的索引方法
    },
  ]
});
```

##### 组合索引的创建及使用
* 只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
>  CREATE TABLE IF NOT EXISTS `tests` (`id` INTEGER NOT NULL auto_increment , `title` VARCHAR(255), `tag` VARCHAR(40), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;
> ALTER TABLE `tests` ADD INDEX `title_tag` (`tag`, `title`)

> SELECT `id`, `title`, `tag`, `createdAt`, `updatedAt` FROM `tests` AS `test` WHERE `test`.`tag` = 'tag1';
> explain SELECT `id`, `title`, `tag`, `createdAt`, `updatedAt` FROM `tests` AS `test` WHERE `test`.`tag` = 'tag1';

``` js
const Test = sequelize.define("test", {
  title: {
    type: Sequelize.STRING
  },
  tag: {
    type: Sequelize.STRING(40),
  }
},{
  indexes: [
    {
      name: 'title_tag', // 设置索引名
      fields: ['tag' , 'title'], // 索引对应的栏位
      // method: 'BTREE', // 使用的索引方法
    },
  ]
});
```

#### 关联和外键
##### Mysql中的关联查询(内连接，外连接，自连接)
* 关联查询 不用定义外键也可以正常查询 且查询结果和定义了外键关联是一样的
* 定义外键可以表之间的关系更加紧密 不能随意新增或删除
* 若同一个数据库中，B表的外键与A表的主键相对应，则A表为主表，B表为从表。

* 内连接
``` bash
# 内连接的特点，只查询在连接的表中能够有对应的记录
SELECT `user`.`id`, `user`.`name`,  `compas`.`id` AS `compas.id`, `compas`.`userId` AS `compas.userId`, `compas`.`comPname` AS `compas.comPname` FROM `users` AS `user` INNER JOIN `compas` AS `compas` ON `user`.`id` = `compas`.`userId`;
```

* 左外连接查询
``` js
// 以左边的表的数据为基准，去匹配右边的表的数据，如果匹配到就显示，匹配不到就显示为null。
SELECT `user`.`id`, `user`.`name`,  `compas`.`id` AS `compas.id`, `compas`.`userId` AS `compas.userId`, `compas`.`comPname` AS `compas.comPname` FROM `users` AS `user` LEFT OUTER JOIN `compas` AS `compas` ON `user`.`id` = `compas`.`userId`;

```

* 右外连接查询
``` js
// 右外连接是同理的，只是基准表的位置变化了而已
// 以右边的表的数据为基准，去匹配左边的表的数据，如果匹配到就显示，匹配不到就显示为null。
SELECT `user`.`id`, `user`.`name`,  `compas`.`id` AS `compas.id`, `compas`.`userId` AS `compas.userId`, `compas`.`comPname` AS `compas.comPname` FROM `users` AS `user` RIGHT OUTER JOIN `compas` AS `compas` ON `user`.`id` = `compas`.`userId`;

```

* 全外连接
``` js
// mysql是没有全外连接的(mysql中没有full outer join关键字)
// 想要达到全外连接的效果，可以使用union关键字连接左外连接和右外连接

SELECT `user`.`id`, `user`.`name`,  `compas`.`id` AS `compas.id`, `compas`.`userId` AS `compas.userId`, `compas`.`comPname` AS `compas.comPname` FROM `users` AS `user` LEFT OUTER JOIN `compas` AS `compas` ON `user`.`id` = `compas`.`userId`
UNION
SELECT `user`.`id`, `user`.`name`,  `compas`.`id` AS `compas.id`, `compas`.`userId` AS `compas.userId`, `compas`.`comPname` AS `compas.comPname` FROM `users` AS `user` RIGHT OUTER JOIN `compas` AS `compas` ON `user`.`id` = `compas`.`userId`;

```

* 自连接查询
``` js
// 自连接查询就是当前表与自身的连接查询，关键点在于虚拟化出一张表给一个别名
SELECT e.comPname,b.* FROM compas e LEFT JOIN compas b ON e.userId = b.id;
```

#### 建立表的关联
* 一对一关联 和 一对多关联的从表SQL语句是一样的

* 一对一关联 belongsTo
``` js
const User = sequelize.define("user", {
  name: {
    type: Sequelize.STRING
  }
});
const Comp = sequelize.define("compa", {
  comPname: {
    type: Sequelize.STRING(24)
  }
});

Comp.belongsTo(User, { foreignKey: "userId" });

/** 先新建主表  */
CREATE TABLE IF NOT EXISTS `users` (`id` INTEGER NOT NULL auto_increment , `name` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;

/* 新建从表  */
CREATE TABLE IF NOT EXISTS `compas` (`id` INTEGER NOT NULL auto_increment , `comPname` VARCHAR(24), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `userId` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB;
```

* 一对多关联 hasMany
``` js
const User = sequelize.define("user", {
  name: {
    type: Sequelize.STRING
  }
});
const Comp = sequelize.define("compa", {
  comPname: {
    type: Sequelize.STRING(24)
  }
});

User.hasMany(Comp, { foreignKey: "userId" });

/** 创建主表  */
CREATE TABLE IF NOT EXISTS `users` (`id` INTEGER NOT NULL auto_increment , `name` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;

/** 创建从表  */
// 自动建立userId索引
CREATE TABLE IF NOT EXISTS `compas` (`id` INTEGER NOT NULL auto_increment , `comPname` VARCHAR(24), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `userId` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB;
```

* 多对多关联
``` bash
1.主键的作用是保证数据的唯一性和完整性，同时通过主键检索表能够增加检索速度。
2.主键只有一个，但是可以设置为多个字段为主键，也即联合主键。
3.当两个数据表形成的是多对多的关系，那么需要通过两个数据表的主键来组成联合主键，就可以确定每个数据表的其中一条记录了

4.一个学生有多个课程 一个课程也有多个学生
学生表(student)  id  name age
课程表(course)  id  name
学生课程表(stu_cour) id stu_id cour_id
```
``` js
const User = sequelize.define("user", {
  name: {
    type: Sequelize.STRING
  }
});
const Comp = sequelize.define("compa", {
  comPname: {
    type: Sequelize.STRING(24)
  }
});

const UserProjects = sequelize.define('userProjects', {})

User.belongsToMany(Comp,{through: UserProjects}, { foreignKey: "userId" });
Comp.belongsToMany(User,{through: UserProjects}, { foreignKey: "compId" });

/** 强制创建表  */
await sequelize.sync({ force: true });

await User.bulkCreate([
  { name: "1"},
  { name: "2"},
  { name: "3"},
]);
await Comp.bulkCreate([
  { comPname: "4"},
  { comPname: "5"},
  { comPname: "6"},
]);

await UserProjects.bulkCreate([
  { userId: 1 , compaId:1},
  { userId: 1 , compaId:2},
  { userId: 1 , compaId:3},
  { userId: 2 , compaId:1},
  { userId: 3 , compaId:2},
  { userId: 3 , compaId:3},
]);

/** 查询部分  */
 SELECT `user`.`id`, `user`.`name`, `user`.`createdAt`, `user`.`updatedAt`, `compas`.`id` AS `compas.id`, `compas`.`comPname` AS `compas.comPname`, `compas->userProjects`.`createdAt` AS `compas.userProjects.createdAt`, `compas->userProjects`.`updatedAt` AS `compas.userProjects.updatedAt`, `compas->userProjects`.`userId` AS `compas.userProjects.userId`, `compas->userProjects`.`compaId` AS `compas.userProjects.compaId` FROM `users` AS `user` LEFT OUTER JOIN ( `userProjects` AS `compas->userProjects` INNER JOIN `compas` AS `compas` ON `compas`.`id` = `compas->userProjects`.`compaId`) ON `user`.`id` = `compas->userProjects`.`userId`;

await User.findAll({
  raw: true, // 只会打印出值得部分
  include: [{
    model: Comp,
    attributes: ['id','comPname'],
    through: {
      attributes: ['userId','compaId'],
    }
  }]
}).then(result => {
  console.log(result); // 返回 查找到的所有条目的数组
});

/** 新建users表  */
CREATE TABLE IF NOT EXISTS `users` (`id` INTEGER NOT NULL auto_increment , `name` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;

/** 新建compas表  */
CREATE TABLE IF NOT EXISTS `compas` (`id` INTEGER NOT NULL auto_increment , `comPname` VARCHAR(24), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;

/** 新建UserProject表  */
// 自动建立 compaId 索引 外键是userId compaId 主键是userId , compaId
CREATE TABLE IF NOT EXISTS `UserProject` (`createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `userId` INTEGER , `compaId` INTEGER , PRIMARY KEY (`userId`, `compaId`), FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, FOREIGN KEY (`compaId`) REFERENCES `compas` (`id`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE=InnoDB;
```

## 数据库备份与还原
* 备份数据库
> mysqldump -u root -p123456 tsequelize > Tsequelize.sql

* 还原数据库 方法一
> mysql -u root -p123456 tsequelize < d:\xampp\Tsequelize.sql

* 还原数据库方法二
> mysql -u root -p 
> 输入密码
> source d:\xampp\Tsequelize.sql;

## 知识点补充
* Session 与 Cookie
* Cookie
``` bash
1.HTTP 请求都是无状态的
2.服务端可以通过响应头（set-cookie）将少量数据响应给客户端，浏览器会遵循协议将数据保存，并在下次请求同一个服务的时候带上
# Cookie 一般是通过服务器端设置 保存在浏览器上的
# Cookie 有长度限制限制 cookie的长度不能大于4kB 一般来说不要超过 4093 bytes
# Cookie 的设置参数
maxAge(Number) 设置这个键值对在浏览器的最长保存时间。是一个从服务器当前时刻开始的毫秒数。 
expires(Date) 设置这个键值对的失效时间，如果设置了 maxAge，expires 将会被覆盖。如果 maxAge 和 expires 都没设置，Cookie 将会在浏览器的会话失效（一般是关闭浏览器时）的时候失效。 
path(String) 设置键值对生效的 URL 路径，默认设置在根路径上（/），也就是当前域名下的所有 URL 都可以访问这个 Cookie。
domain(String) 设置键值对生效的域名，默认没有配置，可以配置成只在指定域名才能访问。 
httpOnly(Boolean) 设置键值对是否可以被 js 访问，默认为 true，不允许被 js 访问。 
secure(Boolean) 设置键值对只在 HTTPS 连接上传输，框架会帮我们判断当前是否在 HTTPS 连接上自动设置 secure 的值。 

egg框架拓展的其他参数
# 默认的配置下，Cookie 是加签不加密的，浏览器可以看到明文，js 不能访问，不能被客户端（手工）篡改。
overwrite(Boolean) 设置 key 相同的键值对如何处理，如果设置为 true，则后设置的值会覆盖前面设置的，否则将会发送两个 set-cookie 响应头。  
signed(Boolean) 设置是否对 Cookie 进行签名，如果设置为 true，则设置键值对的时候会同时对这个键值对的值进行签名，后面取的时候做校验，可以防止前端对这个值进行篡改。默认为 true。 
encrypt(Boolean) 设置是否对 Cookie 进行加密，如果设置为 true，则在发送 Cookie 前会对这个键值对的值进行加密，客户端无法读取到 Cookie 的明文值。默认为 false。 
```
* Session
``` bash
# session类似服务器端的cookie，保存于服务器端，类似于服务器缓存。
# session可以储存在内存中 也可以储存在数据库或文件中
# session的使用 cookie与url重写
1.sessionid字段通过cookie传递给后端
2.sessionid字段通过URL传递给后端

```

``` pug
cascade 串联
indexes 树状
explain 解释
dump 倾倒
```



