# 表关联

## Associations - 关联
###  BelongsTo  关联
* 一对一关联是通过单个外键连接的两个模型之间的关联。 BelongsTo 主表上会保存一个外键
* 一个简单的例子是 Player 通过 player 的外键作为 Team 的一部分。
``` js
/** 会先去创建 player 表 再创建 team表 */
const Player = sequelize.define('player', {/* attributes */});
const Team  =  sequelize.define('team', {/* attributes */});
Player.belongsTo(Team); // 将向 Player 添加一个 teamId 属性以保存 Team 的主键值
/** 强制创建表  */
await sequelize.sync({ force: true });

```
* sql
``` sql
CREATE TABLE IF NOT EXISTS `teams` (`id` INTEGER NOT NULL auto_increment , `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;

CREATE TABLE IF NOT EXISTS `players` (`id` INTEGER NOT NULL auto_increment , `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `teamId` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`teamId`) REFERENCES `teams` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB;

```


### 默认的样式是 camelCase，但是如果源模型配置为 underscored: true ，那么将使用字段 snake_case 创建 foreignKey。
``` js
/** 使用  underscored: true User表的字段名都是下划线了  */
const User = sequelize.define('user', {/* attributes */ }, { underscored: true })
const Company = sequelize.define('company', {
  uuid: {
    type: Sequelize.UUID,
    primaryKey: true
  }
});

User.belongsTo(Company); // 将 company_uuid 添加到 user

/** 强制创建表  */
await sequelize.sync({ force: true });

```

### 在已定义 as 的情况下，将使用它代替目标模型名称。
``` js
const User = sequelize.define('user', {/* attributes */ })
const UserRole = sequelize.define('userRole', {/* attributes */ });
User.belongsTo(UserRole, { as: 'role' }); // 将 role 添加到 user 而不是 userRole 此时外键为roleId

/** 强制创建表  */
await sequelize.sync({ force: true });
```

### 使用自定义外键名

* 目标键是源模型上的外键列指向的目标模型上的列。 默认情况下，belongsTo 关系的目标键将是目标模型的主键。 要定义自定义列，请使用 targetKey 选项。
``` js
/** 外键必须是唯一索引 且 类型要和关联字段类型一致  字段长度不能定义太长*/

const User = sequelize.define('user', {
  userId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING,
  },
  title: {
    type: Sequelize.STRING,
    allowNull: true,
  }
});
const Comp = sequelize.define('compa', {
  comId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING(24),
    unique:true,
  }
});

User.belongsTo(Comp, { foreignKey: {
  field:'fk_companyname',
  type: Sequelize.STRING(24),
}, targetKey: 'name'}); // 添加 fk_companyname 到 User


/** 强制创建表  */
await sequelize.sync({ force: true });

/** 设置外键关联的sql */
CREATE TABLE IF NOT EXISTS `compas` (`comId` INTEGER auto_increment , `name` VARCHAR(24) UNIQUE, `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`comId`)) ENGINE=InnoDB;

CREATE TABLE IF NOT EXISTS `users` (`userId` INTEGER auto_increment , `name` VARCHAR(255), `title` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `fk_companyname` VARCHAR(24), PRIMARY KEY (`userId`), FOREIGN KEY (`fk_companyname`) REFERENCES `compas` (`name`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB;
```

###  HasOne 关联
``` bash
HasOne 在 target 模型中插入关联键，而 BelongsTo 将关联键插入到 source 模型中。
当关于关联的信息存在于 source 模型中时，我们可以使用 belongsTo。
当关于关联的信息存在于 target 模型中时，我们可以使用 hasOne。
```

### 一对多关联 (hasMany)

``` js
/** 外键必须是唯一索引 且 类型要和关联字段类型一致  字段长度不能定义太长*/

const User = sequelize.define('user', {
  userId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING,
  },
  title: {
    type: Sequelize.STRING,
    allowNull: true,
  }
});
const Comp = sequelize.define('compa', {
  comId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING(24),
    unique:true,
  }
});


/**  hasMany 一对多关联 外键字段fk_companyname 会被写到 User表中 */
Comp.hasMany(User, { foreignKey: {
  field:'fk_companyname',
  type: Sequelize.STRING(24),
}, sourceKey: 'name'}); // 添加 fk_companyname 到 User 参考 compa表的name字段

/** 强制创建表  */
await sequelize.sync({ force: true });
```

## 多对多关联
* 简单的多表关联
``` js
const User = sequelize.define('user', {
  name: {
    type: Sequelize.STRING,
  },
});
const Comp = sequelize.define('compa', {
  name: {
    type: Sequelize.STRING(24),
    unique:true,
  }
});


/** 会新建一个UserProject的表 并添加 compaId 和 userId字段  */
Comp.belongsToMany(User, {through: 'UserProject'});

/** 强制创建表  */
await sequelize.sync({ force: true });
```

### 可以使用别名
``` js
/** 外键必须是唯一索引 且 类型要和关联字段类型一致  字段长度不能定义太长*/
const User = sequelize.define('user', {
  userId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING,
  },
});
const Comp = sequelize.define('compa', {
  compId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING(24),
    unique:true,
  }
});



/** 会新建 worker_tasks 表 并添加外键字段  compId 和 userId*/
Comp.belongsToMany(User, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'compId' });
User.belongsToMany(Comp, { as: 'Workers', through: 'worker_tasks', foreignKey: 'userId' });

/** 强制创建表  */
await sequelize.sync({ force: true });
```
### 
* foreignKey 将允许你在 through 关系中设置 source model 键。
* otherKey 将允许你在 through 关系中设置 target model 键。

``` js
/** 外键必须是唯一索引 且 类型要和关联字段类型一致  字段长度不能定义太长*/
const User = sequelize.define('user', {
  userId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING,
  },
});
const Comp = sequelize.define('compa', {
  compId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING(24),
    unique:true,
  }
});


/* 会新建worker_tasks 表 有两个主键 其中  userId1 对应 User表的userId字段 compId1 对应 Comp表的compId字段 */
User.belongsToMany(Comp, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId1', otherKey: 'compId1'})

/** 强制创建表  */
await sequelize.sync({ force: true });
```


### 当然你也可以使用 belongsToMany 定义自我引用：
``` js
/** 外键必须是唯一索引 且 类型要和关联字段类型一致  字段长度不能定义太长*/
const User = sequelize.define('user', {
  userId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING,
  },
});
const Comp = sequelize.define('compa', {
  compId: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: Sequelize.STRING(24),
    unique:true,
  }
});

/** 这将创建存储对象的 ID 的表 PersonChildren。  */
User.belongsToMany(User, { as: 'Children', through: 'PersonChildren' })

/** 强制创建表  */
await sequelize.sync({ force: true });
```

### 定义关联之前为连接表定义一个模型，然后再说明它应该使用该模型进行连接，而不是创建一个新的关联：
``` js
const User = sequelize.define('user', {})
const Project = sequelize.define('project', {})
const UserProjects = sequelize.define('userProjects', {
  status: Sequelize.STRING
})

User.belongsToMany(Project, { through: UserProjects })
Project.belongsToMany(User, { through: UserProjects })

/** 强制创建表  */
await sequelize.sync({ force: true });
```

### 当通过模型不存在主键时，Belongs-To-Many会创建唯一键。 可以使用 uniqueKey 选项覆盖此唯一键名。
``` js
Project.belongsToMany(User, { through: UserProjects, uniqueKey: 'my_custom_unique' })
```

## 表关联实例

### Users表 
* 一对多关联 Contents表
* 一对多关联 Comments表格

* Users表字段
``` pug
id: Sequelize.INTEGER,
username: Sequelize.STRING(20),
password: Sequelize.CHAR(32),
createdAt: Sequelize.DATE
updatedAt: Sequelize.DATE
```

* Users表关联设置
``` js
//  一个用户在Contents表中可以有多个内容
Users.hasMany(models.Contents, {
  foreignKey: 'user_id'
});

// 一个用户在Comments表中可以有多个评论
Users.hasMany(models.Comments, {
  foreignKey: 'user_id'
});
```

### Contents表
* Contents表 一对一关联 Users表
* Contents表 一对多关联 Comments表

* Contents表字段
``` pug
id: type: Sequelize.INTEGER
user_id: Sequelize.INTEGER, 外键字段 关联User表的id字段
title: Sequelize.STRING(50),
content：Sequelize.STRING(1000),
like_count: type: Sequelize.INTEGER,
comment_count: type: Sequelize.INTEGER,
createdAt: type: Sequelize.DATE
updatedAt: type: Sequelize.DATE
```

* Contents表关联设置
``` js 
// 一个内容对应一个用户
Contents.belongsTo(models.Users, {
  foreignKey: 'user_id'
});

// 一个内容有多条评论
Contents.hasMany(models.Comments, {
  foreignKey: 'content_id'
});
```

### Comments 表
* Comments 表 一对一关联 Users表
* Comments 表 一对一关联 Contents表

* Comments表字段
``` pug
id: Sequelize.INTEGER
content_id: Sequelize.INTEGER, 关联Contents表的id字段
user_id: Sequelize.INTEGER,  关联Users表的id字段
content: Sequelize.STRING(1000),
createdAt: Sequelize.DATE
updatedAt: Sequelize.DATE
```

* Comments表关联设置
``` js
// 一条评论对应一个内容
Comments.belongsTo(models.Contents, {
  foreignKey: 'content_id'
});

// 一条评论对应一个用户
Comments.belongsTo(models.Users, {
  foreignKey: 'user_id'
});
```
### Likes表
* 一对一关联 Users表
* 一对一关联 Contents表

* Likes表字段
``` pug
id: Sequelize.INTEGER
content_id: Sequelize.INTEGER, 关联Contents表的id字段
user_id： Sequelize.INTEGER, 关联Users表的id 字段
createdAt：Sequelize.DATE
updatedAt：Sequelize.DATE
```

* Likes表关联设置
``` js

// 一个点赞对应一个内容
Likes.belongsTo(models.Contents, {
  foreignKey: 'content_id'
});

// 一个点赞对应一个用户
Likes.belongsTo(models.Users, {
  foreignKey: 'user_id'
});
```


