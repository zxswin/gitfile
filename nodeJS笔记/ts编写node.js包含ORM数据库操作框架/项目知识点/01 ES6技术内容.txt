
一.Symbol数据类型

1.数据类型
Number , Boolean , String , Symbol , Null , Undefined , Object

2.什么是Symbol
--Symbol类型的值通过Symbol函数生成,相同Symbol函数返回的值是唯一的
--Symbol函数可以接受字符串为参数,但是即使使用相同的参数返回值也是唯一的 参数仅为描述的作用
即Symbol('miaov') != Symbol('miaov')

Symbol 函数前不能使用new否则会报错 原因在于Symbol 是一个原始类型的值 不是对象
不能作运算 不能转换为Number

Symbol作为对象的属性 不能被for in 循环遍历
通过Object.getOwnPropertySymbols方法获得一个对象所有的Symbol属性

3.案例
1.用于防止属性被外部修改
let Person = (function(){

  let _gender = Symbol('gender'); // 这个值是唯一的

  function P(name , gender){
    this.name = name;
    this[_gender] = gender;
  };

  P.prototype.say = function(){
    console.log(this[_gender]);
  };

  return P;
})();

let p1 = new Person('姓名','男'); 
console.log(p1); // { name: '姓名', [Symbol(gender)]: '男' }
console.log(p1[Symbol('gender')]); // undefined
p1.say(); // 男


二.变量声明
1.var
作用域块:由{}包含的代码块所产生的作用域
var:
-- 支持变量声明预解析
-- 不支持块作用域
-- 允许重复声明

2.let
-- 不支持变量声明预解析 先声明后使用
-- 支持块作用域
-- 不支持重复声明 暂存死区
let f = 10;
function fn(){
  f=7; // 暂时性死区 虽然f在代码块里面
  let f=2;
}
fn(); // 函数执行后会报错

3.const
-- 不支持变量声明预解析 先声明后使用
-- 支持块作用域
-- 不支持重复声明 暂存死区
-- 常量的值一旦确定就不允许修改 所以必须初始化

三.解构赋值
1.允许安装一定的模式 从数组和对象中提取值 并对标量进行赋值 这种称为解构赋值
null 和 undefined不能进行解构赋值
let {length：len} = 'miaov';
console.log(len); // 5

2.数组解构
let [a,b,c] = [1,2,3];

3.对象解构
let {foo,bar} = {foo:"aaa",bar:"bbb"}
-key值对应

4.对象解构赋值的注意点
let top = 500;
console.log(top); // top是全局对象已经被定义过了

let {left,top} = {left:100,top:200};
console.log(left,top);  //报错因为top已经被定义过了

// 如果已经有定义过的变量值 使用下面的写法
let {left:L,top:T} = {left:100,top:200};
console.log(L,T)

5.解构赋值 - 别名
let {foo:f,bar:b} = {foo:"aaa",bar:"bbb"};
-foo:原始名称
-f:别名

6.多重解构
let {foo:[a,b]} = {foo:[10,20],bar:"bbb"};

7.解构赋值-案例
let {left:L,top:T} = getComputedStyle('#box');



四.扩展运算符
...
把数组或对象转换成参数序列 使用逗号分隔的序列
['a','b','c'] => 'a','b','c'
{left:100,top:200} => left:100,top:200

2.拓展运算符 - 案例
-- Math.max()
let arr = [1,2,3,4,5];
console.log(Math.max(...arr));

-- 数组合并
let arr1 = [1,2,3,4,5];
let arr2 = ['a','b','c','d','e'];

console.log([...arr1,...arr2]);

-- 对象合并
let obj1 = {left:100,top:200};
let obj2 = {left:200,height:200};

let obj3 = {
  ...obj1,
  ...obj2
}

console.log(obj3);

五.字符串拓展
1.unicode表示法
模板字符串
-- http://www.unicode.org/
-- http://www.unicode.org/emoji/charts

2.模板字符串
-- `字符串内容`
-- 变量表达式解析：`${表达式}`


六.数值的拓展
1.二进制 0b
2.八进制 0o ES6之前：0开头表示八进制
3.十进制 非0开头
4.十六进制 0x

七.对象的拓展
1.对象简介表示法
当对象的key与对应的属性所引用的变量或函数同名的时候 可以简写为一个
let a =1;
let fn = function(){};

let obj = {
  a,
  fn
}
2.属性名表达式
对象的属性名可以接收表达式作为key 表达式计算的结果作为最终的key

let x = 'miaov';
let obj1 = {
  x:1,  // 第一种写法
  [x]:1 //第二种写法
}
obj1[x] = 1;

Object.is() // 判断两个对象是否一样 看起来一样
Object.is(NaN,NaN); true;

八.迭代
1.迭代协议：规定了迭代的实现逻辑
2.迭代器：具体的迭代实现逻辑
3.迭代对象
可迭代的对象 -[Symbol.interator]方法
4.迭代语句
for……in:以原始插入的顺序迭代对象的可枚举属性
for……of:根据迭代对象的迭代器具体实现迭代对象数据
5.迭代协议的实现
let  obj = {
  left:1,
  top:2,
}

//迭代协议
obj[Symbol.iterator] = function() {
  let keys = Object.keys(obj); // ['left','top']
  let len = keys.length;
  let n = 0;

  return {
    next: function(){

      if (n < len){
        return {
          value: keys[n++],
          done: false, // 继续循环调用next()
        }
      } else {
        return {
          done: true, // 停止循环
        }
      }
    }
  }
}


for (var attr of obj) {
  console.log(attr);

}

6.冻结对象
const arr1 = Object.freeze([1,2,3]); // freeze冻结
console.log(Object.isFrozen(arr1)); // true 是否冻结


九.函数扩展
1.函数扩展
-- 函数参数默认值
function fn2(x = 0, y = 0) {
  console.log(x ,y);
}
fn2(1 ,2); // 1 2
fn2(); // 0 0 


-- rest剩余参数
function arrayPush6(arr , ...newData) {
  // 从第二个参数开始 后面的数据全部赋值给newData这个参数
  // 剩余参数只能写在形参列表的最后面
  for (let i=0; i < newData.length; i++){
    arr.push(newData[i]);
  }
}

let arr1 = [1,2,3];

arrayPush6(arr1,'a','b','c');
console.log(arr1); // [ 1, 2, 3, 'a', 'b', 'c' ]

2.箭头函数
--基本格式
   (参数列表) => {函数体}
   (x,y)=>{}
   ()=>{}
   x=>{} // 当有一个参数的时候是可以省略小括号的
  参数
  返回值
  let fn4 = x=> x + 100; // 直接返回x + 100的结果

3.箭头函数 - 注意事项
-- 内部this对象指向创建期上下文对象
普通函数的this指向是在函数的执行期绑定的(确定的)
function fn6() {
  console.log(this);
}

fn6(); // 指向window
var obj = {};
obj.f = fn6;
obj.f(); //执行的是obj
document.onclick = fn6; // 指向触发该函数的事件document;


箭头函数的this在函数创建期间就绑定好了,箭头函数的this指向创建该箭头函数所在的作用域对象(this);
let fn7 = ()=>{
  console.log(this);
}
fn7();
document.onclick = fn7; // fn7内部的this永远都是fn7函数声明的时候所在的this对象

-- 不能作为构造函数
-- 没有arguments
-- 不能作为生成器函数

-- 不可以当做构造函数 不可以使用new命令 否则会抛出一个错误
-- 箭头函数不可以作为Generator函数

十.内置对象
1.String
-- startWith();
   'miaov'.startWith('m');  // true
-- endWith();
   'miaov'.endWith('v');  // true
   
-- includes();
   'miaov'.endWith('m');  // true

-- repeat();
   'miaov'.repeat(2);  // 'miaovmiaov'

2.Number
-- isFinite()
-- isNaN()
-- parseInt()
-- ParseFloat()

3.Array 
-- includes()
-- every()
let arr2 = [1, 6, 5, 6, 7];
let rs = arr2.every(v => {
  // 必须是每个值都是大于5 才会返回真
  return v > 5
});

console.log(rs); // false

-- some() // 有一个为真就是true

-- filter() // 过滤符合条件的选项
let arr2 = [1, 6, 5, 6, 7];
let arr3 = arr2.filter(v => {
  return v > 5; 
});
console.log(arr3); // [6,7]

-- map()  //对值进行加工 返回一个新数组
let arr = [1,2,3];
let arr4 = arr.map(v => {
  return v*10;
});
console.log(arr4); // [ 10, 20, 30 ]

-- reduce()
实现数组累加功能
let arr = [1,2,3];
let arr4 = arr.reduce((prev , current)=> {
  // prev表示上一次结果的值
  // current 表示当前值
  return prev + current;
});
console.log(arr4); // 6

-- forEach
let arr1 = ['a','b','c'];
arr1.forEach(function(v,k,s) {
  console.log(v,k,s); // v是值 k是key s是arr1
  console.log(this);  // this默认指向外部上下文环境
},arr1); // arr1参数改变函数体内部的this指向arr1

原生代码实现
let arr1 = ['a', 'b', 'c'];
function forEach(data, callback, context) {
  for (let i = 0; i < data.length; i++) {
    callback.call(context, data[i], i, data);
  }
}

forEach(arr1, function (v,k,s) {
  console.log(v, k, s);
  console.log(this);
}, 1);

4.Object 
-- Object.assign()  // 对象进行浅拷贝
let obj1 = {x:1,y:2};
let obj2 = {};
Object.assign(obj2,obj1);
console.log(obj2); // 实际上是修改了obj2的值 { x: 1, y: 2 }

-- Object.create()
let obj = Object.create({a:1,b:2});
console.log(obj); // {} 创建的对象被赋值该了原型对象上的object

-- Object.freeze() // 冻结对象
-- Object.defineProperty() // 定义对象属性
let obj4 = { x: 1 };
obj4.y = 10;
// 通过 defineProperty 添加或修改的属性,
// configurable/enumerable/value/writable 默认为false
Object.defineProperty(obj4, 'z', {
  // 描述了该属性的一些详细细节
  value: 100,
  writable: true,
  enumerable: true,
});

console.log(obj4); // { x: 1, y: 10, z: 100 }



5.Set 
-- 集合:它类似于数组 但是成员的值都是唯一的 没有重复的值 并且是无序的
-- 特点：key 和 value 相同 没有重复的value
-- Set是一个构造函数 可以传入一个可迭代的对象初始默认值
const s = new Set([1,2,3]); // 创建一个Set
s.size // 3 返回Set的长度

set.add(value) 添加一个数据 返回Set结构本身
s.add('a').add('b').add('c');

set.delete(value) 删除指定的数据 返回一个布尔值 表示删除是否成功

set.has(value) 判断该值是否为Set的成员 返回一个布尔值

set.clear() 清除所有数据 没有返回值

set.keys() 返回键名的遍历器

set.values() 返回键值遍历器

set.entries() 返回键值对的遍历器

forEach() 使用回调函数遍历每一个成员



-- Set 案例
数组去重
let arr1 = [1,2,3,45,6,7,12,3,4,5];
arr1 = [...new Set(arr1)];
console.log(arr1); // [ 1, 2, 3, 45, 6, 7, 12, 4, 5 ]


6.WeakSet 
7.Map 
-- 映射 它类似于对象 但是key值可以任何类型的值 不仅仅局限于字符串

-- 如何创建一个Map
const map = new Map([
  ['a',1],
  ['b',2]
]);

console.log(map); // Map { 'a' => 1, 'b' => 2 }

-- Map 类的属性
map.size; // 返回Map的长度 Map仅有这个属性

-- Map 类的方法
set(key,value) 设置键名key对应的键值为value 然后返回整个Map结构 
如果key已经有值 则键值会被更新 否则就新生产该键

map.set('miaov','ketang').set('new','fd').set('miaov','leo');


get(key) get方法读取key对应的键值 如果找不到key 返回undefined

delete(key) 删除某个键 返回true 如果删除失败 返回false

has(key) 方法返回一个布尔值 表示某个键是否在当前Map对象之中

claer() 清除所有的数据 没有返回值

keys() 返回键名的遍历器

values() 返回键值得遍历器

entries() 返回键值对的遍历器

forEach() 使用回调函数遍历每个成员

Map 在使用过程中的一些注意事项
map.set(NaN,10).set(NaN,100); // 它认为NaN是同一个值

map.set({},'x'),set({},'y'); // 不同的引用地址 判断是不同的


-- Map 案例
类数据私有化
const Person = (function () {
  // 把对象与某个性别关联起来
  let _gender = new Map();

  function P(name, gender) {
    this.name = name;
    _gender.set(this, gender);
  }

  P.prototype.getGender = function () {
    return _gender.get(this);
  }

  P.prototype.setGender = function (newGender) {
    _gender.set(this, newGender);
  }

  P.prototype.getGenders = function () {
    return _gender;
  }

  return P;

})();

let p1 = new Person('p1', '男');
let p2 = new Person('p2', '男');

p1.setGender('女');
console.log(p1.getGender());
console.log(p2.getGender());
console.log(p1.getGenders());
console.log(p2.getGenders());

8.WeakMap 
映射:类似Map 但是key必须是对象 特点是key是弱引用的 GC机制不考虑回收问题

-- WeakMap -案例
数据私有化优化
let _gender = new WeakMap();

9.Iterator 和 for...of循环
-- Iterator 遍历器的作用
- 为各种数据结构 提供一个统一的 简便的访问接口
- 使得数据结构的成员能按某种测序排列
- ES6新增了遍历命令for...of循环 Iterator接口主要提供for...of消费

-- 手写Iterator遍历器
const arr = [1,2,3];
function iterator(arr){
  let index =0;
  return {
    next: function(){
      return index<arr.length?
      {value:arr[index++],done:false}:
      {value:undefined,done:true}
    }
  }
}

const it = iterator(arr);
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());

-- 具备iterator接口的数据结构可以进行如下操作
- 解构赋值
- 扩展运算符

let str = 'miaov';
let arrStr = [...str];

-- for ... of循环
const ofArr = [1,2,3,4];
for(let i of ofArr){
  console.log(i); // 1,2,3,4 打印出value值
}

const m = new Map();
m.set('a',1).set('b',2).set('c',3);
for(let data of m){
  console.log(typeof data); // object
  console.log(data);
  // [ 'a', 1 ]
  // [ 'b', 2 ]
  // [ 'c', 3 ]
}

for(let [key,value] of m){
  console.log(key,value);
//   a 1
//   b 2
//   c 3
}

10.class 类 

-- 传统的面向对象的写法
const Miaov = function (a, b) {
  this.a = a;
  this.b = b;
  return this;
};

Miaov.prototype = {
  constructor: Miaov,
  print: function () {
    console.log(this.a + ' ' + this.b);
  }
};

const miaov = new Miaov('hello', 'world').print();

-- 使用Class的面向对象的写法
class Miaov {
  constructor(a,b){ 
    // 类的构造函数
    this.a = a;
    this.b= b;
    return this; // 去掉也可以
  }

  // 方法与方法之间是不用加逗号的 加了会报错
  print(){
    console.log(this.a + ' ' + this.b);
  }
}

const miaov = new Miaov('hello','world').print()

-- 定义在类中的方法都是不可以被枚举的
console.log(Object.keys(Miaov.prototype)); // 不能打印出类中定义的方法

-- constructor方法如果没有被显示定义 一个空的constructor 方法会被默认添加

-- 如果忘记加上new 像函数那样调用class 将会报错

11.class 的继承等相关知识

-- 一个绘制小球的例子

const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

const w = canvas.width = 600;
const h = canvas.height = 400;

class Ball {
  constructor(x, y, r) {
    // 小球的构造方法
    this.x = x;
    this.y = y;
    this.r = r;
    this.color = `rgb(${~~Ball.rpFn([55, 255])},
${~~Ball.rpFn([55, 255])},${~~Ball.rpFn([55, 255])}`;
    /**
      *  ~~运算符    
      * 其实是一种利用符号进行的类型转换,转换成数字类型
      * ~~true == 1
        ~~false == 0
        ~~"" == 0
        ~~[] == 0

        ~~undefined ==0
        ~~!undefined == 1
        ~~null == 0
        ~~!null == 1
      */
    return this; // 实例化的时候方便去调用其他的方法
  }

  render(ctx) {
    // 普通类方法
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(0, 0, this.r, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();
    return this;
  }

  static rpFn(arr) {
    // 定义静态方法
    let max = Math.max(...arr),
      min = Math.min(...arr);
    return Math.random() * (max - min) + min;
  }
}

// const ball1 = new Ball(100, 100, 30).render(ctx); // 实例化小球类对象


class SuperBall extends Ball {
  constructor(x, y, r) {
    // Ball.call(this,x,y,r); 父类不允许用方法的形式去调用
    // this.color = 'red'; // 在调用super()方法之前 子类是没有自己的this对象的
    super(x, y, r); // 这样就继承了父类的属性和方法 且 只能在构造函数中使用
    this.vy = SuperBall.rpFn([2, 4]); // 调用父类中的静态方法
    this.g = SuperBall.rpFn([0.2,0.4]);
    this.a =0;
    return this;
  }

  move(ctx){
    this.y += this.vy;
    this.vy += this.g;
    let current = this.vy * -0.75;

    if(this.y + this.r >= ctx.canvas.height){
      this.y = ctx.canvas.height - this.r;

      if(Math.abs(current - this.a)<0.01) return false;
      this.a = this.vy *= -0.75;
    }

    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    super.render(ctx); // 调用父类的方法去重绘小球

    return true;

  }
}

// const ball1 = new SuperBall(100, 100, 30).render(ctx); // 实例化小球类对象


// 点击绘制小球
let ball,timer;
canvas.onclick = function(e){
  let x = e.offsetX,y = e.offsetY;
  console.log(x,y,e);
  let r = ~~Ball.rpFn([25,55]);
  ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); // 清空画布
  ball = new SuperBall(x,y,r).render(ctx);

  ballMove(); // 执行小球运动函数
}

function ballMove(){
  timer = window.requestAnimationFrame(ballMove);
  if(!ball.move(ctx)){
    window.cancelAnimationFrame(timer);
  }
}

12.Promise 对象
-- 基本概念
Promise 是ES6中新增的异步编程解决方案

-- new Promise(cb) ===> 实例化的基本使用 Pending Resolved Rejected
- Pending(进行中) ===> Resolved(已完成)
- Pending(进行中) ===> Rejected(已失败)

let p1 = new Promise((resolve,reject)=>{
  // 当Promise被实例化的时候 callback的异步任何就会被执行
  // 我们可以通过传入的resolve reject 去改变当前的Promise任务的状态
  // resolve reject是两个惨 调用resolve这个函数 会吧状态改成resolved 调用reject函数会
  // 把状态改变为reject
  setTimeout(() => {
    console.log(1);
    resolve();
  }, 3000);
})

// then 当promise对象的状态变成resolved的时候执行
// p1.then() 放回的是一个成功的Promise对象
p1.then(()=>{
  console.log('成功');
}).catch(()=>{
  console.log('失败');
});


-- 两个原型方法：
- Promise.prototype.then();
- Promise.prototype.catch();

-- 两个常用的静态方法
- Promise.all();
Promise.all 可以将多个Promise 实例包装成一个新的Promise实例
当所有的Promise实例的状态变成功resolved Promise.all的状态会变成
resolved 此时返回值组成一个数组 传递给then中的resolve函数

只要其中有一个rejectd Promise.all的状态就会变成rejected 此时第一个被
reject的实例的返回值 会传递给p的回调函数

let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log(1);
    resolve(1);
  }, 3000);
});

let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log(1);
    resolve(2);
  }, 3000);
});


Promise.all([p1, p2]).then(data => {
  console.log(data); // [ 1, 2 ]
}).catch(v => {
  console.log(v);
});

Promise.race([p1, p2]).then(data => {
  console.log(data); // 1 或 2 看p1 p2那个先执行
}).catch(v => {
  console.log(v);
});


- Promise.resolve();
Promise.resolve('miaov').then(function(str){
  console.log(str); // 'miaov'
})


13.箭头函数不可以作为Generator函数
在形式上,Generator是一个普通函数 但是有两个特征 
一是 function命令与函数名之间有一个星号
二是 函数体内部使用yield语句 定义便离奇的每个成员 即不同的内部状态

-- 迭代
generator返回一个迭代函数 调用next方法才能执行

function* fn(){
  console.log(1);
  yield console.log(2);
  console.log(3);
};

// 返回一个迭代器函数
let f= fn();  // 1
f.next();  // 2
f.next(); //3

{value: done:false} // done的值 false 表示未遍历完毕 true 表示遍历完成

let val = yield getData();
function getData(){
  f.next(100) // 100 会传给val
}

-- 封装co函数使得generoter函数能够自动执行next

function* fn(){
  console.log(1);
  let val = yield getData();
  console.log(val);
  console.log(3);
}

function getData(){
  return new Promise((resolve,reject)=>{
    setTimeout(() => {
      resolve(100);
    }, 1000);
  })
}



function co( callback ){
  let cb = callback();
  // co 递归的调用cb的next方法
  function next(d){
    let result = cb.next(d); // {value , done}
    if(result.done){
      return
    }
    result.value.then(data=>{
      console.log('data',data); // 100
      next(data);
    })
  }
  next();
}

let f=fn;
co(f);

-- async await 的使用
async function fn(){
  console.log(1);
  let v1 = await getData();
  console.log(v1); // 100

  let v2 = await getData();
  console.log(v2); // 100

  let v3 = await getData();
  console.log(v3); // 100

  console.log(3)
}


function getData(){
  return new Promise((resolve,reject)=>{
    setTimeout(() => {
      resolve(100);
    }, 1000);
  })
}

fn();




资源地址：
https://developer.mozilla.org/zh-CN/ WEB文档

单词
symbol 符号 象征
entries 条目
iterator 迭代器
generator 发动机
promise 承诺

