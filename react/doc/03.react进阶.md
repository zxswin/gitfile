## react 进阶

- 界面交互类

```tsx
// 使用 React 片段(Fragments) 将多个元素组合在一起
// 当需要 key 属性时使用 <Fragment> ：

import React, { Fragment } from 'react';

function Glossary(props) {
  return (
    <dl>
      {props.items.map(item => (
        // Without the `key`, React will fire a key warning
        <Fragment key={item.id}>
          <dt>{item.term}</dt>
          <dd>{item.description}</dd>
        </Fragment>
      ))}
    </dl>
  );
}

// 焦点的设置
function CustomTextInput(props) {
  return (
    <div>
      <input ref={props.inputRef} />
    </div>
  );
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.inputElement = React.createRef();
  }
  render() {
    return (
      <CustomTextInput inputRef={this.inputElement} />
    );
  }
}
/>

// 现在您可以根据需要设置焦点。
this.inputElement.current.focus();


```

- 路由拆分

```tsx
// 使用 React Router 和React Loadable 等库设置基于路由的 代码拆分
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Loadable from 'react-loadable';

const Loading = () => <div>Loading...</div>;

const Home = Loadable({
  loader: () => import('./routes/Home'),
  loading: Loading,
});

const About = Loadable({
  loader: () => import('./routes/About'),
  loading: Loading,
});

const App = () => (
  <Router>
    <Switch>
      <Route exact path="/" component={Home} />
      <Route path="/about" component={About} />
    </Switch>
  </Router>
);
```

- 上下文

```tsx
// 上下文(Context) 提供了一种通过组件树传递数据的方法，无需在每个级别手动传递 props 属性。
// Context 旨在共享一个组件树内可被视为 “全局” 的数据

// 使用 context, 我们可以避免通过中间元素传递 props
const ThemeContext = React.createContext('light');
class App extends React.Component {
  render() {
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

function ThemedButton(props) {
  return <ThemeContext.Consumer>{theme => <Button {...props} theme={theme} />}</ThemeContext.Consumer>;
}

// 只要 Provider 的 value 属性发生变化是，所有属于该 Provider 后代的 Consumers 就会重新渲染。
// 即使当祖先组件退出更新时，后代 Consumer 也会被更新。

// 动态 Context
// -- theme-context.js
export const themes = {
  light: {
    foreground: '#000000',
    background: '#eeeeee',
  },
  dark: {
    foreground: '#ffffff',
    background: '#222222',
  },
};

export const ThemeContext = React.createContext(
  themes.dark // 默认值
);

// -- themed-button.js
import { ThemeContext } from './theme-context';

function ThemedButton(props) {
  // ThemeContext.Consumer消费上下文数据
  return <ThemeContext.Consumer>{theme => <button {...props} style={{ backgroundColor: theme.background }} />}</ThemeContext.Consumer>;
}

export default ThemedButton;

// -- app.js
import { ThemeContext, themes } from './theme-context';
import ThemedButton from './themed-button';

function Toolbar(props) {
  return <ThemedButton onClick={props.changeTheme}>Change Theme</ThemedButton>;
}

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      theme: themes.light,
    };

    this.toggleTheme = () => {
      this.setState(state => ({
        theme: state.theme === themes.dark ? themes.light : themes.dark,
      }));
    };
  }

  render() {
    // ThemeContext.Provider 提供上下文数据
    return (
      <Page>
        <ThemeContext.Provider value={this.state.theme}>
          <Toolbar changeTheme={this.toggleTheme} />
        </ThemeContext.Provider>
        <Section>
          <ThemedButton />
        </Section>
      </Page>
    );
  }
}

ReactDOM.render(<App />, document.root);

// 从嵌套组件更新 context (添加上下文事件)
// -- theme-context.js
export const ThemeContext = React.createContext({
  theme: themes.dark,
  toggleTheme: () => {},
});

// -- theme-toggler-button.js
import { ThemeContext } from './theme-context';

function ThemeTogglerButton() {
  return (
    <ThemeContext.Consumer>
      {({ theme, toggleTheme }) => (
        <button onClick={toggleTheme} style={{ backgroundColor: theme.background }}>
          Toggle Theme
        </button>
      )}
    </ThemeContext.Consumer>
  );
}

export default ThemeTogglerButton;

// - app.js
import { ThemeContext, themes } from './theme-context';
import ThemeTogglerButton from './theme-toggler-button';

class App extends React.Component {
  constructor(props) {
    super(props);

    this.toggleTheme = () => {
      this.setState(state => ({
        theme: state.theme === themes.dark ? themes.light : themes.dark,
      }));
    };

    // 这个数据可以通过 ThemeContext.Provider 提供给消费者
    this.state = {
      theme: themes.light,
      toggleTheme: this.toggleTheme,
    };
  }

  render() {
    return (
      <ThemeContext.Provider value={this.state}>
        <Content />
      </ThemeContext.Provider>
    );
  }
}

function Content() {
  return (
    <div>
      <ThemeTogglerButton />
    </div>
  );
}

ReactDOM.render(<App />, document.root);

// ============ 同时使用两个或多个 context 值 ============ //
const ThemeContext = React.createContext('light');

const UserContext = React.createContext({
  name: 'Guest',
});

class App extends React.Component {
  render() {
    const { signedInUser, theme } = this.props;
    return (
      <ThemeContext.Provider value={theme}>
        <UserContext.Provider value={signedInUser}>
          <Layout />
        </UserContext.Provider>
      </ThemeContext.Provider>
    );
  }
}

function Layout() {
  return (
    <div>
      <Sidebar />
      <Content />
    </div>
  );
}

function Content() {
  return (
    <ThemeContext.Consumer>
      {theme => <UserContext.Consumer>{user => <ProfilePage user={user} theme={theme} />}</UserContext.Consumer>}
    </ThemeContext.Consumer>
  );
}

// ====== 在生命周期方法中访问 Context ====== //
// 只需将它作为 props ， 然后像使用 props 一样使用它即可
class Button extends React.Component {
  componentDidMount() {}

  componentDidUpdate(prevProps, prevState) {}

  render() {
    const { theme, children } = this.props;
    return <button className={theme ? 'dark' : 'light'}>{children}</button>;
  }
}

export default props => <ThemeContext.Consumer>{theme => <Button {...props} theme={theme} />}</ThemeContext.Consumer>;

// ======== 高阶组件中的 Context ======== //
const ThemeContext = React.createContext('light');

// withTheme接受一个组件作为参数
export function withTheme(Component) {
  return function ThemedComponent(props) {
    return <ThemeContext.Consumer>{theme => <Component {...props} theme={theme} />}</ThemeContext.Consumer>;
  };
}

// 现在，任何依赖于 theme context 的组件都可以使用我们创建的 withTheme 函数轻松订阅它：
function Button({ theme, ...rest }) {
  return <button className={theme} {...rest} />;
}
const ThemedButton = withTheme(Button);

// ======== 转发 Refs 给 context Consumer(使用者) ========
// 渲染 prop(属性) API的一个问题是 refs 不会自动传递给封装元素。 为了解决这个问题，使用 React.forwardRef ：
// fancy-button.js
class FancyButton extends React.Component {
  focus() {}
}

export default React.forwardRef((props, ref) => (
  <ThemeContext.Consumer>{theme => <FancyButton {...props} theme={theme} ref={ref} />}</ThemeContext.Consumer>
));

// app.js
import FancyButton from './fancy-button';
const ref = React.createRef();
<FancyButton ref={ref} onClick={handleClick}>
  Click me!
</FancyButton>;

// ======== 防止每次 Provider(提供者) 重新渲染时，会重新渲染所有 Consumer(使用者)  ========
// 提升 value 到父节点的 state 里
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: { something: 'something' },
    };
  }

  render() {
    return (
      <Provider value={this.state.value}>
        <Toolbar />
      </Provider>
    );
  }
}
```

- 错误处理

```tsx
// 部分 UI 中的 JavaScript 错误不应该破坏整个应用程序。
// 为了解决 React 用户的这个问题，React 16引入了一个 “错误边界(Error Boundaries)” 的新概念。
// 错误边界(Error Boundaries) 在渲染，生命周期方法以及整个组件树下的构造函数中捕获错误。

// 注意
// 错误边界 无法 捕获如下错误:
// 事件处理 （了解更多）
// 异步代码 （例如 setTimeout 或 requestAnimationFrame 回调函数）
// 服务端渲染
// 错误边界自身抛出来的错误 （而不是其子组件）

// 如果一个类组件定义了一个名为 componentDidCatch(error, info): 的新生命周期方法，它将成为一个错误边界
// 针对组件。仅有类组件可以成为错误边界
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  // 如果发生错误将会触发这里的生命周期函数
  componentDidCatch(error, info) {
    this.setState({ hasError: true });
    logErrorToMyService(error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

// 注意 错误边界(Error Boundaries) 仅可以捕获其子组件的错误。
// 错误边界无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会向上冒泡至最接近的错误边界。
// 这也类似于 JavaScript 中 catch {} 的工作机制。
// info 是一个含有 componentStack 属性的对象。这一属性包含了错误期间关于组件的堆栈信息。
componentDidCatch(error, info) {
  logComponentStackToMyService(info.componentStack);
}

// 自 React 16 开始，任何未被错误边界捕获的错误将会卸载整个 React 组件树。
```

- 转发 Refs

```tsx
// Ref 转发是一种自动将 ref 通过组件传递给子组件的技术。
// FancyButton 使用 React.forwardRef 来获取传递给它的 ref ， 然后将其转发给它渲染的的 DOM button
// 我们通过调用 React.createRef 创建一个 React ref 并将其分配给 ref 变量。
// 通过将 ref 变量传递给指定ref为 JSX 属性的 <FancyButton ref={ref}>。
// Reac t将ref传递给 forwardRef 中的 (props, ref) => ... 函数作为第二个参数。
// 我们将这个ref参数转发到指定ref为 JSX 属性的 <button ref = {ref}> 。
// 当附加 ref 时，ref.current 将指向 <button> DOM节点。
// Ref 转发不限于 DOM 组件。您也可以将 refs 转发给类组件实例。
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;

// ref 不是 props(属性)
// 果你添加一个 ref 到 HOC ， 这个 ref 将引用最外面的容器组件，而不是包裹的组件。
// 我们可以使用 React.forwardRef API 明确地将 ref 转发到内部的 FancyButton 组件。
// React.forwardRef 接受一个渲染函数，该函数接收 props 和 ref 参数并返回一个 React 节点。例如：
function logProps(Component) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }

    render() {
      const { forwardedRef, ...rest } = this.props;
      return <Component ref={forwardedRef} {...rest} />;
    }
  }

  return React.forwardRef((props, ref) => {
    return <LogProps {...props} forwardedRef={ref} />;
  });
}

// 函数的 displayName 属性来包含你包裹的组件
function logProps(Component) {
  class LogProps extends React.Component {}

  function forwardRef(props, ref) {
    return <LogProps {...props} forwardedRef={ref} />;
  }

  const name = Component.displayName || Component.name;
  forwardRef.displayName = `logProps(${name})`;

  return React.forwardRef(forwardRef);
}
```

- 片段(fragments)

```tsx
// React 中一个常见模式是为一个组件返回多个元素。
// 片段(fragments) 可以让你将子元素列表添加到一个分组中，并且不会在DOM 中增加额外节点。
render() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </React.Fragment>
  );
}

// 不会在DOM 中增加额外节点
class Columns extends React.Component {
  render() {
    return (
      <React.Fragment>
        <td>Hello</td>
        <td>World</td>
      </React.Fragment>
    );
  }
}

// 带 key 的 片段(fragments)
// key 是唯一可以传递给 Fragment 的属性
function Glossary(props) {
  return (
    <dl>
      {props.items.map(item => (
        // 没有`key`，将会触发一个key警告
        <React.Fragment key={item.id}>
          <dt>{item.term}</dt>
          <dd>{item.description}</dd>
        </React.Fragment>
      ))}
    </dl>
  );
}
```

- 高阶组件(Higher-Order Components)

```tsx
// 高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。
// HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。
// 高阶组件是一个函数，能够接受一个组件并返回一个新的组件。

const EnhancedComponent = higherOrderComponent(WrappedComponent);

// ======== 高阶组件示例 ========

// 函数接受一个组件参数……
function withSubscription(WrappedComponent, selectData) {
  // ……返回另一个新组件……
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props),
      };
    }

    componentDidMount() {
      // ……注意订阅数据……
      DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
      this.setState({
        data: selectData(DataSource, this.props),
      });
    }

    render() {
      // ……使用最新的数据渲染组件
      // 注意此处将已有的props属性传递给原组件
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
}

const CommentListWithSubscription = withSubscription(CommentList, DataSource => DataSource.getComments());

const BlogPostWithSubscription = withSubscription(BlogPost, (DataSource, props) => DataSource.getBlogPost(props.id));

// ======== 高阶组件最好是通过将输入组件包裹在容器组件的方式来使用组合 ========
function logProps(WrappedComponent) {
  return class extends React.Component {
    componentWillReceiveProps(nextProps) {
      console.log('Current props: ', this.props);
      console.log('Next props: ', nextProps);
    }
    render() {
      // 用容器组件组合包裹组件且不修改包裹组件，这才是正确的打开方式。
      return <WrappedComponent {...this.props} />;
    }
  };
}

// ======== 高阶组件应该通过props传递那些与特定功能无关的特性 =========
render() {
  // 过滤掉与高阶函数功能相关的props属性，
  // 不再传递
  const { extraProp, ...passThroughProps } = this.props;

  // 向包裹组件注入props属性，一般都是高阶组件的state状态
  // 或实例方法
  const injectedProp = someStateOrInstanceMethod;

  // 向包裹组件传递props属性
  return (
    <WrappedComponent
      injectedProp={injectedProp}
      {...passThroughProps}
    />
  );
}

// ======== 约定:为了方便调试包装显示名称(display name) ========
function withSubscription(WrappedComponent) {
  class WithSubscription extends React.Component {/* ... */}
  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;
  return WithSubscription;
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

// ======== 不要在render函数中使用高阶组件 =======
render() {
  // 每一次render函数调用都会创建一个新的EnhancedComponent实例
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 每一次都会使子对象树完全被卸载或移除
  return <EnhancedComponent />;
}

// ======== 静态方法必须复制 ========
// 定义静态方法
WrappedComponent.staticMethod = function() {/*...*/}
// 使用高阶组件
const EnhancedComponent = enhance(WrappedComponent);

// 增强型组件没有静态方法
typeof EnhancedComponent.staticMethod === 'undefined' // true

// 为了解决这个问题，在返回之前，可以向容器组件中复制原有的静态方法：
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // 必须得知道要拷贝的方法 :(
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}

// 然而，这需要你明确地知道哪些方法需要别复制。
// 你可以使用hoist-non-react-statics来自动复制非React的静态方法。

import hoistNonReactStatic from 'hoist-non-react-statics';
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  hoistNonReactStatic(Enhance, WrappedComponent);
  return Enhance;
}

// 另一个有效的方法是将静态方法与组件本身相分离：
// 替代……
MyComponent.someFunction = someFunction;
export default MyComponent;

// ……分别导出……
export { someFunction };

// ……在要使用的组件中导入
import MyComponent, { someFunction } from './MyComponent.js';

// ======= Refs不会被传递 =======
// 虽然高阶组件的惯例是将所有 属性(props) 传递给包裹的组件，但是对 refs 不起作用。
// 那是因为 ref 不是一个真正的属性(props) - 不像 key。React 对它进行了特殊处理。
// 如果你向一个由高阶组件创建的组件的元素添加ref应用，那么ref指向的是最外层容器组件实例的，而不是包裹组件。
```

- 与其他库整合(Integrating with Other Libraries)

```tsx
// ======= 集成 jQuery Chosen 插件 =======

class Chosen extends React.Component {
  componentDidMount() {
    this.$el = $(this.el);
    this.$el.chosen();

    this.handleChange = this.handleChange.bind(this);
    this.$el.on('change', this.handleChange);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.children !== this.props.children) {
      this.$el.trigger('chosen:updated');
    }
  }

  componentWillUnmount() {
    this.$el.off('change', this.handleChange);
    this.$el.chosen('destroy');
  }

  handleChange(e) {
    this.props.onChange(e.target.value);
  }

  render() {
    return (
      // 这个div标签不能有任何属性或变量
      <div>
        <select className="Chosen-select" ref={el => (this.el = el)}>
          {this.props.children}
        </select>
      </div>
    );
  }
}

// ======== jQuery 代码改写成这样的 React 组件
function Button() {
  return <button id="btn">Say Hello</button>;
}

ReactDOM.render(<Button />, document.getElementById('container'), function() {
  $('#btn').click(function() {
    alert('Hello!');
  });
});
```

- 深入 JSX

```tsx
// JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖
<MyButton color="blue" shadowSize={2}>
  Click Me
</MyButton>;

// => 编译为
React.createElement(MyButton, { color: 'blue', shadowSize: 2 }, 'Click Me');

// ======== 对 JSX 类型使用点语法 ========
import React from 'react';

const MyComponents = {
  DatePicker: function DatePicker(props) {
    return <div>Imagine a {props.color} datepicker here.</div>;
  },
};

function BlueDatePicker() {
  return <MyComponents.DatePicker color="blue" />;
}

// ======== 组件以大写字母开头 ========
import React from 'react';

// 正确！ 这是一个组件，首字母应该大写：
function Hello(props) {
  // 正确！这种使用 <div> 是合法的，因为 div 是一个有效的 HTML 标记：
  return <div>Hello {props.toWhat}</div>;
}

function HelloWorld() {
  // 正确！React 认为 <Hello /> 是一个组件，因为它首字母应是大写的：
  return <Hello toWhat="World" />;
}

// ======== JSX 类型不能是表达式 ========
import React from 'react';
import { PhotoStory, VideoStory } from './stories';

const components = {
  photo: PhotoStory,
  video: VideoStory,
};

function Story(props) {
  // 正确！JSX 类型可以是一个以大写字母开头的变量.
  const SpecificStory = components[props.storyType];
  return <SpecificStory story={props.story} />;
}

// ======== JavaScript 表达式作为 props(属性) =========
// 在 JavaScript 中，if 语句和 for 循环不是表达式，因此不能在 JSX 中直接使用。
// 如果要使用可以按照如下方式使用
function NumberDescriber(props) {
  let description;
  if (props.number % 2 == 0) {
    description = <strong>even</strong>;
  } else {
    description = <i>odd</i>;
  }
  return (
    <div>
      {props.number} is an {description} number
    </div>
  );
}


// 如果你没给 prop(属性) 传值，那么他默认为 true 。下面两个 JSX 表达式是等价的：
<MyTextBox autocomplete />
<MyTextBox autocomplete={true} />

// 属性展开
// 可以使用扩展操作符 ... 传入整个 props 对象。这两个组件是等效的
function App1() {
  return <Greeting firstName="Ben" lastName="Hector" />;
}

function App2() {
  const props = {firstName: 'Ben', lastName: 'Hector'};
  return <Greeting {...props} />;
}

// ======== 可以挑选你的组件将使用的指定属性(props)，同时使用展开运算符传递所有其他属性(props) =======
const Button = props => {
  const { kind, ...other } = props;
  const className = kind === "primary" ? "PrimaryButton" : "SecondaryButton";
  return <button className={className} {...other} />;
};

const App = () => {
  return (
    <div>
      <Button kind="primary" onClick={() => console.log("clicked!")}>
        Hello World!
      </Button>
    </div>
  );
};

// ========= JSX 中的 Children ========
// 这是有效的 JSX ，MyComponent 组件中的 props.children 值为字符串 "Hello world!"
<MyComponent>Hello world!</MyComponent>

// React组件也可以返回一个元素数组：
render() {
  // No need to wrap list items in an extra element!
  return [
    // Don't forget the keys :)
    <li key="A">First item</li>,
    <li key="B">Second item</li>,
    <li key="C">Third item</li>,
  ];
}

// 通过使用 {} 包裹，你可以将任何的 JavaScript 元素而作为 children(子元素) 传递，下面表达式是等价的:
<MyComponent>foo</MyComponent>
<MyComponent>{'foo'}</MyComponent>

// Functions(函数) 作为 Children(子元素)
function Repeat(props) {
  let items = [];
  for (let i = 0; i < props.numTimes; i++) {
    items.push(props.children(i));
  }
  return <div>{items}</div>;
}

function ListOfTenThings() {
  return (
    <Repeat numTimes={10}>
      {(index) => <div key={index}>This is item {index} in the list</div>}
    </Repeat>
  );
}

// Booleans, Null, 和 Undefined 被忽略
// false，null，undefined，和 true 都是有效的的 children(子元素) 。
// 但是并不会被渲染，下面的JSX表达式渲染效果是相同的：
// falsy 值 (虚值) 是在 Boolean 上下文中认定为 false 的值

// ======== 在有条件性渲染 React 元素时非常有用。如果 showHeader 为 true 时，<Header />会被渲染：========
<div>
  {showHeader && <Header />}
  <Content />
</div>

// 需要注意的是“falsy”值，例如数值 0 ，仍然会被 React 渲染。
// 例如，这段代码不会按照你预期的发生，因为当 props.messages 是一个空数组时 0 会被打印：

<div>
  {props.messages.length &&
    <MessageList messages={props.messages} />
  }
</div>
// 要修复这个问题，确保 && 之前的表达式总是布尔值：
<div>
  {props.messages.length > 0 &&
    <MessageList messages={props.messages} />
  }
</div>

// 如果在输出中想要渲染 false ，true，null 或者 undefined ，你必须先将其转化为字符串:
<div>
  My JavaScript variable is {String(myVariable)}.
</div>
```

- 优化性能

```tsx
// 使用生产版本
// 虚拟化长列表
// 避免重新渲染

// 可以通过重写生命周期函数 shouldComponentUpdate 来优化性能，
// 这是在重新渲染过程开始之前触发的。该函数的默认实现中返回的是 true，使得 React 执行更新操作：
shouldComponentUpdate(nextProps, nextState) {
  return true;
}

// 仅当 props.color 或 state.count 发生改变时需要更新
class CounterButton extends React.Component {
  constructor(props) {
    super(props);
    this.state = {count: 1};
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (this.props.color !== nextProps.color) {
      return true;
    }
    if (this.state.count !== nextState.count) {
      return true;
    }
    return false;
  }

  render() {
    return (
      <button
        color={this.props.color}
        onClick={() => this.setState(state => ({count: state.count + 1}))}>
        Count: {this.state.count}
      </button>
    );
  }
}

// 可以使用类似于对 props 和 state 的所有属性进行”浅比较”这种模式来决定组件是否需要更新。
// 这种模式非常普遍，因此 React 提供了一个 helper 实现上面的逻辑：继承 React.PureComponent 。
// 因此，下面的代码是一种更简单的方式实现了相同的功能：
class CounterButton extends React.PureComponent {
  constructor(props) {
    super(props);
    this.state = {count: 1};
  }

  render() {
    return (
      <button
        color={this.props.color}
        onClick={() => this.setState(state => ({count: state.count + 1}))}>
        Count: {this.state.count}
      </button>
    );
  }
}
```

- 插槽(Portals)

```tsx
// 使用方法
// 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。
// 第二个参数（container）则是一个 DOM 元素
ReactDOM.createPortal(child, container);

render() {
  // React *不* 会创建一个新的 div。 它把 children 渲染到 `domNode` 中。
  // `domNode` 可以是任何有效的 DOM 节点，不管它在 DOM 中的位置。
  return ReactDOM.createPortal(
    this.props.children,
    domNode,
  );
}
```

- 声明默认 Props

```tsx
// defaultProps 被定义为组件本身的属性：
class Greeting extends React.Component {}

Greeting.defaultProps = {
  name: 'Mary',
};
```

- 设置初始化 State(状态)

```tsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: props.initialCount };
  }
}
```

- Refs 和 DOM

```tsx
// Refs 提供了一种访问在 render 方法中创建的 DOM 节点或 React 元素的方式
// 下面有一些正好使用 refs 的场景:
// 处理focus、文本选择或者媒体播放
// 触发强制动画
// 集成第三方DOM库

// ======== 创建 Refs ========
// 使用 React.createRef() 创建 refs，通过 ref 属性来获得 React 元素。
// 当构造组件时，refs 通常被赋值给实例的一个属性，这样你可以在组件中任意一处使用它们.
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}

// ======== 访问 Refs ========
// 当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问。

const node = this.myRef.current;

// ref的值取决于节点的类型:
// 当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref 。
// 当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。
// 你不能在函数式组件上使用 ref 属性，因为它们没有实例。

// ======== DOM 元素传入 ref ========
// React 组件在加载时将 DOM 元素传入 ref 的回调函数
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    this.textInput.current.focus();
  }

  render() {
    return (
      <div>
        <input type="text" ref={this.textInput} />

        <input type="button" value="Focus the text input" onClick={this.focusTextInput} />
      </div>
    );
  }
}

// ======== 为 类(Class) 组件添加 Ref ========
// 需要注意的是，这种方法仅对以类(class)声明的 CustomTextInput 有效：
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput();
  }

  render() {
    return <CustomTextInput ref={this.textInput} />;
  }
}

// ======== 可以 在函数式组件内部使用 ref 来引用一个 DOM 元素或者 类(class)组件 ========
function CustomTextInput(props) {
  // textInput必须在这里声明，所以 ref 回调可以引用它
  let textInput = null;

  function handleClick() {
    textInput.focus();
  }

  return (
    <div>
      <input
        type="text"
        ref={input => {
          textInput = input;
        }}
      />

      <input type="button" value="Focus the text input" onClick={handleClick} />
    </div>
  );
}

// ======== 回调 Refs ========
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);

    this.textInput = null;

    this.setTextInputRef = element => {
      this.textInput = element;
    };

    this.focusTextInput = () => {
      // 直接使用原生 API 使 text 输入框获得焦点
      if (this.textInput) this.textInput.focus();
    };
  }

  componentDidMount() {
    // 渲染后文本框自动获得焦点
    this.focusTextInput();
  }

  render() {
    // 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React
    // 实例上（比如 this.textInput）
    return (
      <div>
        <input type="text" ref={this.setTextInputRef} />
        <input type="button" value="Focus the text input" onClick={this.focusTextInput} />
      </div>
    );
  }
}

// ======== 可以在组件间传递回调形式的 refs ========
function CustomTextInput(props) {
  return (
    <div>
      <input ref={props.inputRef} />
    </div>
  );
}

class Parent extends React.Component {
  render() {
    return <CustomTextInput inputRef={el => (this.inputElement = el)} />;
  }
}

// ======== 注意 ========
// 不要过度使用 Refs
```

- 转发 Refs 父组件暴露子组件的 DOM 节点

```tsx
// FancyButton 使用 React.forwardRef 来获取传递给它的 ref ， 然后将其转发给它渲染的的 DOM button：
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```

- 渲染属性(Render Props)

```tsx
// 带有渲染属性(Render Props)的组件需要一个返回 React 元素并调用它的函数，而不是实现自己的渲染逻辑。
class Cat extends React.Component {
  render() {
    const mouse = this.props.mouse;
    return <img src="/cat.jpg" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} />;
  }
}

class Mouse extends React.Component {
  constructor(props) {
    super(props);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove(event) {
    this.setState({
      x: event.clientX,
      y: event.clientY,
    });
  }

  render() {
    return (
      <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}>
        {/*
          Instead of providing a static representation of what <Mouse> renders,
          use the `render` prop to dynamically determine what to render.
        */}
        {this.props.render(this.state)}
      </div>
    );
  }
}

class MouseTracker extends React.Component {
  render() {
    return (
      <div>
        <h1>Move the mouse around!</h1>
        <Mouse render={mouse => <Cat mouse={mouse} />} />
      </div>
    );
  }
}

// 如果 Mouse 继承自 React.PureComponent 而不是 React.Component，我们的例子看起来就像这样
class MouseTracker extends React.Component {
  constructor(props) {
    super(props);
    this.renderTheCat = this.renderTheCat.bind(this);
  }

  renderTheCat(mouse) {
    return <Cat mouse={mouse} />;
  }

  render() {
    return (
      <div>
        <h1>Move the mouse around!</h1>
        <Mouse render={this.renderTheCat} />
      </div>
    );
  }
}
```

- Web 组件(Web Components)

```tsx
// Web组件通常暴露一个必要的API，例如，一个videoWeb组件可能会暴露play()和pause()方法。
// 为访问组件的必要 API，你需要使用一个引用以能够直接和DOM节点交互。
// 若你正在使用第三方Web组件，其最好的解决方案是编写一个 React组件，以包装该 Web组件。

// 由Web组件触发的事件可能无法通过React渲染树来正确冒泡。 你需要手动捕获事件处理器以处理那些在React组件里的事件。
```

- 在 JSX 中如何写注释

```tsx
<div>
  {/* Comment goes here */}
  Hello, {name}!
</div>
```
