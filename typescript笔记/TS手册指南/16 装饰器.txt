/*
* TypeScript装饰器（decorators）
* 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上，可以修改类的行为
* @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入(参数信息来自类)
  TypeScript中装饰器还属于实验性语法，所以要想使用必须在配置文件中tsconfig.json编译选项中开启：
  {
      "compilerOptions": {
          "experimentalDecorators": true
      }
  }
* 修饰器对类的行为的改变，是代码编译时发生的（不是TypeScript编译，而是js在执行机中编译阶段），而不是在运行时。
* 这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。（类似于立即执行）
*/

// 装饰器函数 必须返回一个函数 该函数的参数会取被修饰的类，方法，属性的相关信息
function Path(p1: string, p2: string) {
  return function (target) { //  这才是真正装饰器 js编译阶段就会执行 是最终执行函数
    console.log('' , target); // 装饰的是类，此时target参数是 class HelloService 类本身
    console.log('p1' , p1); // 装饰器自带参数p1
    console.log('p2' , p2); // 装饰器自带参数p2
  }
}

@Path("/hello", "world")
class HelloService {}


/*
* 类装饰器
* 应用于类构造函数，其参数是类的构造函数。
*/

function Path(path: string) {
  return function (target: Function) {
    console.log('' , target); // 装饰的是类，此时target参数是 class HelloService 类本身
    console.log('path' , path); // 装饰器函数自带参数
  };
}

@Path('/hello')
class HelloService {
  constructor() {}
}

/*
* 方法装饰器
* 方法装饰会在运行时传入下列3个参数：
1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2、成员的名字。
3、成员的属性描述符。
*/

function GET(url: string) {
  return function (target, methodName: string, descriptor: PropertyDescriptor) {
    console.log('target', target); // getUser()
    console.log('methodName', methodName); // 方法名 getUser
    console.log('descriptor', descriptor); // 方法的属性描述符。
  }
}

class HelloService {
  constructor() { }
  @GET("xx")
  getUser() { }
}


/*
* 方法参数装饰器
* 方法参数装饰会在运行时传入下列3个参数：
1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2、参数的名字。
3、参数在函数参数列表中的索引。
*/

function PathParam(paramName: string) {
  return function (target, methodName: string, paramIndex: number) {
    console.log('target' , target); // 装饰的是类，此时target参数是 class HelloService 类本身
    console.log('methodName' , methodName); // 方法名 getUser
    console.log('paramIndex' , paramIndex); // 参数在函数参数列表中的索引 0
  }
}

class HelloService {
  constructor() { }
  getUser( @PathParam("userId") userId: string) { }
}

console.log((<any>HelloService).prototype.$Meta); // 确保HelloService下即使没有$Meta属性也不报错


/*
* 属性装饰器
* 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：
1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2、成员的名字。
*/

function DefaultValue(value: string) {
  return function (target: any, propertyName: string) {
    // 传入的参数为 1 构造函数本身 2 属性名
    target[propertyName] = value;
  }
}

class Hello {
  @DefaultValue("world") greeting: string;
}

console.log(new Hello().greeting);// 输出: world 调用属性 实际上是去执行了装饰器方法

/*
* 装饰器加载顺序
1、有多个参数装饰器时：从最后一个参数依次向前执行
2、方法和方法参数中参数装饰器先执行。
3、类装饰器总是最后执行。
4、方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行。
*/

function ClassDecorator() {
  return function (target) {
      console.log("I am class decorator");
  }
}
function MethodDecorator() {
  return function (target, methodName: string, descriptor: PropertyDescriptor) {
      console.log("I am method decorator");
  }
}
function Param1Decorator() {
  return function (target, methodName: string, paramIndex: number) {
      console.log("I am parameter1 decorator");
  }
}
function Param2Decorator() {
  return function (target, methodName: string, paramIndex: number) {
      console.log("I am parameter2 decorator");
  }
}
function PropertyDecorator() {
  return function (target, propertyName: string) {
      console.log("I am property decorator");
  }
}

@ClassDecorator()
class Hello {
  @PropertyDecorator()
  greeting: string;


  @MethodDecorator()
  greet( @Param1Decorator() p1: string, @Param2Decorator() p2: string) { }
}


打印输出结果为：
I am property decorator
I am parameter2 decorator
I am parameter1 decorator
I am method decorator
I am class decorator










注意：
Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。
使用Object.freeze()冻结的对象中的现有属性是不可变的。用Object.seal()密封的对象可以改变其现有属性。





单词 
decorators 装饰器
experimental 实验性的
expression 表达 语法
evaluated 评价
greet 打招呼 欢迎
seal 密封



























