一.一个实现混合的经典案例

// 创建一个用于混合的类
class Disposable {
  isDisposed: boolean;
  dispose() {
      this.isDisposed = true;
  }

}

// 创建一个用于混合的类
class Activatable {
  isActive: boolean;
  activate() {
      this.isActive = true;
  }
  deactivate() {
      this.isActive = false;
  }
}


/**
 * 没使用extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。
 */
class SmartObject implements Disposable, Activatable {
  constructor() {
      setInterval(() => console.log(this.isActive + " : " + this.isDisposed), 500);
  }

  interact() {
      this.activate();
  }

  // 避免在类中实现接口
  // 为将要mixin进来的属性方法创建出占位属性。
  //  这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。

  isDisposed: boolean = false;
  dispose: () => void;
  isActive: boolean = false;
  activate: () => void;
  deactivate: () => void;
}

applyMixins(SmartObject, [Disposable, Activatable]);

let smartObj = new SmartObject();
setTimeout(() => smartObj.interact(), 1000); // 1秒后去改变isActive的值

/**
 * 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。
 * @param derivedCtor 
 * @param baseCtors 
 */
function applyMixins(derivedCtor: any, baseCtors: any[]) {
  baseCtors.forEach(baseCtor => {
      Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
          derivedCtor.prototype[name] = baseCtor.prototype[name];
      });
  });
}


单词 
mixing 混合
disposable 一次性的






















