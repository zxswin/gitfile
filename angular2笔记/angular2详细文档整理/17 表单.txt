==================================简介==================================

一.简单例子

1.响应式表单实现了单个控件
在响应式表单中，表单模型是显式定义在组件类中的。接着，响应式表单指令（这里是 FormControlDirective）
会把这个现有的表单控件实例通过数据访问器（ControlValueAccessor 的实例）来指派给视图中的表单元素。

import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';

@Component({
  selector: 'app-reactive-favorite-color',
  template: `
    Favorite Color: <input type="text" [formControl]="favoriteColorControl">
  `
})
export class FavoriteColorComponent {
  favoriteColorControl = new FormControl('888'); // 表单模型就是 FormControl 的实例。
}

2.模板驱动表单实现了单个控件例子
在模板驱动表单中，权威数据源是模板。
import { Component } from '@angular/core';

@Component({
  selector: 'app-template-favorite-color',
  template: `
    Favorite Color: <input type="text" [(ngModel)]="favoriteColor">
  `
})
export class FavoriteColorComponent {
  favoriteColor = '';
}


二.响应式表单中的数据流

1.从视图到模型
-最终用户在输入框元素中键入了一个值，这里是 "Blue"。
-这个输入框元素会发出一个带有最新值的 "input" 事件。
-这个控件值访问器 ControlValueAccessor 会监听表单输入框元素上的事件，并立即把新值传给 FormControl 实例。
-FormControl 实例会通过 valueChanges 这个可观察对象发出这个新值。
-valueChanges 的任何一个订阅者都会收到这个新值。

2.从模型到视图的数据流
-favoriteColorControl.setValue() 方法被调用，它会更新这个 FormControl 的值。
-FormControl 实例会通过 valueChanges 这个可观察对象发出新值。
-valueChanges 的任何订阅者都会收到这个新值。
-该表单输入框元素上的控件值访问器会把控件更新为这个新值。


三.模板驱动表单中的数据流

1.从视图到模型" 数据流
-最终用户在输入框元素中敲 "Blue"。
-该输入框元素会发出一个 "input" 事件，带着值 "Blue"。
-附着在该输入框上的控件值访问器会触发 FormControl 实例上的 setValue() 方法。
-FormControl 实例通过 valueChanges 这个可观察对象发出新值。
-valueChanges 的任何订阅者都会收到新值。
-控件值访问器 ControlValueAccessory 还会调用 NgModel.viewToModelUpdate() 方法，它会发出一个 ngModelChange 事件。
-由于该组件模板双向数据绑定到了 favoriteColor，组件中的 favoriteColor 属性就会修改为 ngModelChange 事件所发出的值（"Blue"）。

2.从模型到视图的数据流
-组件中修改了 favoriteColor 的值。
-变更检测开始。
-在变更检测期间，由于这些输入框之一的值发生了变化，Angular 就会调用 NgModel 指令上的 ngOnChanges 生命周期钩子。
-ngOnChanges() 方法会把一个异步任务排入队列，以设置内部 FormControl 实例的值。
-变更检测完成。
-在下一个检测周期，用来为 FormControl 实例赋值的任务就会执行。
-FormControl 实例通过可观察对象 valueChanges 发出最新值。
-valueChanges 的任何订阅者都会收到这个新值。
-控件值访问器 ControlValueAccessor 会使用 favoriteColor 的最新值来修改表单的输入框元素。

四.响应式表单和模板驱动表单共同点
无论响应式表单还是模板驱动表单都共享了一些底层构造块。
FormControl 实例用于追踪单个表单控件的值和验证状态。
FormGroup 实例用于追踪一个表单控件集的值和状态。
FormArray 实例用于追踪一个表单控件数组的值和状态。
ControlValueAccessor 用于在 Angular 的 FormControl 实例和原生 DOM 元素之间创建一个桥梁。


五.响应式表单和模板驱动表单差异
响应式	模板驱动
建立（表单模式）	显式，在组件类中创建。	隐式，由组件创建。
数据模式	结构化	非结构化
可预测性	同步	异步
表单验证	函数	指令
可变性	不可变	可变
可伸缩性	访问底层 API	在 API 之上的抽象

响应式表单具备更加高效的检测验证能力

==================================响应式表单==================================
一.第一个案例分析
import { Component } from '@angular/core';
import { FormControl } from '@angular/forms'; //导入 FormControl 类


@Component({
  selector: 'login',
  templateUrl: './login.component.pug',
  styleUrls: ['./login.component.less'],
 
})
export class LoginComponent {
  name = new FormControl(''); // 并创建一个 FormControl 的新实例

  updateName() {
    this.name.setValue('Nancy'); // 设置一个新值
  }
}

===pug===
label 
  |Name:
  input(type="text",[formControl]="name")

p  Value: {{ name.value }}

p 
  button((click)="updateName()") Update Name


二.第二个案例分析 FormBuilder Validators FormArray
import { Component } from '@angular/core';
import { FormBuilder } from '@angular/forms'; // FormBuilder 服务提供了一些便捷方法来生成表单控件
import { Validators } from '@angular/forms'; // 导入验证器函数
import { FormArray } from '@angular/forms'; // 导入 FormArray，以使用它的类型信息。FormBuilder 服务用于创建 FormArray 实例。


@Component({
  selector: 'login',
  templateUrl: './login.component.pug',
  styleUrls: ['./login.component.less'],
 
})
export class LoginComponent {

  //FormBuilder 服务提供了一些便捷方法来生成表单控件
  profileForm = this.fb.group({
    firstName: ['', Validators.required],
    lastName: [''],
    address: this.fb.group({
      street: [''],
      city: [''],
      state: [''],
      zip: ['']
    }),

    //FormBuilder 服务用于创建 FormArray 实例
    aliases: this.fb.array([
      this.fb.control('')
    ])
  });

  get aliases() { 
    // 可以直接使用 this.aliases 获取数组的值
    return this.profileForm.get('aliases') as FormArray; //获取数组的值
  }

  constructor(private fb: FormBuilder) { }


  updateProfile() {
    //patchValue() 只会更新表单模型中所定义的那些属性。 仅仅更新修改的值 setValue() 方法则更新所有
    this.profileForm.patchValue({
      firstName: 'Nancy',
      address: {
        street: '123 Drew Street'
      }
    });
  }

  addAlias() {
    this.aliases.push(this.fb.control(''));
  }

  onSubmit() {
    // TODO: Use EventEmitter with form value
    console.warn(this.profileForm.value);
  }
}

===pug结构===
form([formGroup]="profileForm",(ngSubmit)="onSubmit()")
  label 
    |First Name:
    input(type="text", formControlName="firstName" ,required)
  label 
    |Last Name:
    input(type="text", formControlName="lastName")
  
  div(formGroupName="address")
    h3 Address
    label 
      |Street:
      input(type="text" , formControlName="street")
    label 
      |City:
      input(type="text" , formControlName="city")
    label 
      |State:
      input(type="text" , formControlName="state")
    label 
      |Zip Code:
      input(type="text" , formControlName="zip")

  div(formArrayName="aliases")
    h3 Aliases
    button((click)="addAlias()") Add Alias
    div(*ngFor="let address of aliases.controls; let i=index")
      label 
        |Alias:
        input(type="text",[formControlName]="i")

  button(type="submit",[disabled]="!profileForm.valid")
    
hr 
p Form Value: {{ profileForm.value | json }}
p Form Status: {{ profileForm.status }}
p 
  button((click)="updateProfile()") Update Profile



三.主要知识点
1.使用响应式表单需要先注册 ReactiveFormsModule
import { ReactiveFormsModule } from '@angular/forms';

@NgModule({
  imports: [
    // other imports ...
    ReactiveFormsModule
  ],
})
export class AppModule { }

2.当使用响应式表单时，FormControl 类是最基本的构造块。
-使用 value 属性。它能让你获得当前值的一份快照。Value: {{ name.value }}
-通过 setValue() 方法来把原来的值替换为新的值。this.name.setValue('Nancy');

3.FormGroup 的实例也能跟踪一组 FormControl 实例（比如一个表单）的表单状态。
import { Component } from '@angular/core';
import { FormGroup, FormControl } from '@angular/forms';
 
@Component({
  selector: 'app-profile-editor',
  templateUrl: './profile-editor.component.html',
  styleUrls: ['./profile-editor.component.css']
})
export class ProfileEditorComponent {
  profileForm = new FormGroup({
    firstName: new FormControl(''),
    lastName: new FormControl(''),
  });
}

<form [formGroup]="profileForm">
  <label>
    First Name:
    <input type="text" formControlName="firstName">
  </label>

  <label>
    Last Name:
    <input type="text" formControlName="lastName">
  </label>
</form>

4.把 onSubmit() 回调方法添加为 form 标签上的 ngSubmit 事件监听器。
<form [formGroup]="profileForm" (ngSubmit)="onSubmit()">

5.创建嵌套的分组
profileForm = new FormGroup({
    firstName: new FormControl(''),
    lastName: new FormControl(''),
    address: new FormGroup({
      street: new FormControl(''),
      city: new FormControl(''),
      state: new FormControl(''),
      zip: new FormControl('')
    })
  });

<div formGroupName="address">
  <h3>Address</h3>

  <label>
    Street:
    <input type="text" formControlName="street">
  </label>

  <label>
    City:
    <input type="text" formControlName="city">
  </label>
  
  <label>
    State:
    <input type="text" formControlName="state">
  </label>

  <label>
    Zip Code:
    <input type="text" formControlName="zip">
  </label>
</div>

6.修补（Patching）模型值
使用 setValue() 方法来为单个控件设置新值。 setValue() 方法会严格遵循表单组的结构，并整体性替换控件的值。
使用 patchValue() 方法可以用对象中所定义的任何属性为表单模型进行替换。

7.使用 FormBuilder 来生成表单控件
FormBuilder 服务有三个方法：control()、group() 和 array()。这些方法都是工厂方法，用于在组件类中分别生成 FormControl、FormGroup 和 FormArray。
import { Component } from '@angular/core';
import { FormBuilder } from '@angular/forms';
 
@Component({
  selector: 'app-profile-editor',
  templateUrl: './profile-editor.component.html',
  styleUrls: ['./profile-editor.component.css']
})
export class ProfileEditorComponent {
  profileForm = this.fb.group({
    firstName: [''],
    lastName: [''],
    address: this.fb.group({
      street: [''],
      city: [''],
      state: [''],
      zip: ['']
    }),
  });
 
  constructor(private fb: FormBuilder) { }
}

8.这些 HTML5 验证器属性可以和 Angular 响应式表单提供的内置验证器组合使用。组合使用这两种验证器实践，可以防止在模板检查完之后表达式再次被修改导致的错误。
7.通过该 FormGroup 实例的 status 属性来访问其当前状态
{{ profileForm.status }}

9.使用表单数组管理动态控件
FormBuilder 服务用于创建 FormArray 实例。
使用 FormBuilder.array() 方法来定义该数组，并用 FormBuilder.control() 方法来往该数组中添加一个初始控件。

profileForm = this.fb.group({
  firstName: ['', Validators.required],
  lastName: [''],
  address: this.fb.group({
    street: [''],
    city: [''],
    state: [''],
    zip: ['']
  }),
  aliases: this.fb.array([
    this.fb.control('')
  ])
});

使用 getter 语法创建类属性 aliases，以从父表单组中接收表示绰号的表单数组控件
get aliases() {
  return this.profileForm.get('aliases') as FormArray;
}

<div formArrayName="aliases">
  <h3>Aliases</h3> <button (click)="addAlias()">Add Alias</button>

  <div *ngFor="let address of aliases.controls; let i=index">
    <!-- The repeated alias template -->
    <label>
      Alias:
      <input type="text" [formControlName]="i">
    </label>
  </div>
</div>


响应式表单 API
下面列出了用于创建和管理表单控件的基础类和服务。
AbstractControl
所有三种表单控件类（FormControl、FormGroup 和 FormArray）的抽象基类。它提供了一些公共的行为和属性。
FormControl
管理单体表单控件的值和有效性状态。它对应于 HTML 的表单控件，比如 <input> 或 <select>。
FormGroup
管理一组 AbstractControl 实例的值和有效性状态。该组的属性中包括了它的子控件。组件中的顶级表单就是 FormGroup。
FormArray
管理一些 AbstractControl 实例数组的值和有效性状态。
FormBuilder
一个可注入的服务，提供一些用于提供创建控件实例的工厂方法。
FormControlDirective
把一个独立的 FormControl 实例绑定到表单控件元素。
FormControlName
把一个现有 FormGroup 中的 FormControl 实例根据名字绑定到表单控件元素。
FormGroupDirective
把一个现有的 FormGroup 实例绑定到 DOM 元素。
FormGroupName
把一个内嵌的 FormGroup 实例绑定到一个 DOM 元素。
FormArrayName
把一个内嵌的 FormArray 实例绑定到一个 DOM 元素。


=========================================模板驱动表格=========================================
1.注意
  当在表单中使用[(ngModel)]时，必须要定义name属性。
  NgForm指令为form增补了一些额外特性。 它会控制那些带有ngModel指令和name属性的元素，监听他们的属性（包括其有效性）
  它还有自己的valid属性，这个属性只有在它包含的每个控件都有效时才是真。
  每个 input 元素都有name属性，Angular 表单用它注册控件。使用name属性值作为键值
2.添加模板引擎变量
  <input type="text" class="form-control" id="name" required [(ngModel)]="hero.name" name="name" #syp/>
  <p>模板引擎类名状态syp.className变化值：{{syp.className}}</p>
  1.控件被访问过   ng-touched(真)	   ng-untouched(假)
  2.控件的值变化了 ng-dirty(真)	     ng-pristine(假)
  3.控件的值有效   ng-valid	(真)      ng-invalid(假)
  4.类似这样控制必填字段的样式
    .ng-valid[required], .ng-valid.required  {------(字段为有效值的时候)
      border-left: 5px solid #42A948;
    }
    .ng-invalid:not(form)  {---------(字段为无效值的时候)
      border-left: 5px solid #a94442;
    }
  5.这里把name设置为ngModel是因为ngModel指令的exportAs属性设置成了 “ngModel”。
      <input type="text" class="form-control" id="name" required [(ngModel)]="hero.name" name="name" #name="ngModel"/>-----(模板变量设置为#name="ngModel")
        <div [hidden]="name.valid||name.pristine" class="alert alert-danger">名字是必填的哦！</div>
        -----([hidden]值为真的时候隐藏,值无效，值变化的时候显示,即为空的时候显示)
        <p>修改了英雄的名字：{{hero.name}}</p>
        <p>模板引擎类名状态name.className变化值：{{name.className}}</p>---(此时{{name.className}}为空)
  6.使用*ngIf改进写法,可以提升性能
      <div *ngIf="!name.valid&&!name.pristine" class="alert alert-danger">名字是必填的哦！</div>
  7.表单的提交
    <form (ngSubmit)="onSubmit()" #heroForm="ngForm">----(定义了表单提交事件和模板引擎)
    <button type="submit" class="btn btn-success" [disabled]="!heroForm.form.valid">Submit</button>
    ------(控制表单提交按钮的状态 heroForm.form.valid判断变动是否有必填字段未填写)
  8.表单demo全
    <h1>{{hero.name}}</h1>
    <div class="form-group">
      <form (ngSubmit)="onSubmit()" #heroForm="ngForm">
        <label for="power">英雄技能</label>
        <select class="form-control" id="power" required>
          <option *ngFor="let pow of powers" [value]="pow">{{pow}}</option>
        </select>
        <input type="text" class="form-control" id="name" required [(ngModel)]="hero.name" name="name" #name="ngModel"/>
        <div *ngIf="!name.valid&&!name.pristine" class="alert alert-danger">名字是必填的哦！</div>
        <input type="text" class="form-control"  [(ngModel)]="hero.age" name="age" #age="ngModel"/>
        <div *ngIf="!age.valid&&!age.pristine" class="alert alert-danger">年龄是必填的哦！</div>
        <p>修改了英雄的名字：{{hero.name}}</p>
        <p>模板引擎类名状态name.className变化值：{{name.className}}</p>
        <p>{{heroForm.form.valid}}</p>
        <button type="submit" class="btn btn-success" [disabled]="!heroForm.form.valid">提交内容</button>
      </form>
    </div>



=========================================表单验证=========================================
一.模板驱动验证
<input> 元素带有一些 HTML 验证属性：required 和 minlength。它还带有一个自定义的验证器指令 forbiddenName。要了解更多信息，参见自定义验证器一节。
#name="ngModel" 把 NgModel 导出成了一个名叫 name 的局部变量。NgModel 把自己控制的 FormControl 实例的属性映射出去，让你能在模板中检查控件的状态，比如 valid 和 dirty。要了解完整的控件属性，参见 API 参考手册中的AbstractControl。
<div> 元素的 *ngIf 揭露了一套嵌套消息 divs，但是只在有“name”错误和控制器为 dirty 或者 touched。
每个嵌套的 <div> 为其中一个可能出现的验证错误显示一条自定义消息。比如 required、minlength 和 forbiddenName。

<input id="name" name="name" class="form-control"
      required minlength="4" appForbiddenName="bob"
      [(ngModel)]="hero.name" #name="ngModel" >

<div *ngIf="name.invalid && (name.dirty || name.touched)"
    class="alert alert-danger">

  <div *ngIf="name.errors.required">
    Name is required.
  </div>
  <div *ngIf="name.errors.minlength">
    Name must be at least 4 characters long.
  </div>
  <div *ngIf="name.errors.forbiddenName">
    Name cannot be Bob.
  </div>

</div>


二.响应式表单的验证
1.有两种验证器函数：同步验证器和异步验证器。
同步验证器函数接受一个控件实例，然后返回一组验证错误或 null。你可以在实例化一个 FormControl 时把它作为构造函数的第二个参数传进去。
异步验证器函数接受一个控件实例，并返回一个承诺（Promise）或可观察对象（Observable），它们稍后会发出一组验证错误或者 null。你可以在实例化一个 FormControl 时把它作为构造函数的第三个参数传进去。
注意：出于性能方面的考虑，只有在所有同步验证器都通过之后，Angular 才会运行异步验证器。当每一个异步验证器都执行完之后，才会设置这些验证错误。

2.使用内置验证器
name 控件设置了两个内置验证器：Validators.required 和 Validators.minLength(4)。要了解更多信息，参见本章的自定义验证器一节。
由于这些验证器都是同步验证器，因此你要把它们作为第二个参数传进去。
可以通过把这些函数放进一个数组后传进去，可以支持多重验证器。
这个例子添加了一些 getter 方法。在响应式表单中，你通常会通过它所属的控件组（FormGroup）的 get 方法来访问表单控件，但有时候为模板定义一些 getter 作为简短形式。

ngOnInit(): void {
  this.heroForm = new FormGroup({
    'name': new FormControl(this.hero.name, [
      Validators.required,
      Validators.minLength(4),
      forbiddenNameValidator(/bob/i) // <-- Here's how you pass in the custom validator.
    ]),
    'alterEgo': new FormControl(this.hero.alterEgo),
    'power': new FormControl(this.hero.power, Validators.required)
  });

}
get name() { return this.heroForm.get('name'); }
get power() { return this.heroForm.get('power'); }


<input id="name" class="form-control"
      formControlName="name" required >

<div *ngIf="name.invalid && (name.dirty || name.touched)"
    class="alert alert-danger">

  <div *ngIf="name.errors.required">
    Name is required.
  </div>
  <div *ngIf="name.errors.minlength">
    Name must be at least 4 characters long.
  </div>
  <div *ngIf="name.errors.forbiddenName">
    Name cannot be Bob.
  </div>
</div>

3.使用自定义验证器
自定义异步验证器和同步验证器很像，只是它们必须返回一个稍后会输出 null 或“验证错误对象”的承诺（Promise）或可观察对象，
如果是可观察对象，那么它必须在某个时间点被完成（complete），那时候这个表单就会使用它输出的最后一个值作为验证结果。
（译注：HTTP 服务是自动完成的，但是某些自定义的可观察对象可能需要手动调用 complete 方法）
/** A hero's name can't match the given regular expression */
export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {
  return (control: AbstractControl): {[key: string]: any} | null => {
    const forbidden = nameRe.test(control.value);
    return forbidden ? {'forbiddenName': {value: control.value}} : null;
  };
}

4.自定义验证器添加响应式表单
this.heroForm = new FormGroup({
  'name': new FormControl(this.hero.name, [
    Validators.required,
    Validators.minLength(4),
    forbiddenNameValidator(/bob/i) // <-- Here's how you pass in the custom validator.
  ]),
  'alterEgo': new FormControl(this.hero.alterEgo),
  'power': new FormControl(this.hero.power, Validators.required)
});

5.自定义验证器添加到模板驱动表单
@Directive({
  selector: '[appForbiddenName]',
  // 如果用 useClass 来代替 useExisting，就会注册一个新的类实例，而它是没有 forbiddenName 的。
  providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]
})
export class ForbiddenValidatorDirective implements Validator {
  @Input('appForbiddenName') forbiddenName: string;
 
  validate(control: AbstractControl): {[key: string]: any} | null {
    return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)
                              : null;
  }
}

<input id="name" name="name" class="form-control"
      required minlength="4" appForbiddenName="bob"
      [(ngModel)]="hero.name" #name="ngModel" >

6.表示控件状态的 CSS 类
.ng-valid
.ng-invalid
.ng-pending
.ng-pristine
.ng-dirty
.ng-untouched
.ng-touched

7.跨字段交叉验证(响应式模型驱动表单中)
const heroForm = new FormGroup({
  'name': new FormControl(),
  'alterEgo': new FormControl(),
  'power': new FormControl()
}, { validators: identityRevealedValidator });

/** A hero's name can't match the hero's alter ego */
export const identityRevealedValidator: ValidatorFn = (control: FormGroup): ValidationErrors | null => {
  const name = control.get('name');
  const alterEgo = control.get('alterEgo');

  return name && alterEgo && name.value === alterEgo.value ? { 'identityRevealed': true } : null;
};

<div *ngIf="heroForm.errors?.identityRevealed && (heroForm.touched || heroForm.dirty)" class="cross-validation-error-message alert alert-danger">
    Name cannot match alter ego.
</div>

8.跨字段交叉验证(模板驱动表单中)
@Directive({
  selector: '[appIdentityRevealed]',
  providers: [{ provide: NG_VALIDATORS, useExisting: IdentityRevealedValidatorDirective, multi: true }]
})
export class IdentityRevealedValidatorDirective implements Validator {
  validate(control: AbstractControl): ValidationErrors {
    return identityRevealedValidator(control)
  }
}

<form #heroForm="ngForm" appIdentityRevealed>

<div *ngIf="heroForm.errors?.identityRevealed && (heroForm.touched || heroForm.dirty)" class="cross-validation-error-message alert alert-danger">
    Name cannot match alter ego.
</div>

9.异步验证
就像同步验证器有 ValidatorFn 和 Validator 接口一样，异步验证器也有自己的对应物：AsyncValidatorFn 和 AsyncValidator。
它们必须返回承诺（Promise）或可观察对象（Observable），
返回的可观察对象必须是有限的，也就是说，它必须在某个时间点结束（complete）。要把无尽的可观察对象转换成有限的，可以使用 first、last、take 或 takeUntil 等过滤型管道对其进行处理。

常见的 UI 处理模式是在执行异步验证时显示一个旋转指示标（spinner）。下面的例子展示了在模板驱动表单中该怎么做：

<input [(ngModel)}="name" #model="ngModel" appSomeAsyncValidator>
<app-spinner *ngIf="model.pending"></app-spinner>

实现自定义异步验证器
@Injectable({ providedIn: 'root' })
export class UniqueAlterEgoValidator implements AsyncValidator {
  constructor(private heroesService: HeroesService) {}

  validate(
    ctrl: AbstractControl
  ): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> {
    return this.heroesService.isAlterEgoTaken(ctrl.value).pipe(
      map(isTaken => (isTaken ? { uniqueAlterEgo: true } : null)),
      catchError(() => null)
    );
  }
}

interface HeroesService {
  isAlterEgoTaken: (alterEgo: string) => Observable<boolean>;
}

我们可以把 updateOn 属性从 change（默认值）改成 submit 或 blur 来推迟表单验证的更新时机。
-对于模板驱动表单：
<input [(ngModel)]="name" [ngModelOptions]="{updateOn: 'blur'}">
-对于响应式表单：
new FormControl('', {updateOn: 'blur'});



=========================================动态表单=========================================
export class QuestionBase<T> {
  value: T;
  key: string;
  label: string;
  required: boolean;
  order: number;
  controlType: string;
 
  constructor(options: {
      value?: T,
      key?: string,
      label?: string,
      required?: boolean,
      order?: number,
      controlType?: string
    } = {}) {
    this.value = options.value;
    this.key = options.key || '';
    this.label = options.label || '';
    this.required = !!options.required;
    this.order = options.order === undefined ? 1 : options.order;
    this.controlType = options.controlType || '';
  }
}

import { QuestionBase } from './question-base';

export class TextboxQuestion extends QuestionBase<string> {
  controlType = 'textbox';
  type: string;

  constructor(options: {} = {}) {
    super(options);
    this.type = options['type'] || '';
  }
}

import { QuestionBase } from './question-base';

export class DropdownQuestion extends QuestionBase<string> {
  controlType = 'dropdown';
  options: {key: string, value: string}[] = [];

  constructor(options: {} = {}) {
    super(options);
    this.options = options['options'] || [];
  }
}

import { Injectable }   from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';

import { QuestionBase } from './question-base';

@Injectable()
export class QuestionControlService {
  constructor() { }

  toFormGroup(questions: QuestionBase<any>[] ) {
    let group: any = {};

    questions.forEach(question => {
      group[question.key] = question.required ? new FormControl(question.value || '', Validators.required)
                                              : new FormControl(question.value || '');
    });
    return new FormGroup(group);
  }
}

import { Injectable }       from '@angular/core';
 
import { DropdownQuestion } from './question-dropdown';
import { QuestionBase }     from './question-base';
import { TextboxQuestion }  from './question-textbox';
 
@Injectable()
export class QuestionService {
 
  // TODO: get from a remote source of question metadata
  // TODO: make asynchronous
  getQuestions() {
 
    let questions: QuestionBase<any>[] = [
 
      new DropdownQuestion({
        key: 'brave',
        label: 'Bravery Rating',
        options: [
          {key: 'solid',  value: 'Solid'},
          {key: 'great',  value: 'Great'},
          {key: 'good',   value: 'Good'},
          {key: 'unproven', value: 'Unproven'}
        ],
        order: 3
      }),
 
      new TextboxQuestion({
        key: 'firstName',
        label: 'First name',
        value: 'Bombasto',
        required: true,
        order: 1
      }),
 
      new TextboxQuestion({
        key: 'emailAddress',
        label: 'Email',
        type: 'email',
        order: 2
      })
    ];
 
    return questions.sort((a, b) => a.order - b.order);
  }
}

import { Component }       from '@angular/core';
 
import { QuestionService } from './question.service';
 
@Component({
  selector: 'app-root',
  template: `
    <div>
      <h2>Job Application for Heroes</h2>
      <app-dynamic-form [questions]="questions"></app-dynamic-form>
    </div>
  `,
  providers:  [QuestionService]
})
export class AppComponent {
  questions: any[];
 
  constructor(service: QuestionService) {
    this.questions = service.getQuestions();
  }
}



同步校验器 和异步校验器使用案例
export class LoginComponent {
  validateForm: FormGroup;
  submitForm = ($event, value) => {
    $event.preventDefault();
    for (const key in this.validateForm.controls) {
      this.validateForm.controls[ key ].markAsDirty();
      this.validateForm.controls[ key ].updateValueAndValidity();
    }
    console.log(value);
  };

  resetForm(e: MouseEvent): void {
    e.preventDefault();
    this.validateForm.reset();
    for (const key in this.validateForm.controls) {
      this.validateForm.controls[ key ].markAsPristine();
      this.validateForm.controls[ key ].updateValueAndValidity();
    }
  }

  validateConfirmPassword(): void {
    setTimeout(() => this.validateForm.controls.confirm.updateValueAndValidity());
  }

  userNameAsyncValidator = (control: FormControl) => Observable.create((observer: Observer<ValidationErrors>) => {
    // 自定义异步校验器
    setTimeout(() => {
      if (control.value === 'JasonWood') {
        observer.next({ error: true, duplicated: true });
      } else {
        observer.next(null);
      }
      observer.complete();
    }, 1000);
  });

  confirmValidator = (control: FormControl): { [ s: string ]: boolean } => {
    // 同步校验器
    //  { [ s: string ]: boolean } 返回 {key:value} key是string类型 value是boolean类型
    if (!control.value) {
      return { required: true };
    } else if (control.value !== this.validateForm.controls.password.value) {
      // validateForm.get('confirm').hasError('confirm') 通过这样可获取对应的错误
      return { confirm: true, error: true };
    }
  };

  constructor(private fb: FormBuilder) {
    this.validateForm = this.fb.group({
      userName: [ '', [ Validators.required ], [ this.userNameAsyncValidator ] ], // 第三个参数用于添加异步校验器
      email   : [ '', [ Validators.email ] ],
      password: [ '', [ Validators.required ] ],
      confirm : [ '', [ this.confirmValidator ] ], // 添加同步校验器
      comment : [ '', [ Validators.required ] ]
    });
  }
}




注意:
1.JavaScript get set方法 ES5/ES6写法

get / set 有点类似于语法糖的作用 

class Num {
  constructor(num) {
    this._num = num;
  }
   
  get num() {
    return this._num;
  }
   
  set num(num) {
    this._num = num;
  }
}
 
var test = new Num(9);
console.log(test.num);
test.num = 99;
console.log(test.num);





单词：
accessor 存取器
abstract 摘要
profile 外形 轮廓
untouched 未触及的
patch 补丁 修理
builder 建设者
validator 验证器
required 必修 必填
invalid 无效
aliases 别名
ego 自我
generate 生成
diagnostic 诊断的
container 容器
ToDo 备忘录 代办事项
dirty 肮脏的
pristine 原始的
forbidden 被禁止的
existing 现存的
pending 悬而未决的 



