# RxJs 核心知识点

## 函数 遍历器 Promise Observable 的特点

```bash
函数 调用后同步计算并返回单一值
生成器函数 | 遍历器 遍历过程中同步计算并返回0个到无穷多个值
Promise 异步执行中返回或者不返回单一值
Observable 同步或者异步计算并返回0个到无穷多个值
```

## 核心概念之 Observable(可观察者对象)

- 纯 JavaScript 代码展示可观察值对象实现原理

```js
/**  observer 参数就是 观察者 被订阅后会执行next方法回调*/
function subscribe(observer) {
  var intervalID = setInterval(() => {
    observer.next('hi');
  }, 1000);

  return function unsubscribe() {
    clearInterval(intervalID);
  };
}

/**
 * 订阅实际上就是具体的观察者的实现 next回调函数的具体实现
 * 订阅可观察者对象后会产生返回unsubscribe函数 用于取消订阅操作
 */
var unsubscribe = subscribe({ next: x => console.log(x) });

// 一段时间后:
unsubscribe(); // 终止
```

- 可观察者对象使用最佳实践

```js
/**
 * 除了使用create创建Observable，我们通常还使用创建操作符, 如 of，from， interval, 等来创建Observable
 * Observable在执行过程中，可以推送三种类型的值：
 * "Next" 通知： 实际产生的数据，包括数字、字符串、对象等 表示事件传递给观察者的数据
 * "Error" 通知：一个JavaScript错误或者异常
 * "Complete" 通知：一个不带有值的事件
 * 错误和完成通知仅会在执行阶段推送其一，并不会同时推送错误和完成通知。
 * 在错误或者完成通知被推送后，Observable不会再推送任何其他通知。
 * 观察者并不需要在Observable中进行注册，Observable也不需要维护订阅者的列表。
 */
var observable = Rx.Observable.create(function subscribe(observer) {
  try {
    observer.next(1);
    observer.next(2);
    observer.next(3);
    observer.complete(); // 结束
  } catch (err) {
    observer.error(err); // 捕获异常后推送错误通知
  }
});
/** 订阅这个可观察者对象  */
observable.subscribe({
  next: v => {}, // 订阅可观察者对象发送值的时候执行
  complete: () => {}, // 订阅可观察者对象完结的时候执行
  err: () => {} // 订阅可观察者对象发送错误的时候执行
});
```

- 可观察者对象分析

```js
/**
 * 核心概念
 * 如果不去订阅可观察者对象 Observable 则什么都不会执行
 * 两次订阅同样会产生两个独立的作用域 Observable不会被共享
 * 可观察者订阅的时候传入的参数可以只是一个回调函数，不需要一定有next: (v) => {}
 */
/** 创建一个可观察者对象  */
var foo = Rx.Observable.create(function(observer) {
  console.log('Hello');
  observer.next(42);
});

/** 添加了一个观察者  产生一个独立的作用域*/
foo.subscribe(function(x) {
  console.log(x);
});

/** 再添加一个观察者  参数一个独立的作用域*/
foo.subscribe(function(y) {
  console.log(y);
});

/**
 * 打印结果
  "Hello"
  42
  "Hello"
  42
 */
```

- 取消订阅可观察者

```js
/**
 * 在observable.subscribe被调用时(可观察者对象被订阅后)，观察者会与其执行作用域绑定，同时返回一个Subscription类型的对象
 */
var observable = Rx.Observable.from([10, 20, 30]);
/** 订阅后 可观察者对象会返回一个 Subscription类型的对象  */
var subscription = observable.subscribe(x => console.log(x));
/** 可以通过 Subscription类型的对象来取消订阅 */
subscription.unsubscribe();
```

## Observer 观察者

- 一个典型的观察者对象

```js
/** 创建一个可观察者对象  */
var observable = Rx.Observable.create(function subscribe(observer) {
  try {
    observer.next(1);
    observer.next(2);
    observer.next(3);
    observer.complete(); // 结束
  } catch (err) {
    observer.error(err); // 捕获异常后推送错误通知
  }
});
/**
 * 观察者们(Observers)就是一组callback函数的集合
 * 监听着每一个Observable流推送出的不同类型的通知，包括:next,error和complete。
 */
var observer = {
  next: x => console.log('Observer got a next value: ' + x),
  error: err => console.error('Observer got an error: ' + err),
  complete: () => console.log('Observer got a complete notification')
};

/** 观察者 订阅 可观察者对象  */
observable.subscribe(observer);
```

- 创建观察者的其他写法

```js
/**
 * 如果没有为某个类型的通知提供callback，Observable流的执行过程仍然会照常进行，
 * 但是响应的通知将会被忽略，因为观察者没有提供相应的callback来接收。
 */

var observer = {
  next: x => console.log('Observer got a next value: ' + x),
  error: err => console.error('Observer got an error: ' + err)
};

/**
 * 在observable.subscribe()内部，将会创建一个观察者对象(Observer object)，
 * 并将第一个参数提供的callback作为next通知的响应函数。接受三个类型通知的callback也可以分别以参数的形式提供:
 */
observable.subscribe(
  x => console.log('Observer got a next value: ' + x),
  err => console.error('Observer got an error: ' + err),
  () => console.log('Observer got a complete notification')
);
```

## Subscription 对象

- Subscription 的具体用法

```js
/**
 * Subscription是一个代表可以终止资源的对象，表示一个Observable的执行过程。
 * Subscription能够通过unsubscribe() 函数终止Observable的执行过程并释放相应资源。
 * Subscription提供了remove(otherSubscription)方法，可以删除一个Subscription嵌套的子Subscription
 */
var observable = Rx.Observable.interval(1000);
var subscription = observable.subscribe(x => console.log(x));

/** 取消对可观察者对象资源的订阅  */
subscription.unsubscribe();
```

- Subscription 可以嵌套使用

```js
var observable1 = Rx.Observable.interval(400);
var observable2 = Rx.Observable.interval(300);

var subscription = observable1.subscribe(x => console.log('first: ' + x));
var childSubscription = observable2.subscribe(x => console.log('second: ' + x));

/** 通过add方法，便可以实现Subscription的嵌套：  */
subscription.add(childSubscription);

setTimeout(() => {
  // 终止所有嵌套的Subscription
  subscription.unsubscribe();
}, 1000);
```

## Subject 主题

- 一个简单的 Subject 用法(作为可观察者对象被订阅)

```js
/**
 * 每一个Subject都是一个Observable（可观察对象
 * Subject是一类特殊的Observable，它可以向多个Observer多路推送数值
 * 每一个Observer都有自己独立的执行环境，而Subject可以共享一个执行环境。
 * Subject是一种可以多路推送的可观察对象。与EventEmitter类似，Subject维护着自己的Observer。
 */

/** 创建一个主题  */
var subject = new Rx.Subject();

/** 注册观察者1  */
subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

/** 注册观察者2  */
subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

subject.next(1);
subject.next(2);
/* 
  控制台输出结果如下：
  observerA: 1
  observerB: 1
  observerA: 2
  observerB: 2
 */
```

- 一个简单的 Subject 用法(作为一个观察者)

```js
/**
 * Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数
 */

/** 创建一个 Subject 对象 */
var subject = new Rx.Subject();

/** 注册观察者1  */
subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

/** 注册观察者2  */
subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

/** 创建一个普通的可观察者对象  */
var observable = Rx.Observable.from([1, 2, 3]);

/**
 * Subject作为一个观察者 去订阅这个普通的可观察者对象
 * Subject的作用——作为单路Observable转变为多路Observable的桥梁。
 */
observable.subscribe(subject); // 你可以传递Subject来订阅observable

/*
  执行后结果如下：
  observerA: 1
  observerB: 1
  observerA: 2
  observerB: 2
  observerA: 3
  observerB: 3
*/
```

- 使用 multicast() 和 connect() 方法 然普通的 Observable 实现多路推送

```js
/** 创建了一共可观察者对象  */
var source = Rx.Observable.from([1, 2, 3]);
/** 创建了一共主题  */
var subject = new Rx.Subject();
/**
 * 使用multicast multicast 返回的对象同时是ConnectableObservable类型的，拥有connect() 方法
 * multicast方法返回一个类似于Observable的可观察对象，但是在其被订阅后，它会表现Subject的特性。
 */
var multicasted = source.multicast(subject);

// 通过`subject.subscribe({...})`订阅Subject的Observer观察者：
multicasted.subscribe({
  next: v => console.log('observerA: ' + v)
});
multicasted.subscribe({
  next: v => console.log('observerB: ' + v)
});

/**
 * 调用connect()后，Observable开始执行  让Subject从数据源订阅开始生效
 * connect()会返回一个Subscription供调用者来终止执行
 */
multicasted.connect();
```

- refCount(引用计数) 使得多路推送的 Observable 在被订阅后自动执行，在所有观察者取消订阅后，停止执行。

```js
/**
 * 第一个Observer订阅Subject后自动connnect，当所有Observer都取消订阅后终止这个Subject。
 * 在ConnectableObservable类型的Observable上调用refCount()方法
 * 方法会进行引用计数：记录Observable被订阅的行为。当订阅数从 0 到 1时refCount() 会调用connect() 方法。
 * 到订阅数从1 到 0，他会终止整个执行过程。
 */

var source = Rx.Observable.interval(500);
var subject = new Rx.Subject();
/** 调用后会返回一个Observable而不是新的ConnectableObservable。  */
var refCounted = source.multicast(subject).refCount();
var subscription1, subscription2, subscriptionConnect;

console.log('observerA subscribed');
subscription1 = refCounted.subscribe({
  next: v => console.log('observerA: ' + v)
});

setTimeout(() => {
  console.log('observerB subscribed');
  subscription2 = refCounted.subscribe({
    next: v => console.log('observerB: ' + v)
  });
}, 600);

setTimeout(() => {
  console.log('observerA unsubscribed');
  subscription1.unsubscribe();
}, 1200);

setTimeout(() => {
  console.log('observerB unsubscribed');
  subscription2.unsubscribe();
}, 2000);

/*
  执行输出结果如下:
  observerA subscribed
  observerA: 0
  observerB subscribed
  observerA: 1
  observerB: 1
  observerA unsubscribed
  observerB: 2
  observerB unsubscribed
*/
```

- BehaviorSubject 是 Subject 的子类

```js
/**
 * 它总是保存最近向数据消费者发送的值，当一个Observer订阅后，它会即刻从BehaviorSubject收到“最新的值”。
 * 在第二个Observer订阅BehaviorSubject之前，它推送了2，虽然订阅在推送2之后，但是第二个Observer仍然能接受到2：
 */
var subject = new Rx.BehaviorSubject(0 /* 初始值 */);

subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

subject.next(1);
subject.next(2);

/** 第二个观察者订阅后会接受到之前推送的最新的值  */
subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

subject.next(3);

/*
  输出结果如下：
  observerA: 0
  observerA: 1
  observerA: 2
  observerB: 2
  observerA: 3
  observerB: 3
*/
```

- ReplaySubject 是 Subject 的子类

```js
/**
 * 通过 ReplaySubject可以向新的订阅者推送旧数值，t可以记录Observable的一部分状态（过去时间内推送的值）。
 * 一个ReplaySubject可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。
 */
var subject = new Rx.ReplaySubject(3 /* 回放数量 */);

subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

subject.next(1);
subject.next(2);
subject.next(3);
subject.next(4);

subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

subject.next(5);

/* 
输出如下:
observerA: 1
observerA: 2
observerA: 3
observerA: 4
observerB: 2
observerB: 3
observerB: 4
observerA: 5
observerB: 5
*/

/**
 * 除了回放数量，你也可以以毫秒为单位去指定“窗口时间”
 */

var subject = new Rx.ReplaySubject(100, 500 /* windowTime */);

subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

var i = 1;
setInterval(() => subject.next(i++), 200);

setTimeout(() => {
  subject.subscribe({
    next: v => console.log('observerB: ' + v)
  });
}, 1000);

/**
  输出结果：
  observerA: 1
  observerA: 2
  observerA: 3
  observerA: 4
  observerA: 5
  observerB: 3
  observerB: 4
  observerB: 5
  observerA: 6
  observerB: 6
*/
```

- AsyncSubject 是 Subject 的另外一个衍生类

```js
/*
 * Observable仅会在执行完成后，推送执行环境中的最后一个值。
 */
var subject = new Rx.AsyncSubject();

subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

subject.next(1);
subject.next(2);
subject.next(3);
subject.next(4);

subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

subject.next(5);
subject.complete();

/**
  输出结果如下：
  observerA: 5
  observerB: 5
*/
```

## 单词

```pug
lazy 懒惰的
magic 魔术
disposable 用后即丢弃的;一次性的;
immutability 不变性
accumulated 积累的
stream 流动 河流
dispose 处理 处置
reactive 反应的
programming 编程 程序设计
pure 纯洁的
chain 链子
evaluation 评估 计值
scheduler 调度程序
exception 例外
operator 操作符 操作人员
diagram 图标
marble 弹珠
newest 最新的
legacy 遗产
combine 结合 组合
anchor 锚
rect 矩形
bound 界限
scan 细看 扫描
buffer 缓冲区
throttle 节流阀
distinct 不同的

```
