# RxJs 核心知识点

## 函数 遍历器 Promise Observable 的特点

```bash
函数 调用后同步计算并返回单一值
生成器函数 | 遍历器 遍历过程中同步计算并返回0个到无穷多个值
Promise 异步执行中返回或者不返回单一值
Observable 同步或者异步计算并返回0个到无穷多个值
```

## 核心概念之 Observable(可观察者对象)

- 纯 JavaScript 代码展示可观察值对象实现原理

```js
/**  observer 参数就是 观察者 被订阅后会执行next方法回调*/
function subscribe(observer) {
  var intervalID = setInterval(() => {
    observer.next('hi');
  }, 1000);

  return function unsubscribe() {
    clearInterval(intervalID);
  };
}

/**
 * 订阅实际上就是具体的观察者的实现 next回调函数的具体实现
 * 订阅可观察者对象后会产生返回unsubscribe函数 用于取消订阅操作
 */
var unsubscribe = subscribe({ next: x => console.log(x) });

// 一段时间后:
unsubscribe(); // 终止
```

- 可观察者对象使用最佳实践

```js
/**
 * 除了使用create创建Observable，我们通常还使用创建操作符, 如 of，from， interval, 等来创建Observable
 * Observable在执行过程中，可以推送三种类型的值：
 * "Next" 通知： 实际产生的数据，包括数字、字符串、对象等 表示事件传递给观察者的数据
 * "Error" 通知：一个JavaScript错误或者异常
 * "Complete" 通知：一个不带有值的事件
 * 错误和完成通知仅会在执行阶段推送其一，并不会同时推送错误和完成通知。
 * 在错误或者完成通知被推送后，Observable不会再推送任何其他通知。
 * 观察者并不需要在Observable中进行注册，Observable也不需要维护订阅者的列表。
 */
var observable = Rx.Observable.create(function subscribe(observer) {
  try {
    observer.next(1);
    observer.next(2);
    observer.next(3);
    observer.complete(); // 结束
  } catch (err) {
    observer.error(err); // 捕获异常后推送错误通知
  }
});
/** 订阅这个可观察者对象  */
observable.subscribe({
  next: v => {}, // 订阅可观察者对象发送值的时候执行
  complete: () => {}, // 订阅可观察者对象完结的时候执行
  err: () => {} // 订阅可观察者对象发送错误的时候执行
});
```

- 可观察者对象分析

```js
/**
 * 核心概念
 * 如果不去订阅可观察者对象 Observable 则什么都不会执行
 * 两次订阅同样会产生两个独立的作用域 Observable不会被共享
 * 可观察者订阅的时候传入的参数可以只是一个回调函数，不需要一定有next: (v) => {}
 */
/** 创建一个可观察者对象  */
var foo = Rx.Observable.create(function(observer) {
  console.log('Hello');
  observer.next(42);
});

/** 添加了一个观察者  产生一个独立的作用域*/
foo.subscribe(function(x) {
  console.log(x);
});

/** 再添加一个观察者  参数一个独立的作用域*/
foo.subscribe(function(y) {
  console.log(y);
});

/**
 * 打印结果
  "Hello"
  42
  "Hello"
  42
 */
```

- 取消订阅可观察者

```js
/**
 * 在observable.subscribe被调用时(可观察者对象被订阅后)，观察者会与其执行作用域绑定，同时返回一个Subscription类型的对象
 */
var observable = Rx.Observable.from([10, 20, 30]);
/** 订阅后 可观察者对象会返回一个 Subscription类型的对象  */
var subscription = observable.subscribe(x => console.log(x));
/** 可以通过 Subscription类型的对象来取消订阅 */
subscription.unsubscribe();
```

## Observer 观察者

- 一个典型的观察者对象

```js
/** 创建一个可观察者对象  */
var observable = Rx.Observable.create(function subscribe(observer) {
  try {
    observer.next(1);
    observer.next(2);
    observer.next(3);
    observer.complete(); // 结束
  } catch (err) {
    observer.error(err); // 捕获异常后推送错误通知
  }
});
/**
 * 观察者们(Observers)就是一组callback函数的集合
 * 监听着每一个Observable流推送出的不同类型的通知，包括:next,error和complete。
 */
var observer = {
  next: x => console.log('Observer got a next value: ' + x),
  error: err => console.error('Observer got an error: ' + err),
  complete: () => console.log('Observer got a complete notification')
};

/** 观察者 订阅 可观察者对象  */
observable.subscribe(observer);
```

- 创建观察者的其他写法

```js
/**
 * 如果没有为某个类型的通知提供callback，Observable流的执行过程仍然会照常进行，
 * 但是响应的通知将会被忽略，因为观察者没有提供相应的callback来接收。
 */

var observer = {
  next: x => console.log('Observer got a next value: ' + x),
  error: err => console.error('Observer got an error: ' + err)
};

/**
 * 在observable.subscribe()内部，将会创建一个观察者对象(Observer object)，
 * 并将第一个参数提供的callback作为next通知的响应函数。接受三个类型通知的callback也可以分别以参数的形式提供:
 */
observable.subscribe(
  x => console.log('Observer got a next value: ' + x),
  err => console.error('Observer got an error: ' + err),
  () => console.log('Observer got a complete notification')
);
```

## Subscription 对象

- Subscription 的具体用法

```js
/**
 * Subscription是一个代表可以终止资源的对象，表示一个Observable的执行过程。
 * Subscription能够通过unsubscribe() 函数终止Observable的执行过程并释放相应资源。
 * Subscription提供了remove(otherSubscription)方法，可以删除一个Subscription嵌套的子Subscription
 */
var observable = Rx.Observable.interval(1000);
var subscription = observable.subscribe(x => console.log(x));

/** 取消对可观察者对象资源的订阅  */
subscription.unsubscribe();
```

- Subscription 可以嵌套使用

```js
var observable1 = Rx.Observable.interval(400);
var observable2 = Rx.Observable.interval(300);

var subscription = observable1.subscribe(x => console.log('first: ' + x));
var childSubscription = observable2.subscribe(x => console.log('second: ' + x));

/** 通过add方法，便可以实现Subscription的嵌套：  */
subscription.add(childSubscription);

setTimeout(() => {
  // 终止所有嵌套的Subscription
  subscription.unsubscribe();
}, 1000);
```

## Subject 主题

- 一个简单的 Subject 用法(作为可观察者对象被订阅)

```js
/**
 * 每一个Subject都是一个Observable（可观察对象
 * Subject是一类特殊的Observable，它可以向多个Observer多路推送数值
 * 每一个Observer都有自己独立的执行环境，而Subject可以共享一个执行环境。
 * Subject是一种可以多路推送的可观察对象。与EventEmitter类似，Subject维护着自己的Observer。
 */

/** 创建一个主题  */
var subject = new Rx.Subject();

/** 注册观察者1  */
subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

/** 注册观察者2  */
subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

subject.next(1);
subject.next(2);
/* 
  控制台输出结果如下：
  observerA: 1
  observerB: 1
  observerA: 2
  observerB: 2
 */
```

- 一个简单的 Subject 用法(作为一个观察者)

```js
/**
 * Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数
 */

/** 创建一个 Subject 对象 */
var subject = new Rx.Subject();

/** 注册观察者1  */
subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

/** 注册观察者2  */
subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

/** 创建一个普通的可观察者对象  */
var observable = Rx.Observable.from([1, 2, 3]);

/**
 * Subject作为一个观察者 去订阅这个普通的可观察者对象
 * Subject的作用——作为单路Observable转变为多路Observable的桥梁。
 */
observable.subscribe(subject); // 你可以传递Subject来订阅observable

/*
  执行后结果如下：
  observerA: 1
  observerB: 1
  observerA: 2
  observerB: 2
  observerA: 3
  observerB: 3
*/
```

- 使用 multicast() 和 connect() 方法 然普通的 Observable 实现多路推送

```js
/** 创建了一共可观察者对象  */
var source = Rx.Observable.from([1, 2, 3]);
/** 创建了一共主题  */
var subject = new Rx.Subject();
/**
 * 使用multicast multicast 返回的对象同时是ConnectableObservable类型的，拥有connect() 方法
 * multicast方法返回一个类似于Observable的可观察对象，但是在其被订阅后，它会表现Subject的特性。
 */
var multicasted = source.multicast(subject);

// 通过`subject.subscribe({...})`订阅Subject的Observer观察者：
multicasted.subscribe({
  next: v => console.log('observerA: ' + v)
});
multicasted.subscribe({
  next: v => console.log('observerB: ' + v)
});

/**
 * 调用connect()后，Observable开始执行  让Subject从数据源订阅开始生效
 * connect()会返回一个Subscription供调用者来终止执行
 */
multicasted.connect();
```

- refCount(引用计数) 使得多路推送的 Observable 在被订阅后自动执行，在所有观察者取消订阅后，停止执行。

```js
/**
 * 第一个Observer订阅Subject后自动connnect，当所有Observer都取消订阅后终止这个Subject。
 * 在ConnectableObservable类型的Observable上调用refCount()方法
 * 方法会进行引用计数：记录Observable被订阅的行为。当订阅数从 0 到 1时refCount() 会调用connect() 方法。
 * 到订阅数从1 到 0，他会终止整个执行过程。
 */

var source = Rx.Observable.interval(500);
var subject = new Rx.Subject();
/** 调用后会返回一个Observable而不是新的ConnectableObservable。  */
var refCounted = source.multicast(subject).refCount();
var subscription1, subscription2, subscriptionConnect;

console.log('observerA subscribed');
subscription1 = refCounted.subscribe({
  next: v => console.log('observerA: ' + v)
});

setTimeout(() => {
  console.log('observerB subscribed');
  subscription2 = refCounted.subscribe({
    next: v => console.log('observerB: ' + v)
  });
}, 600);

setTimeout(() => {
  console.log('observerA unsubscribed');
  subscription1.unsubscribe();
}, 1200);

setTimeout(() => {
  console.log('observerB unsubscribed');
  subscription2.unsubscribe();
}, 2000);

/*
  执行输出结果如下:
  observerA subscribed
  observerA: 0
  observerB subscribed
  observerA: 1
  observerB: 1
  observerA unsubscribed
  observerB: 2
  observerB unsubscribed
*/
```

- BehaviorSubject 是 Subject 的子类

```js
/**
 * 它总是保存最近向数据消费者发送的值，当一个Observer订阅后，它会即刻从BehaviorSubject收到“最新的值”。
 * 在第二个Observer订阅BehaviorSubject之前，它推送了2，虽然订阅在推送2之后，但是第二个Observer仍然能接受到2：
 */
var subject = new Rx.BehaviorSubject(0 /* 初始值 */);

subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

subject.next(1);
subject.next(2);

/** 第二个观察者订阅后会接受到之前推送的最新的值  */
subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

subject.next(3);

/*
  输出结果如下：
  observerA: 0
  observerA: 1
  observerA: 2
  observerB: 2
  observerA: 3
  observerB: 3
*/
```

- ReplaySubject 是 Subject 的子类

```js
/**
 * 通过 ReplaySubject可以向新的订阅者推送旧数值，t可以记录Observable的一部分状态（过去时间内推送的值）。
 * 一个ReplaySubject可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。
 */
var subject = new Rx.ReplaySubject(3 /* 回放数量 */);

subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

subject.next(1);
subject.next(2);
subject.next(3);
subject.next(4);

subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

subject.next(5);

/* 
输出如下:
observerA: 1
observerA: 2
observerA: 3
observerA: 4
observerB: 2
observerB: 3
observerB: 4
observerA: 5
observerB: 5
*/

/**
 * 除了回放数量，你也可以以毫秒为单位去指定“窗口时间”
 */

var subject = new Rx.ReplaySubject(100, 500 /* windowTime */);

subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

var i = 1;
setInterval(() => subject.next(i++), 200);

setTimeout(() => {
  subject.subscribe({
    next: v => console.log('observerB: ' + v)
  });
}, 1000);

/**
  输出结果：
  observerA: 1
  observerA: 2
  observerA: 3
  observerA: 4
  observerA: 5
  observerB: 3
  observerB: 4
  observerB: 5
  observerA: 6
  observerB: 6
*/
```

- AsyncSubject 是 Subject 的另外一个衍生类

```js
/*
 * Observable仅会在执行完成后，推送执行环境中的最后一个值。
 */
var subject = new Rx.AsyncSubject();

subject.subscribe({
  next: v => console.log('observerA: ' + v)
});

subject.next(1);
subject.next(2);
subject.next(3);
subject.next(4);

subject.subscribe({
  next: v => console.log('observerB: ' + v)
});

subject.next(5);
subject.complete();

/**
  输出结果如下：
  observerA: 5
  observerB: 5
*/
```

## 单词

```pug
lazy 懒惰的
magic 魔术
disposable 用后即丢弃的;一次性的;
immutability 不变性
accumulated 积累的
stream 流动 河流
dispose 处理 处置
reactive 反应的
programming 编程 程序设计
pure 纯洁的
chain 链子
```
